/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


/**
 *
 * FULL TILT
 * http://github.com/richtr/Full-Tilt
 *
 * A standalone DeviceOrientation + DeviceMotion JavaScript library that
 * normalises orientation sensor input, applies relevant screen orientation
 * transforms, returns Euler Angle, Quaternion and Rotation
 * Matrix representations back to web developers and provides conversion
 * between all supported orientation representation types.
 *
 * Copyright: 2014 Rich Tibbett
 * License:   MIT
 *
 */

(function ( window ) {

// Only initialize the FULLTILT API if it is not already attached to the DOM
if ( window.FULLTILT !== undefined && window.FULLTILT !== null ) {
	return;
}

var M_PI   = Math.PI;
var M_PI_2 = M_PI / 2;
var M_2_PI = 2 * M_PI;

// Degree to Radian conversion
var degToRad = M_PI / 180;
var radToDeg = 180 / M_PI;

// Internal device orientation + motion variables
var sensors = {
	"orientation": {
		active:    false,
		callbacks: [],
		data:      undefined
	},
	"motion": {
		active:    false,
		callbacks: [],
		data:      undefined
	}
};
var screenActive = false;

// Internal screen orientation variables
var hasScreenOrientationAPI = window.screen && window.screen.orientation && window.screen.orientation.angle !== undefined && window.screen.orientation.angle !== null ? true : false;
var screenOrientationAngle = ( hasScreenOrientationAPI ? window.screen.orientation.angle : ( window.orientation || 0 ) ) * degToRad;

var SCREEN_ROTATION_0        = 0,
    SCREEN_ROTATION_90       = M_PI_2,
    SCREEN_ROTATION_180      = M_PI,
    SCREEN_ROTATION_270      = M_2_PI / 3,
    SCREEN_ROTATION_MINUS_90 = - M_PI_2;

// Math.sign polyfill
function sign(x) {
	x = +x; // convert to a number
	if (x === 0 || isNaN(x))
		return x;
	return x > 0 ? 1 : -1;
}

///// Promise-based Sensor Data checker //////

function SensorCheck(sensorRootObj) {

	var promise = new Promise(function(resolve, reject) {

		var runCheck = function (tries) {

			setTimeout(function() {

				if (sensorRootObj && sensorRootObj.data) {

					resolve();

				} else if (tries >= 20) {

					reject();

				} else {

					runCheck(++tries);

				}

			}, 50);

		};

		runCheck(0);

	});

	return promise;

}

////// Internal Event Handlers //////

function handleScreenOrientationChange () {

	if ( hasScreenOrientationAPI ) {

		screenOrientationAngle = ( window.screen.orientation.angle || 0 ) * degToRad;

	} else {

		screenOrientationAngle = ( window.orientation || 0 ) * degToRad;

	}

}

function handleDeviceOrientationChange ( event ) {

	sensors.orientation.data = event;

	// Fire every callback function each time deviceorientation is updated
	for ( var i in sensors.orientation.callbacks ) {

		sensors.orientation.callbacks[ i ].call( this );

	}

}

function handleDeviceMotionChange ( event ) {

	sensors.motion.data = event;

	// Fire every callback function each time devicemotion is updated
	for ( var i in sensors.motion.callbacks ) {

		sensors.motion.callbacks[ i ].call( this );

	}

}

///// FULLTILT API Root Object /////

var FULLTILT = {};

FULLTILT.version = "0.5.3";

///// FULLTILT API Root Methods /////

FULLTILT.getDeviceOrientation = function(options) {

	var promise = new Promise(function(resolve, reject) {

		var control = new FULLTILT.DeviceOrientation(options);

		control.start();

		var orientationSensorCheck = new SensorCheck(sensors.orientation);

		orientationSensorCheck.then(function() {

			control._alphaAvailable = (sensors.orientation.data.alpha && sensors.orientation.data.alpha !== null);
			control._betaAvailable = (sensors.orientation.data.beta && sensors.orientation.data.beta !== null);
			control._gammaAvailable = (sensors.orientation.data.gamma && sensors.orientation.data.gamma !== null);

			resolve(control);

		}).catch(function() {

			control.stop();
			reject('DeviceOrientation is not supported');

		});

	});

	return promise;

};

FULLTILT.getDeviceMotion = function(options) {

	var promise = new Promise(function(resolve, reject) {

		var control = new FULLTILT.DeviceMotion(options);

		control.start();

		var motionSensorCheck = new SensorCheck(sensors.motion);

		motionSensorCheck.then(function() {

			control._accelerationXAvailable = (sensors.motion.data.acceleration && sensors.motion.data.acceleration.x);
			control._accelerationYAvailable = (sensors.motion.data.acceleration && sensors.motion.data.acceleration.y);
			control._accelerationZAvailable = (sensors.motion.data.acceleration && sensors.motion.data.acceleration.z);

			control._accelerationIncludingGravityXAvailable = (sensors.motion.data.accelerationIncludingGravity && sensors.motion.data.accelerationIncludingGravity.x);
			control._accelerationIncludingGravityYAvailable = (sensors.motion.data.accelerationIncludingGravity && sensors.motion.data.accelerationIncludingGravity.y);
			control._accelerationIncludingGravityZAvailable = (sensors.motion.data.accelerationIncludingGravity && sensors.motion.data.accelerationIncludingGravity.z);

			control._rotationRateAlphaAvailable = (sensors.motion.data.rotationRate && sensors.motion.data.rotationRate.alpha);
			control._rotationRateBetaAvailable = (sensors.motion.data.rotationRate && sensors.motion.data.rotationRate.beta);
			control._rotationRateGammaAvailable = (sensors.motion.data.rotationRate && sensors.motion.data.rotationRate.gamma);

			resolve(control);

		}).catch(function() {

			control.stop();
			reject('DeviceMotion is not supported');

		});

	});

	return promise;

};


////// FULLTILT.Quaternion //////

FULLTILT.Quaternion = function ( x, y, z, w ) {

	var quat, outQuat;

	this.set = function ( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = w || 1;

	};

	this.copy = function ( quaternion ) {

		this.x = quaternion.x;
		this.y = quaternion.y;
		this.z = quaternion.z;
		this.w = quaternion.w;

	};

	this.setFromEuler = (function () {

		var _x, _y, _z;
		var _x_2, _y_2, _z_2;
		var cX, cY, cZ, sX, sY, sZ;

		return function ( euler ) {

			euler = euler || {};

			_z = ( euler.alpha || 0 ) * degToRad;
			_x = ( euler.beta || 0 ) * degToRad;
			_y = ( euler.gamma || 0 ) * degToRad;

			_z_2 = _z / 2;
			_x_2 = _x / 2;
			_y_2 = _y / 2;

			cX = Math.cos( _x_2 );
			cY = Math.cos( _y_2 );
			cZ = Math.cos( _z_2 );
			sX = Math.sin( _x_2 );
			sY = Math.sin( _y_2 );
			sZ = Math.sin( _z_2 );

			this.set(
				sX * cY * cZ - cX * sY * sZ, // x
				cX * sY * cZ + sX * cY * sZ, // y
				cX * cY * sZ + sX * sY * cZ, // z
				cX * cY * cZ - sX * sY * sZ  // w
			);

			this.normalize();

			return this;

		};

	})();

	this.setFromRotationMatrix = (function () {

		var R;

		return function( matrix ) {

			R = matrix.elements;

			this.set(
				0.5 * Math.sqrt( 1 + R[0] - R[4] - R[8] ) * sign( R[7] - R[5] ), // x
				0.5 * Math.sqrt( 1 - R[0] + R[4] - R[8] ) * sign( R[2] - R[6] ), // y
				0.5 * Math.sqrt( 1 - R[0] - R[4] + R[8] ) * sign( R[3] - R[1] ), // z
				0.5 * Math.sqrt( 1 + R[0] + R[4] + R[8] )                        // w
			);

			return this;

		};

	})();

	this.multiply = function ( quaternion ) {

		outQuat = FULLTILT.Quaternion.prototype.multiplyQuaternions( this, quaternion );
		this.copy( outQuat );

		return this;

	};

	this.rotateX = function ( angle ) {

		outQuat = FULLTILT.Quaternion.prototype.rotateByAxisAngle( this, [ 1, 0, 0 ], angle );
		this.copy( outQuat );

		return this;

	};

	this.rotateY = function ( angle ) {

		outQuat = FULLTILT.Quaternion.prototype.rotateByAxisAngle( this, [ 0, 1, 0 ], angle );
		this.copy( outQuat );

		return this;

	};

	this.rotateZ = function ( angle ) {

		outQuat = FULLTILT.Quaternion.prototype.rotateByAxisAngle( this, [ 0, 0, 1 ], angle );
		this.copy( outQuat );

		return this;

	};

	this.normalize = function () {

		return FULLTILT.Quaternion.prototype.normalize( this );

	};

	// Initialize object values
	this.set( x, y, z, w );

};

FULLTILT.Quaternion.prototype = {

	constructor: FULLTILT.Quaternion,

	multiplyQuaternions: function () {

		var multipliedQuat = new FULLTILT.Quaternion();

		return function ( a, b ) {

			var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
			var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

			multipliedQuat.set(
				qax * qbw + qaw * qbx + qay * qbz - qaz * qby, // x
				qay * qbw + qaw * qby + qaz * qbx - qax * qbz, // y
				qaz * qbw + qaw * qbz + qax * qby - qay * qbx, // z
				qaw * qbw - qax * qbx - qay * qby - qaz * qbz  // w
			);

			return multipliedQuat;

		};

	}(),

	normalize: function( q ) {

		var len = Math.sqrt( q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w );

		if ( len === 0 ) {

			q.x = 0;
			q.y = 0;
			q.z = 0;
			q.w = 1;

		} else {

			len = 1 / len;

			q.x *= len;
			q.y *= len;
			q.z *= len;
			q.w *= len;

		}

		return q;

	},

	rotateByAxisAngle: function () {

		var outputQuaternion = new FULLTILT.Quaternion();
		var transformQuaternion = new FULLTILT.Quaternion();

		var halfAngle, sA;

		return function ( targetQuaternion, axis, angle ) {

			halfAngle = ( angle || 0 ) / 2;
			sA = Math.sin( halfAngle );

			transformQuaternion.set(
				( axis[ 0 ] || 0 ) * sA, // x
				( axis[ 1 ] || 0 ) * sA, // y
				( axis[ 2 ] || 0 ) * sA, // z
				Math.cos( halfAngle )    // w
			);

			// Multiply quaternion by q
			outputQuaternion = FULLTILT.Quaternion.prototype.multiplyQuaternions( targetQuaternion, transformQuaternion );

			return FULLTILT.Quaternion.prototype.normalize( outputQuaternion );

		};

	}()

};

////// FULLTILT.RotationMatrix //////

FULLTILT.RotationMatrix = function ( m11, m12, m13, m21, m22, m23, m31, m32, m33 ) {

	var outMatrix;

	this.elements = new Float32Array( 9 );

	this.identity = function () {

		this.set(
			1, 0, 0,
			0, 1, 0,
			0, 0, 1
		);

		return this;

	};

	this.set = function ( m11, m12, m13, m21, m22, m23, m31, m32, m33 ) {

		this.elements[ 0 ] = m11 || 1;
		this.elements[ 1 ] = m12 || 0;
		this.elements[ 2 ] = m13 || 0;
		this.elements[ 3 ] = m21 || 0;
		this.elements[ 4 ] = m22 || 1;
		this.elements[ 5 ] = m23 || 0;
		this.elements[ 6 ] = m31 || 0;
		this.elements[ 7 ] = m32 || 0;
		this.elements[ 8 ] = m33 || 1;

	};

	this.copy = function ( matrix ) {

		this.elements[ 0 ] = matrix.elements[ 0 ];
		this.elements[ 1 ] = matrix.elements[ 1 ];
		this.elements[ 2 ] = matrix.elements[ 2 ];
		this.elements[ 3 ] = matrix.elements[ 3 ];
		this.elements[ 4 ] = matrix.elements[ 4 ];
		this.elements[ 5 ] = matrix.elements[ 5 ];
		this.elements[ 6 ] = matrix.elements[ 6 ];
		this.elements[ 7 ] = matrix.elements[ 7 ];
		this.elements[ 8 ] = matrix.elements[ 8 ];

	};

	this.setFromEuler = (function() {

		var _x, _y, _z;
		var cX, cY, cZ, sX, sY, sZ;

		return function ( euler ) {

			euler = euler || {};

			_z = ( euler.alpha || 0 ) * degToRad;
			_x = ( euler.beta || 0 ) * degToRad;
			_y = ( euler.gamma || 0 ) * degToRad;

			cX = Math.cos( _x );
			cY = Math.cos( _y );
			cZ = Math.cos( _z );
			sX = Math.sin( _x );
			sY = Math.sin( _y );
			sZ = Math.sin( _z );

			//
			// ZXY-ordered rotation matrix construction.
			//

			this.set(
				cZ * cY - sZ * sX * sY, // 1,1
				- cX * sZ,              // 1,2
				cY * sZ * sX + cZ * sY, // 1,3

				cY * sZ + cZ * sX * sY, // 2,1
				cZ * cX,                // 2,2
				sZ * sY - cZ * cY * sX, // 2,3

				- cX * sY,              // 3,1
				sX,                     // 3,2
				cX * cY                 // 3,3
			);

			this.normalize();

			return this;

		};

	})();

	this.setFromQuaternion = (function() {

		var sqw, sqx, sqy, sqz;

		return function( q ) {

			sqw = q.w * q.w;
			sqx = q.x * q.x;
			sqy = q.y * q.y;
			sqz = q.z * q.z;

			this.set(
				sqw + sqx - sqy - sqz,       // 1,1
				2 * (q.x * q.y - q.w * q.z), // 1,2
				2 * (q.x * q.z + q.w * q.y), // 1,3

				2 * (q.x * q.y + q.w * q.z), // 2,1
				sqw - sqx + sqy - sqz,       // 2,2
				2 * (q.y * q.z - q.w * q.x), // 2,3

				2 * (q.x * q.z - q.w * q.y), // 3,1
				2 * (q.y * q.z + q.w * q.x), // 3,2
				sqw - sqx - sqy + sqz        // 3,3
			);

			return this;

		};

	})();

	this.multiply = function ( m ) {

		outMatrix = FULLTILT.RotationMatrix.prototype.multiplyMatrices( this, m );
		this.copy( outMatrix );

		return this;

	};

	this.rotateX = function ( angle ) {

		outMatrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( this, [ 1, 0, 0 ], angle );
		this.copy( outMatrix );

		return this;

	};

	this.rotateY = function ( angle ) {

		outMatrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( this, [ 0, 1, 0 ], angle );
		this.copy( outMatrix );

		return this;

	};

	this.rotateZ = function ( angle ) {

		outMatrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( this, [ 0, 0, 1 ], angle );
		this.copy( outMatrix );

		return this;

	};

	this.normalize = function () {

		return FULLTILT.RotationMatrix.prototype.normalize( this );

	};

	// Initialize object values
	this.set( m11, m12, m13, m21, m22, m23, m31, m32, m33 );

};

FULLTILT.RotationMatrix.prototype = {

	constructor: FULLTILT.RotationMatrix,

	multiplyMatrices: function () {

		var matrix = new FULLTILT.RotationMatrix();

		var aE, bE;

		return function ( a, b ) {

			aE = a.elements;
			bE = b.elements;

			matrix.set(
				aE[0] * bE[0] + aE[1] * bE[3] + aE[2] * bE[6],
				aE[0] * bE[1] + aE[1] * bE[4] + aE[2] * bE[7],
				aE[0] * bE[2] + aE[1] * bE[5] + aE[2] * bE[8],

				aE[3] * bE[0] + aE[4] * bE[3] + aE[5] * bE[6],
				aE[3] * bE[1] + aE[4] * bE[4] + aE[5] * bE[7],
				aE[3] * bE[2] + aE[4] * bE[5] + aE[5] * bE[8],

				aE[6] * bE[0] + aE[7] * bE[3] + aE[8] * bE[6],
				aE[6] * bE[1] + aE[7] * bE[4] + aE[8] * bE[7],
				aE[6] * bE[2] + aE[7] * bE[5] + aE[8] * bE[8]
			);

			return matrix;

		};

	}(),

	normalize: function( matrix ) {

		var R = matrix.elements;

		// Calculate matrix determinant
		var determinant = R[0] * R[4] * R[8] - R[0] * R[5] * R[7] - R[1] * R[3] * R[8] + R[1] * R[5] * R[6] + R[2] * R[3] * R[7] - R[2] * R[4] * R[6];

		// Normalize matrix values
		R[0] /= determinant;
		R[1] /= determinant;
		R[2] /= determinant;
		R[3] /= determinant;
		R[4] /= determinant;
		R[5] /= determinant;
		R[6] /= determinant;
		R[7] /= determinant;
		R[8] /= determinant;

		matrix.elements = R;

		return matrix;

	},

	rotateByAxisAngle: function () {

		var outputMatrix = new FULLTILT.RotationMatrix();
		var transformMatrix = new FULLTILT.RotationMatrix();

		var sA, cA;
		var validAxis = false;

		return function ( targetRotationMatrix, axis, angle ) {

			transformMatrix.identity(); // reset transform matrix

			validAxis = false;

			sA = Math.sin( angle );
			cA = Math.cos( angle );

			if ( axis[ 0 ] === 1 && axis[ 1 ] === 0 && axis[ 2 ] === 0 ) { // x

				validAxis = true;

				transformMatrix.elements[4] = cA;
				transformMatrix.elements[5] = -sA;
				transformMatrix.elements[7] = sA;
				transformMatrix.elements[8] = cA;

	 		} else if ( axis[ 1 ] === 1 && axis[ 0 ] === 0 && axis[ 2 ] === 0 ) { // y

				validAxis = true;

				transformMatrix.elements[0] = cA;
				transformMatrix.elements[2] = sA;
				transformMatrix.elements[6] = -sA;
				transformMatrix.elements[8] = cA;

	 		} else if ( axis[ 2 ] === 1 && axis[ 0 ] === 0 && axis[ 1 ] === 0 ) { // z

				validAxis = true;

				transformMatrix.elements[0] = cA;
				transformMatrix.elements[1] = -sA;
				transformMatrix.elements[3] = sA;
				transformMatrix.elements[4] = cA;

	 		}

			if ( validAxis ) {

				outputMatrix = FULLTILT.RotationMatrix.prototype.multiplyMatrices( targetRotationMatrix, transformMatrix );

				outputMatrix = FULLTILT.RotationMatrix.prototype.normalize( outputMatrix );

			} else {

				outputMatrix = targetRotationMatrix;

			}

			return outputMatrix;

		};

	}()

};

////// FULLTILT.Euler //////

FULLTILT.Euler = function ( alpha, beta, gamma ) {

	this.set = function ( alpha, beta, gamma ) {

		this.alpha = alpha || 0;
		this.beta  = beta  || 0;
		this.gamma = gamma || 0;

	};

	this.copy = function ( inEuler ) {

		this.alpha = inEuler.alpha;
		this.beta  = inEuler.beta;
		this.gamma = inEuler.gamma;

	};

	this.setFromRotationMatrix = (function () {

		var R, _alpha, _beta, _gamma;

		return function ( matrix ) {

			R = matrix.elements;

			if (R[8] > 0) { // cos(beta) > 0

				_alpha = Math.atan2(-R[1], R[4]);
				_beta  = Math.asin(R[7]); // beta (-pi/2, pi/2)
				_gamma = Math.atan2(-R[6], R[8]); // gamma (-pi/2, pi/2)

			} else if (R[8] < 0) {  // cos(beta) < 0

				_alpha = Math.atan2(R[1], -R[4]);
				_beta  = -Math.asin(R[7]);
				_beta  += (_beta >= 0) ? - M_PI : M_PI; // beta [-pi,-pi/2) U (pi/2,pi)
				_gamma = Math.atan2(R[6], -R[8]); // gamma (-pi/2, pi/2)

			} else { // R[8] == 0

				if (R[6] > 0) {  // cos(gamma) == 0, cos(beta) > 0

					_alpha = Math.atan2(-R[1], R[4]);
					_beta  = Math.asin(R[7]); // beta [-pi/2, pi/2]
					_gamma = - M_PI_2; // gamma = -pi/2

				} else if (R[6] < 0) { // cos(gamma) == 0, cos(beta) < 0

					_alpha = Math.atan2(R[1], -R[4]);
					_beta  = -Math.asin(R[7]);
					_beta  += (_beta >= 0) ? - M_PI : M_PI; // beta [-pi,-pi/2) U (pi/2,pi)
					_gamma = - M_PI_2; // gamma = -pi/2

				} else { // R[6] == 0, cos(beta) == 0

					// gimbal lock discontinuity
					_alpha = Math.atan2(R[3], R[0]);
					_beta  = (R[7] > 0) ? M_PI_2 : - M_PI_2; // beta = +-pi/2
					_gamma = 0; // gamma = 0

				}

			}

			// alpha is in [-pi, pi], make sure it is in [0, 2*pi).
			if (_alpha < 0) {
				_alpha += M_2_PI; // alpha [0, 2*pi)
			}

			// Convert to degrees
			_alpha *= radToDeg;
			_beta  *= radToDeg;
			_gamma *= radToDeg;

			// apply derived euler angles to current object
			this.set( _alpha, _beta, _gamma );

		};

	})();

	this.setFromQuaternion = (function () {

		var _alpha, _beta, _gamma;

		return function ( q ) {

			var sqw = q.w * q.w;
			var sqx = q.x * q.x;
			var sqy = q.y * q.y;
			var sqz = q.z * q.z;

			var unitLength = sqw + sqx + sqy + sqz; // Normalised == 1, otherwise correction divisor.
			var wxyz = q.w * q.x + q.y * q.z;
			var epsilon = 1e-6; // rounding factor

			if (wxyz > (0.5 - epsilon) * unitLength) {

				_alpha = 2 * Math.atan2(q.y, q.w);
				_beta = M_PI_2;
				_gamma = 0;

			} else if (wxyz < (-0.5 + epsilon) * unitLength) {

				_alpha = -2 * Math.atan2(q.y, q.w);
				_beta = -M_PI_2;
				_gamma = 0;

			} else {

				var aX = sqw - sqx + sqy - sqz;
				var aY = 2 * (q.w * q.z - q.x * q.y);

				var gX = sqw - sqx - sqy + sqz;
				var gY = 2 * (q.w * q.y - q.x * q.z);

				if (gX > 0) {

					_alpha = Math.atan2(aY, aX);
					_beta  = Math.asin(2 * wxyz / unitLength);
					_gamma = Math.atan2(gY, gX);

				} else {

					_alpha = Math.atan2(-aY, -aX);
					_beta  = -Math.asin(2 * wxyz / unitLength);
					_beta  += _beta < 0 ? M_PI : - M_PI;
					_gamma = Math.atan2(-gY, -gX);

				}

			}

			// alpha is in [-pi, pi], make sure it is in [0, 2*pi).
			if (_alpha < 0) {
				_alpha += M_2_PI; // alpha [0, 2*pi)
			}

			// Convert to degrees
			_alpha *= radToDeg;
			_beta  *= radToDeg;
			_gamma *= radToDeg;

			// apply derived euler angles to current object
			this.set( _alpha, _beta, _gamma );

		};

	})();

	this.rotateX = function ( angle ) {

		FULLTILT.Euler.prototype.rotateByAxisAngle( this, [ 1, 0, 0 ], angle );

		return this;

	};

	this.rotateY = function ( angle ) {

		FULLTILT.Euler.prototype.rotateByAxisAngle( this, [ 0, 1, 0 ], angle );

		return this;

	};

	this.rotateZ = function ( angle ) {

		FULLTILT.Euler.prototype.rotateByAxisAngle( this, [ 0, 0, 1 ], angle );

		return this;

	};

	// Initialize object values
	this.set( alpha, beta, gamma );

};

FULLTILT.Euler.prototype = {

	constructor: FULLTILT.Euler,

	rotateByAxisAngle: function () {

		var _matrix = new FULLTILT.RotationMatrix();
		var outEuler;

		return function ( targetEuler, axis, angle ) {

			_matrix.setFromEuler( targetEuler );

			_matrix = FULLTILT.RotationMatrix.prototype.rotateByAxisAngle( _matrix, axis, angle );

			targetEuler.setFromRotationMatrix( _matrix );

			return targetEuler;

		};

	}()

};

///// FULLTILT.DeviceOrientation //////

FULLTILT.DeviceOrientation = function (options) {

	this.options = options || {}; // by default use UA deviceorientation 'type' ("game" on iOS, "world" on Android)

	var tries = 0;
	var maxTries = 200;
	var successCount = 0;
	var successThreshold = 10;

	this.alphaOffsetScreen = 0;
	this.alphaOffsetDevice = undefined;

	// Create a game-based deviceorientation object (initial alpha === 0 degrees)
	if (this.options.type === "game") {

		var setGameAlphaOffset = function(evt) {

			if (evt.alpha !== null) { // do regardless of whether 'evt.absolute' is also true
				this.alphaOffsetDevice = new FULLTILT.Euler(evt.alpha, 0, 0);
				this.alphaOffsetDevice.rotateZ( -screenOrientationAngle );

				// Discard first {successThreshold} responses while a better compass lock is found by UA
				if(++successCount >= successThreshold) {
					window.removeEventListener( 'deviceorientation', setGameAlphaOffset, false );
					return;
				}
			}

			if(++tries >= maxTries) {
				window.removeEventListener( 'deviceorientation', setGameAlphaOffset, false );
			}

		}.bind(this);

		window.addEventListener( 'deviceorientation', setGameAlphaOffset, false );

	// Create a compass-based deviceorientation object (initial alpha === compass degrees)
	} else if (this.options.type === "world") {

		var setCompassAlphaOffset = function(evt) {

			if (evt.absolute !== true && evt.webkitCompassAccuracy !== undefined && evt.webkitCompassAccuracy !== null && +evt.webkitCompassAccuracy >= 0 && +evt.webkitCompassAccuracy < 50) {
				this.alphaOffsetDevice = new FULLTILT.Euler(evt.webkitCompassHeading, 0, 0);
				this.alphaOffsetDevice.rotateZ( screenOrientationAngle );
				this.alphaOffsetScreen = screenOrientationAngle;

				// Discard first {successThreshold} responses while a better compass lock is found by UA
				if(++successCount >= successThreshold) {
					window.removeEventListener( 'deviceorientation', setCompassAlphaOffset, false );
					return;
				}
			}

			if(++tries >= maxTries) {
				window.removeEventListener( 'deviceorientation', setCompassAlphaOffset, false );
			}

		}.bind(this);

		window.addEventListener( 'deviceorientation', setCompassAlphaOffset, false );

	} // else... use whatever orientation system the UA provides ("game" on iOS, "world" on Android)

};

FULLTILT.DeviceOrientation.prototype = {

	constructor: FULLTILT.DeviceOrientation,

	start: function ( callback ) {

		if ( callback && Object.prototype.toString.call( callback ) == '[object Function]' ) {

			sensors.orientation.callbacks.push( callback );

		}

		if( !screenActive ) {

			if ( hasScreenOrientationAPI ) {

			window.screen.orientation.addEventListener( 'change', handleScreenOrientationChange, false );

			} else {

				window.addEventListener( 'orientationchange', handleScreenOrientationChange, false );

			}

		}

		if ( !sensors.orientation.active ) {

			window.addEventListener( 'deviceorientation', handleDeviceOrientationChange, false );

			sensors.orientation.active = true;

		}

	},

	stop: function () {

		if ( sensors.orientation.active ) {

			window.removeEventListener( 'deviceorientation', handleDeviceOrientationChange, false );

			sensors.orientation.active = false;

		}

	},

	listen: function( callback ) {

		this.start( callback );

	},

	getFixedFrameQuaternion: (function () {

		var euler = new FULLTILT.Euler();
		var matrix = new FULLTILT.RotationMatrix();
		var quaternion = new FULLTILT.Quaternion();

		return function() {

			var orientationData = sensors.orientation.data || { alpha: 0, beta: 0, gamma: 0 };

			var adjustedAlpha = orientationData.alpha;

			if (this.alphaOffsetDevice) {
				matrix.setFromEuler( this.alphaOffsetDevice );
				matrix.rotateZ( - this.alphaOffsetScreen );
				euler.setFromRotationMatrix( matrix );

				if (euler.alpha < 0) {
					euler.alpha += 360;
				}

				euler.alpha %= 360;

				adjustedAlpha -= euler.alpha;
			}

			euler.set(
				adjustedAlpha,
				orientationData.beta,
				orientationData.gamma
			);

			quaternion.setFromEuler( euler );

			return quaternion;

		};

	})(),

	getScreenAdjustedQuaternion: (function () {

		var quaternion;

		return function() {

			quaternion = this.getFixedFrameQuaternion();

			// Automatically apply screen orientation transform
			quaternion.rotateZ( - screenOrientationAngle );

			return quaternion;

		};

	})(),

	getFixedFrameMatrix: (function () {

		var euler = new FULLTILT.Euler();
		var matrix = new FULLTILT.RotationMatrix();

		return function () {

			var orientationData = sensors.orientation.data || { alpha: 0, beta: 0, gamma: 0 };

			var adjustedAlpha = orientationData.alpha;

			if (this.alphaOffsetDevice) {
				matrix.setFromEuler( this.alphaOffsetDevice );
				matrix.rotateZ( - this.alphaOffsetScreen );
				euler.setFromRotationMatrix( matrix );

				if (euler.alpha < 0) {
					euler.alpha += 360;
				}

				euler.alpha %= 360;

				adjustedAlpha -= euler.alpha;
			}

			euler.set(
				adjustedAlpha,
				orientationData.beta,
				orientationData.gamma
			);

			matrix.setFromEuler( euler );

			return matrix;

		};

	})(),

	getScreenAdjustedMatrix: (function () {

		var matrix;

		return function () {

			matrix = this.getFixedFrameMatrix();

			// Automatically apply screen orientation transform
			matrix.rotateZ( - screenOrientationAngle );

			return matrix;

		};

	})(),

	getFixedFrameEuler: (function () {

		var euler = new FULLTILT.Euler();
		var matrix;

		return function () {

			matrix = this.getFixedFrameMatrix();

			euler.setFromRotationMatrix( matrix );

			return euler;

		};

	})(),

	getScreenAdjustedEuler: (function () {

		var euler = new FULLTILT.Euler();
		var matrix;

		return function () {

			matrix = this.getScreenAdjustedMatrix();

			euler.setFromRotationMatrix( matrix );

			return euler;

		};

	})(),

	isAbsolute: function () {

		if ( sensors.orientation.data && sensors.orientation.data.absolute === true ) {
			return true;
		}

		return false;

	},

	getLastRawEventData: function () {

		return sensors.orientation.data || {};

	},

	_alphaAvailable: false,
	_betaAvailable: false,
	_gammaAvailable: false,

	isAvailable: function(_valueType){

		switch(_valueType){
			case this.ALPHA:
				return this._alphaAvailable;

			case this.BETA:
				return this._betaAvailable;

			case this.GAMMA:
				return this._gammaAvailable;
		}

	},

	ALPHA: 'alpha',
	BETA: 'beta',
	GAMMA: 'gamma'

};


///// FULLTILT.DeviceMotion //////

FULLTILT.DeviceMotion = function (options) {

	this.options = options || {}; // placeholder object since no options are currently supported

};

FULLTILT.DeviceMotion.prototype = {

	constructor: FULLTILT.DeviceMotion,

	start: function ( callback ) {

		if ( callback && Object.prototype.toString.call( callback ) == '[object Function]' ) {

			sensors.motion.callbacks.push( callback );

		}

		if( !screenActive ) {

			if ( hasScreenOrientationAPI ) {

				window.screen.orientation.addEventListener( 'change', handleScreenOrientationChange, false );

			} else {

				window.addEventListener( 'orientationchange', handleScreenOrientationChange, false );

			}

		}

		if ( !sensors.motion.active ) {

			window.addEventListener( 'devicemotion', handleDeviceMotionChange, false );

			sensors.motion.active = true;

		}

	},

	stop: function () {

		if ( sensors.motion.active ) {

			window.removeEventListener( 'devicemotion', handleDeviceMotionChange, false );

			sensors.motion.active = false;

		}

	},

	listen: function( callback ) {

		this.start( callback );

	},

	getScreenAdjustedAcceleration: function () {

		var accData = sensors.motion.data && sensors.motion.data.acceleration ? sensors.motion.data.acceleration : { x: 0, y: 0, z: 0 };
		var screenAccData = {};

		switch ( screenOrientationAngle ) {
			case SCREEN_ROTATION_90:
				screenAccData.x = - accData.y;
				screenAccData.y =   accData.x;
				break;
			case SCREEN_ROTATION_180:
				screenAccData.x = - accData.x;
				screenAccData.y = - accData.y;
				break;
			case SCREEN_ROTATION_270:
			case SCREEN_ROTATION_MINUS_90:
				screenAccData.x =   accData.y;
				screenAccData.y = - accData.x;
				break;
			default: // SCREEN_ROTATION_0
				screenAccData.x =   accData.x;
				screenAccData.y =   accData.y;
				break;
		}

		screenAccData.z = accData.z;

		return screenAccData;

	},

	getScreenAdjustedAccelerationIncludingGravity: function () {

		var accGData = sensors.motion.data && sensors.motion.data.accelerationIncludingGravity ? sensors.motion.data.accelerationIncludingGravity : { x: 0, y: 0, z: 0 };
		var screenAccGData = {};

		switch ( screenOrientationAngle ) {
			case SCREEN_ROTATION_90:
				screenAccGData.x = - accGData.y;
				screenAccGData.y =   accGData.x;
				break;
			case SCREEN_ROTATION_180:
				screenAccGData.x = - accGData.x;
				screenAccGData.y = - accGData.y;
				break;
			case SCREEN_ROTATION_270:
			case SCREEN_ROTATION_MINUS_90:
				screenAccGData.x =   accGData.y;
				screenAccGData.y = - accGData.x;
				break;
			default: // SCREEN_ROTATION_0
				screenAccGData.x =   accGData.x;
				screenAccGData.y =   accGData.y;
				break;
		}

		screenAccGData.z = accGData.z;

		return screenAccGData;

	},

	getScreenAdjustedRotationRate: function () {

		var rotRateData = sensors.motion.data && sensors.motion.data.rotationRate ? sensors.motion.data.rotationRate : { alpha: 0, beta: 0, gamma: 0 };
		var screenRotRateData = {};

		switch ( screenOrientationAngle ) {
			case SCREEN_ROTATION_90:
				screenRotRateData.beta  = - rotRateData.gamma;
				screenRotRateData.gamma =   rotRateData.beta;
				break;
			case SCREEN_ROTATION_180:
				screenRotRateData.beta  = - rotRateData.beta;
				screenRotRateData.gamma = - rotRateData.gamma;
				break;
			case SCREEN_ROTATION_270:
			case SCREEN_ROTATION_MINUS_90:
				screenRotRateData.beta  =   rotRateData.gamma;
				screenRotRateData.gamma = - rotRateData.beta;
				break;
			default: // SCREEN_ROTATION_0
				screenRotRateData.beta  =   rotRateData.beta;
				screenRotRateData.gamma =   rotRateData.gamma;
				break;
		}

		screenRotRateData.alpha = rotRateData.alpha;

		return screenRotRateData;

	},

	getLastRawEventData: function () {

		return sensors.motion.data || {};

	},

	_accelerationXAvailable: false,
	_accelerationYAvailable: false,
	_accelerationZAvailable: false,

	_accelerationIncludingGravityXAvailable: false,
	_accelerationIncludingGravityYAvailable: false,
	_accelerationIncludingGravityZAvailable: false,

	_rotationRateAlphaAvailable: false,
	_rotationRateBetaAvailable: false,
	_rotationRateGammaAvailable: false,

	isAvailable: function(_valueType){

		switch(_valueType){
			case this.ACCELERATION_X:
				return this._accelerationXAvailable;

			case this.ACCELERATION_Y:
				return this._accelerationYAvailable;

			case this.ACCELERATION_Z:
				return this._accelerationZAvailable;

			case this.ACCELERATION_INCLUDING_GRAVITY_X:
				return this._accelerationIncludingGravityXAvailable;

			case this.ACCELERATION_INCLUDING_GRAVITY_Y:
				return this._accelerationIncludingGravityYAvailable;

			case this.ACCELERATION_INCLUDING_GRAVITY_Z:
				return this._accelerationIncludingGravityZAvailable;

			case this.ROTATION_RATE_ALPHA:
				return this._rotationRateAlphaAvailable;

			case this.ROTATION_RATE_BETA:
				return this._rotationRateBetaAvailable;

			case this.ROTATION_RATE_GAMMA:
				return this._rotationRateGammaAvailable;
		}
	},

	ACCELERATION_X: 'accelerationX',
	ACCELERATION_Y: 'accelerationY',
	ACCELERATION_Z: 'accelerationZ',

	ACCELERATION_INCLUDING_GRAVITY_X: 'accelerationIncludingGravityX',
	ACCELERATION_INCLUDING_GRAVITY_Y: 'accelerationIncludingGravityY',
	ACCELERATION_INCLUDING_GRAVITY_Z: 'accelerationIncludingGravityZ',

	ROTATION_RATE_ALPHA: 'rotationRateAlpha',
	ROTATION_RATE_BETA: 'rotationRateBeta',
	ROTATION_RATE_GAMMA: 'rotationRateGamma'

};

////// Attach FULLTILT to root DOM element //////

window.FULLTILT = FULLTILT;

})( window );
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.THREE = global.THREE || {})));
}(this, (function (exports) { 'use strict';

    // Polyfills

    if ( Number.EPSILON === undefined ) {

    	Number.EPSILON = Math.pow( 2, - 52 );

    }

    //

    if ( Math.sign === undefined ) {

    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    	Math.sign = function ( x ) {

    		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

    	};

    }

    if ( Function.prototype.name === undefined ) {

    	// Missing in IE9-11.
    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    	Object.defineProperty( Function.prototype, 'name', {

    		get: function () {

    			return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

    		}

    	} );

    }

    if ( Object.assign === undefined ) {

    	// Missing in IE.
    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

    	( function () {

    		Object.assign = function ( target ) {

    			'use strict';

    			if ( target === undefined || target === null ) {

    				throw new TypeError( 'Cannot convert undefined or null to object' );

    			}

    			var output = Object( target );

    			for ( var index = 1; index < arguments.length; index ++ ) {

    				var source = arguments[ index ];

    				if ( source !== undefined && source !== null ) {

    					for ( var nextKey in source ) {

    						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

    							output[ nextKey ] = source[ nextKey ];

    						}

    					}

    				}

    			}

    			return output;

    		};

    	} )();

    }

    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */

    function EventDispatcher() {}

    Object.assign( EventDispatcher.prototype, {

    	addEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) this._listeners = {};

    		var listeners = this._listeners;

    		if ( listeners[ type ] === undefined ) {

    			listeners[ type ] = [];

    		}

    		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

    			listeners[ type ].push( listener );

    		}

    	},

    	hasEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) return false;

    		var listeners = this._listeners;

    		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

    			return true;

    		}

    		return false;

    	},

    	removeEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) return;

    		var listeners = this._listeners;
    		var listenerArray = listeners[ type ];

    		if ( listenerArray !== undefined ) {

    			var index = listenerArray.indexOf( listener );

    			if ( index !== - 1 ) {

    				listenerArray.splice( index, 1 );

    			}

    		}

    	},

    	dispatchEvent: function ( event ) {

    		if ( this._listeners === undefined ) return;

    		var listeners = this._listeners;
    		var listenerArray = listeners[ event.type ];

    		if ( listenerArray !== undefined ) {

    			event.target = this;

    			var array = [], i = 0;
    			var length = listenerArray.length;

    			for ( i = 0; i < length; i ++ ) {

    				array[ i ] = listenerArray[ i ];

    			}

    			for ( i = 0; i < length; i ++ ) {

    				array[ i ].call( this, event );

    			}

    		}

    	}

    } );

    var REVISION = '81';
    var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var BlendingMode = {
        NoBlending: NoBlending,
        NormalBlending: NormalBlending,
        AdditiveBlending: AdditiveBlending,
        SubtractiveBlending: SubtractiveBlending,
        MultiplyBlending: MultiplyBlending,
        CustomBlending: CustomBlending
    };
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var TextureMapping = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    };
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var TextureWrapping = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };
    var NearestFilter = 1003;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipMapLinearFilter = 1008;
    var TextureFilter = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    };
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RGB_S3TC_DXT1_Format = 2001;
    var RGBA_S3TC_DXT1_Format = 2002;
    var RGBA_S3TC_DXT3_Format = 2003;
    var RGBA_S3TC_DXT5_Format = 2004;
    var RGB_PVRTC_4BPPV1_Format = 2100;
    var RGB_PVRTC_2BPPV1_Format = 2101;
    var RGBA_PVRTC_4BPPV1_Format = 2102;
    var RGBA_PVRTC_2BPPV1_Format = 2103;
    var RGB_ETC1_Format = 2151;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    exports.Math = {

    	DEG2RAD: Math.PI / 180,
    	RAD2DEG: 180 / Math.PI,

    	generateUUID: function () {

    		// http://www.broofa.com/Tools/Math.uuid.htm

    		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    		var uuid = new Array( 36 );
    		var rnd = 0, r;

    		return function generateUUID() {

    			for ( var i = 0; i < 36; i ++ ) {

    				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

    					uuid[ i ] = '-';

    				} else if ( i === 14 ) {

    					uuid[ i ] = '4';

    				} else {

    					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
    					r = rnd & 0xf;
    					rnd = rnd >> 4;
    					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

    				}

    			}

    			return uuid.join( '' );

    		};

    	}(),

    	clamp: function ( value, min, max ) {

    		return Math.max( min, Math.min( max, value ) );

    	},

    	// compute euclidian modulo of m % n
    	// https://en.wikipedia.org/wiki/Modulo_operation

    	euclideanModulo: function ( n, m ) {

    		return ( ( n % m ) + m ) % m;

    	},

    	// Linear mapping from range <a1, a2> to range <b1, b2>

    	mapLinear: function ( x, a1, a2, b1, b2 ) {

    		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    	},

    	// http://en.wikipedia.org/wiki/Smoothstep

    	smoothstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * ( 3 - 2 * x );

    	},

    	smootherstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    	},

    	random16: function () {

    		console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
    		return Math.random();

    	},

    	// Random integer from <low, high> interval

    	randInt: function ( low, high ) {

    		return low + Math.floor( Math.random() * ( high - low + 1 ) );

    	},

    	// Random float from <low, high> interval

    	randFloat: function ( low, high ) {

    		return low + Math.random() * ( high - low );

    	},

    	// Random float from <-range/2, range/2> interval

    	randFloatSpread: function ( range ) {

    		return range * ( 0.5 - Math.random() );

    	},

    	degToRad: function ( degrees ) {

    		return degrees * exports.Math.DEG2RAD;

    	},

    	radToDeg: function ( radians ) {

    		return radians * exports.Math.RAD2DEG;

    	},

    	isPowerOfTwo: function ( value ) {

    		return ( value & ( value - 1 ) ) === 0 && value !== 0;

    	},

    	nearestPowerOfTwo: function ( value ) {

    		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

    	},

    	nextPowerOfTwo: function ( value ) {

    		value --;
    		value |= value >> 1;
    		value |= value >> 2;
    		value |= value >> 4;
    		value |= value >> 8;
    		value |= value >> 16;
    		value ++;

    		return value;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author philogb / http://blog.thejit.org/
     * @author egraether / http://egraether.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    function Vector2( x, y ) {

    	this.x = x || 0;
    	this.y = y || 0;

    }

    Vector2.prototype = {

    	constructor: Vector2,

    	isVector2: true,

    	get width() {

    		return this.x;

    	},

    	set width( value ) {

    		this.x = value;

    	},

    	get height() {

    		return this.y;

    	},

    	set height( value ) {

    		this.y = value;

    	},

    	//

    	set: function ( x, y ) {

    		this.x = x;
    		this.y = y;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;

    		return this;

    	},

    	multiply: function ( v ) {

    		this.x *= v.x;
    		this.y *= v.y;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;

    		}

    		return this;

    	},

    	divide: function ( v ) {

    		this.x /= v.x;
    		this.y /= v.y;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector2();
    				max = new Vector2();

    			}

    			min.set( minVal, minVal );
    			max.set( maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	clampLength: function ( min, max ) {

    		var length = this.length();

    		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    	},

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y );

    	},

    	lengthManhattan: function() {

    		return Math.abs( this.x ) + Math.abs( this.y );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	angle: function () {

    		// computes the angle in radians with respect to the positive x-axis

    		var angle = Math.atan2( this.y, this.x );

    		if ( angle < 0 ) angle += 2 * Math.PI;

    		return angle;

    	},

    	distanceTo: function ( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	},

    	distanceToSquared: function ( v ) {

    		var dx = this.x - v.x, dy = this.y - v.y;
    		return dx * dx + dy * dy;

    	},

    	distanceToManhattan: function ( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];

    		return this;

    	},

    	rotateAround: function ( center, angle ) {

    		var c = Math.cos( angle ), s = Math.sin( angle );

    		var x = this.x - center.x;
    		var y = this.y - center.y;

    		this.x = x * c - y * s + center.x;
    		this.y = x * s + y * c + center.y;

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */

    function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    	Object.defineProperty( this, 'id', { value: TextureIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.sourceFile = '';

    	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    	this.mipmaps = [];

    	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

    	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

    	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

    	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    	this.format = format !== undefined ? format : RGBAFormat;
    	this.type = type !== undefined ? type : UnsignedByteType;

    	this.offset = new Vector2( 0, 0 );
    	this.repeat = new Vector2( 1, 1 );

    	this.generateMipmaps = true;
    	this.premultiplyAlpha = false;
    	this.flipY = true;
    	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


    	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    	//
    	// Also changing the encoding after already used by a Material will not automatically make the Material
    	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
    	this.encoding = encoding !== undefined ? encoding :  LinearEncoding;

    	this.version = 0;
    	this.onUpdate = null;

    }

    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;

    Texture.prototype = {

    	constructor: Texture,

    	isTexture: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.image = source.image;
    		this.mipmaps = source.mipmaps.slice( 0 );

    		this.mapping = source.mapping;

    		this.wrapS = source.wrapS;
    		this.wrapT = source.wrapT;

    		this.magFilter = source.magFilter;
    		this.minFilter = source.minFilter;

    		this.anisotropy = source.anisotropy;

    		this.format = source.format;
    		this.type = source.type;

    		this.offset.copy( source.offset );
    		this.repeat.copy( source.repeat );

    		this.generateMipmaps = source.generateMipmaps;
    		this.premultiplyAlpha = source.premultiplyAlpha;
    		this.flipY = source.flipY;
    		this.unpackAlignment = source.unpackAlignment;
    		this.encoding = source.encoding;

    		return this;

    	},

    	toJSON: function ( meta ) {

    		if ( meta.textures[ this.uuid ] !== undefined ) {

    			return meta.textures[ this.uuid ];

    		}

    		function getDataURL( image ) {

    			var canvas;

    			if ( image.toDataURL !== undefined ) {

    				canvas = image;

    			} else {

    				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    				canvas.width = image.width;
    				canvas.height = image.height;

    				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

    			}

    			if ( canvas.width > 2048 || canvas.height > 2048 ) {

    				return canvas.toDataURL( 'image/jpeg', 0.6 );

    			} else {

    				return canvas.toDataURL( 'image/png' );

    			}

    		}

    		var output = {
    			metadata: {
    				version: 4.4,
    				type: 'Texture',
    				generator: 'Texture.toJSON'
    			},

    			uuid: this.uuid,
    			name: this.name,

    			mapping: this.mapping,

    			repeat: [ this.repeat.x, this.repeat.y ],
    			offset: [ this.offset.x, this.offset.y ],
    			wrap: [ this.wrapS, this.wrapT ],

    			minFilter: this.minFilter,
    			magFilter: this.magFilter,
    			anisotropy: this.anisotropy,

    			flipY: this.flipY
    		};

    		if ( this.image !== undefined ) {

    			// TODO: Move to THREE.Image

    			var image = this.image;

    			if ( image.uuid === undefined ) {

    				image.uuid = exports.Math.generateUUID(); // UGH

    			}

    			if ( meta.images[ image.uuid ] === undefined ) {

    				meta.images[ image.uuid ] = {
    					uuid: image.uuid,
    					url: getDataURL( image )
    				};

    			}

    			output.image = image.uuid;

    		}

    		meta.textures[ this.uuid ] = output;

    		return output;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	},

    	transformUv: function ( uv ) {

    		if ( this.mapping !== UVMapping )  return;

    		uv.multiply( this.repeat );
    		uv.add( this.offset );

    		if ( uv.x < 0 || uv.x > 1 ) {

    			switch ( this.wrapS ) {

    				case RepeatWrapping:

    					uv.x = uv.x - Math.floor( uv.x );
    					break;

    				case ClampToEdgeWrapping:

    					uv.x = uv.x < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

    						uv.x = Math.ceil( uv.x ) - uv.x;

    					} else {

    						uv.x = uv.x - Math.floor( uv.x );

    					}
    					break;

    			}

    		}

    		if ( uv.y < 0 || uv.y > 1 ) {

    			switch ( this.wrapT ) {

    				case RepeatWrapping:

    					uv.y = uv.y - Math.floor( uv.y );
    					break;

    				case ClampToEdgeWrapping:

    					uv.y = uv.y < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

    						uv.y = Math.ceil( uv.y ) - uv.y;

    					} else {

    						uv.y = uv.y - Math.floor( uv.y );

    					}
    					break;

    			}

    		}

    		if ( this.flipY ) {

    			uv.y = 1 - uv.y;

    		}

    	}

    };

    Object.assign( Texture.prototype, EventDispatcher.prototype );

    var count = 0;
    function TextureIdCount() { return count++; };

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector4( x, y, z, w ) {

    	this.x = x || 0;
    	this.y = y || 0;
    	this.z = z || 0;
    	this.w = ( w !== undefined ) ? w : 1;

    }

    Vector4.prototype = {

    	constructor: Vector4,

    	isVector4: true,

    	set: function ( x, y, z, w ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;
    		this.w = w;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;
    		this.w = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setZ: function ( z ) {

    		this.z = z;

    		return this;

    	},

    	setW: function ( w ) {

    		this.w = w;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			case 3: this.w = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			case 3: return this.w;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y, this.z, this.w );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;
    		this.w = ( v.w !== undefined ) ? v.w : 1;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;
    		this.w += v.w;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;
    		this.w += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;
    		this.w = a.w + b.w;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;
    		this.w += v.w * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;
    		this.w -= v.w;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;
    		this.w -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;
    		this.w = a.w - b.w;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;
    			this.z *= scalar;
    			this.w *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;
    			this.z = 0;
    			this.w = 0;

    		}

    		return this;

    	},

    	applyMatrix4: function ( m ) {

    		var x = this.x, y = this.y, z = this.z, w = this.w;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	setAxisAngleFromQuaternion: function ( q ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    		// q is assumed to be normalized

    		this.w = 2 * Math.acos( q.w );

    		var s = Math.sqrt( 1 - q.w * q.w );

    		if ( s < 0.0001 ) {

    			 this.x = 1;
    			 this.y = 0;
    			 this.z = 0;

    		} else {

    			 this.x = q.x / s;
    			 this.y = q.y / s;
    			 this.z = q.z / s;

    		}

    		return this;

    	},

    	setAxisAngleFromRotationMatrix: function ( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var angle, x, y, z,		// variables for result
    			epsilon = 0.01,		// margin to allow for rounding errors
    			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

    			te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
    		     ( Math.abs( m13 - m31 ) < epsilon ) &&
    		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

    			// singularity found
    			// first check for identity matrix which must have +1 for all terms
    			// in leading diagonal and zero in other terms

    			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
    			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
    			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
    			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

    				// this singularity is identity matrix so angle = 0

    				this.set( 1, 0, 0, 0 );

    				return this; // zero angle, arbitrary axis

    			}

    			// otherwise this singularity is angle = 180

    			angle = Math.PI;

    			var xx = ( m11 + 1 ) / 2;
    			var yy = ( m22 + 1 ) / 2;
    			var zz = ( m33 + 1 ) / 2;
    			var xy = ( m12 + m21 ) / 4;
    			var xz = ( m13 + m31 ) / 4;
    			var yz = ( m23 + m32 ) / 4;

    			if ( ( xx > yy ) && ( xx > zz ) ) {

    				// m11 is the largest diagonal term

    				if ( xx < epsilon ) {

    					x = 0;
    					y = 0.707106781;
    					z = 0.707106781;

    				} else {

    					x = Math.sqrt( xx );
    					y = xy / x;
    					z = xz / x;

    				}

    			} else if ( yy > zz ) {

    				// m22 is the largest diagonal term

    				if ( yy < epsilon ) {

    					x = 0.707106781;
    					y = 0;
    					z = 0.707106781;

    				} else {

    					y = Math.sqrt( yy );
    					x = xy / y;
    					z = yz / y;

    				}

    			} else {

    				// m33 is the largest diagonal term so base result on this

    				if ( zz < epsilon ) {

    					x = 0.707106781;
    					y = 0.707106781;
    					z = 0;

    				} else {

    					z = Math.sqrt( zz );
    					x = xz / z;
    					y = yz / z;

    				}

    			}

    			this.set( x, y, z, angle );

    			return this; // return 180 deg rotation

    		}

    		// as we have reached here there are no singularities so we can handle normally

    		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
    		                   ( m13 - m31 ) * ( m13 - m31 ) +
    		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    		if ( Math.abs( s ) < 0.001 ) s = 1;

    		// prevent divide by zero, should not happen if matrix is orthogonal and should be
    		// caught by singularity test above, but I've left it in just in case

    		this.x = ( m32 - m23 ) / s;
    		this.y = ( m13 - m31 ) / s;
    		this.z = ( m21 - m12 ) / s;
    		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    		return this;

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );
    		this.w = Math.min( this.w, v.w );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );
    		this.w = Math.max( this.w, v.w );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
    		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector4();
    				max = new Vector4();

    			}

    			min.set( minVal, minVal, minVal, minVal );
    			max.set( maxVal, maxVal, maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );
    		this.w = Math.floor( this.w );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );
    		this.w = Math.ceil( this.w );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );
    		this.w = Math.round( this.w );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;
    		this.w = - this.w;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    	},

    	lengthManhattan: function () {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;
    		this.w += ( v.w - this.w ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];
    		this.w = array[ offset + 3 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;
    		array[ offset + 3 ] = this.w;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];
    		this.z = attribute.array[ index + 2 ];
    		this.w = attribute.array[ index + 3 ];

    		return this;

    	}

    };

    /**
     * @author szimek / https://github.com/szimek/
     * @author alteredq / http://alteredqualia.com/
     * @author Marius Kintel / https://github.com/kintel
     */

    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    */
    function WebGLRenderTarget( width, height, options ) {

    	this.uuid = exports.Math.generateUUID();

    	this.width = width;
    	this.height = height;

    	this.scissor = new Vector4( 0, 0, width, height );
    	this.scissorTest = false;

    	this.viewport = new Vector4( 0, 0, width, height );

    	options = options || {};

    	if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

    	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

    	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

    }

    Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {

    	isWebGLRenderTarget: true,

    	setSize: function ( width, height ) {

    		if ( this.width !== width || this.height !== height ) {

    			this.width = width;
    			this.height = height;

    			this.dispose();

    		}

    		this.viewport.set( 0, 0, width, height );
    		this.scissor.set( 0, 0, width, height );

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.width = source.width;
    		this.height = source.height;

    		this.viewport.copy( source.viewport );

    		this.texture = source.texture.clone();

    		this.depthBuffer = source.depthBuffer;
    		this.stencilBuffer = source.stencilBuffer;
    		this.depthTexture = source.depthTexture;

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com
     */

    function WebGLRenderTargetCube( width, height, options ) {

    	WebGLRenderTarget.call( this, width, height, options );

    	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
    	this.activeMipMapLevel = 0;

    }

    WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

    WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Quaternion( x, y, z, w ) {

    	this._x = x || 0;
    	this._y = y || 0;
    	this._z = z || 0;
    	this._w = ( w !== undefined ) ? w : 1;

    }

    Quaternion.prototype = {

    	constructor: Quaternion,

    	get x () {

    		return this._x;

    	},

    	set x ( value ) {

    		this._x = value;
    		this.onChangeCallback();

    	},

    	get y () {

    		return this._y;

    	},

    	set y ( value ) {

    		this._y = value;
    		this.onChangeCallback();

    	},

    	get z () {

    		return this._z;

    	},

    	set z ( value ) {

    		this._z = value;
    		this.onChangeCallback();

    	},

    	get w () {

    		return this._w;

    	},

    	set w ( value ) {

    		this._w = value;
    		this.onChangeCallback();

    	},

    	set: function ( x, y, z, w ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._w = w;

    		this.onChangeCallback();

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this._x, this._y, this._z, this._w );

    	},

    	copy: function ( quaternion ) {

    		this._x = quaternion.x;
    		this._y = quaternion.y;
    		this._z = quaternion.z;
    		this._w = quaternion.w;

    		this.onChangeCallback();

    		return this;

    	},

    	setFromEuler: function ( euler, update ) {

    		if ( (euler && euler.isEuler) === false ) {

    			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    		}

    		// http://www.mathworks.com/matlabcentral/fileexchange/
    		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    		//	content/SpinCalc.m

    		var c1 = Math.cos( euler._x / 2 );
    		var c2 = Math.cos( euler._y / 2 );
    		var c3 = Math.cos( euler._z / 2 );
    		var s1 = Math.sin( euler._x / 2 );
    		var s2 = Math.sin( euler._y / 2 );
    		var s3 = Math.sin( euler._z / 2 );

    		var order = euler.order;

    		if ( order === 'XYZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'YXZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'ZXY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'ZYX' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'YZX' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'XZY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		}

    		if ( update !== false ) this.onChangeCallback();

    		return this;

    	},

    	setFromAxisAngle: function ( axis, angle ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    		// assumes axis is normalized

    		var halfAngle = angle / 2, s = Math.sin( halfAngle );

    		this._x = axis.x * s;
    		this._y = axis.y * s;
    		this._z = axis.z * s;
    		this._w = Math.cos( halfAngle );

    		this.onChangeCallback();

    		return this;

    	},

    	setFromRotationMatrix: function ( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

    			trace = m11 + m22 + m33,
    			s;

    		if ( trace > 0 ) {

    			s = 0.5 / Math.sqrt( trace + 1.0 );

    			this._w = 0.25 / s;
    			this._x = ( m32 - m23 ) * s;
    			this._y = ( m13 - m31 ) * s;
    			this._z = ( m21 - m12 ) * s;

    		} else if ( m11 > m22 && m11 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

    			this._w = ( m32 - m23 ) / s;
    			this._x = 0.25 * s;
    			this._y = ( m12 + m21 ) / s;
    			this._z = ( m13 + m31 ) / s;

    		} else if ( m22 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

    			this._w = ( m13 - m31 ) / s;
    			this._x = ( m12 + m21 ) / s;
    			this._y = 0.25 * s;
    			this._z = ( m23 + m32 ) / s;

    		} else {

    			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

    			this._w = ( m21 - m12 ) / s;
    			this._x = ( m13 + m31 ) / s;
    			this._y = ( m23 + m32 ) / s;
    			this._z = 0.25 * s;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	setFromUnitVectors: function () {

    		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    		// assumes direction vectors vFrom and vTo are normalized

    		var v1, r;

    		var EPS = 0.000001;

    		return function setFromUnitVectors( vFrom, vTo ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			r = vFrom.dot( vTo ) + 1;

    			if ( r < EPS ) {

    				r = 0;

    				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

    					v1.set( - vFrom.y, vFrom.x, 0 );

    				} else {

    					v1.set( 0, - vFrom.z, vFrom.y );

    				}

    			} else {

    				v1.crossVectors( vFrom, vTo );

    			}

    			this._x = v1.x;
    			this._y = v1.y;
    			this._z = v1.z;
    			this._w = r;

    			return this.normalize();

    		};

    	}(),

    	inverse: function () {

    		return this.conjugate().normalize();

    	},

    	conjugate: function () {

    		this._x *= - 1;
    		this._y *= - 1;
    		this._z *= - 1;

    		this.onChangeCallback();

    		return this;

    	},

    	dot: function ( v ) {

    		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    	},

    	lengthSq: function () {

    		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    	},

    	length: function () {

    		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    	},

    	normalize: function () {

    		var l = this.length();

    		if ( l === 0 ) {

    			this._x = 0;
    			this._y = 0;
    			this._z = 0;
    			this._w = 1;

    		} else {

    			l = 1 / l;

    			this._x = this._x * l;
    			this._y = this._y * l;
    			this._z = this._z * l;
    			this._w = this._w * l;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	multiply: function ( q, p ) {

    		if ( p !== undefined ) {

    			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
    			return this.multiplyQuaternions( q, p );

    		}

    		return this.multiplyQuaternions( this, q );

    	},

    	premultiply: function ( q ) {

    		return this.multiplyQuaternions( q, this );

    	},

    	multiplyQuaternions: function ( a, b ) {

    		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    		this.onChangeCallback();

    		return this;

    	},

    	slerp: function ( qb, t ) {

    		if ( t === 0 ) return this;
    		if ( t === 1 ) return this.copy( qb );

    		var x = this._x, y = this._y, z = this._z, w = this._w;

    		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    		if ( cosHalfTheta < 0 ) {

    			this._w = - qb._w;
    			this._x = - qb._x;
    			this._y = - qb._y;
    			this._z = - qb._z;

    			cosHalfTheta = - cosHalfTheta;

    		} else {

    			this.copy( qb );

    		}

    		if ( cosHalfTheta >= 1.0 ) {

    			this._w = w;
    			this._x = x;
    			this._y = y;
    			this._z = z;

    			return this;

    		}

    		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

    			this._w = 0.5 * ( w + this._w );
    			this._x = 0.5 * ( x + this._x );
    			this._y = 0.5 * ( y + this._y );
    			this._z = 0.5 * ( z + this._z );

    			return this;

    		}

    		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
    		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    		this._w = ( w * ratioA + this._w * ratioB );
    		this._x = ( x * ratioA + this._x * ratioB );
    		this._y = ( y * ratioA + this._y * ratioB );
    		this._z = ( z * ratioA + this._z * ratioB );

    		this.onChangeCallback();

    		return this;

    	},

    	equals: function ( quaternion ) {

    		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this._x = array[ offset ];
    		this._y = array[ offset + 1 ];
    		this._z = array[ offset + 2 ];
    		this._w = array[ offset + 3 ];

    		this.onChangeCallback();

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._w;

    		return array;

    	},

    	onChange: function ( callback ) {

    		this.onChangeCallback = callback;

    		return this;

    	},

    	onChangeCallback: function () {}

    };

    Object.assign( Quaternion, {

    	slerp: function( qa, qb, qm, t ) {

    		return qm.copy( qa ).slerp( qb, t );

    	},

    	slerpFlat: function(
    			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

    		// fuzz-free, array-based Quaternion SLERP operation

    		var x0 = src0[ srcOffset0 + 0 ],
    			y0 = src0[ srcOffset0 + 1 ],
    			z0 = src0[ srcOffset0 + 2 ],
    			w0 = src0[ srcOffset0 + 3 ],

    			x1 = src1[ srcOffset1 + 0 ],
    			y1 = src1[ srcOffset1 + 1 ],
    			z1 = src1[ srcOffset1 + 2 ],
    			w1 = src1[ srcOffset1 + 3 ];

    		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

    			var s = 1 - t,

    				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

    				dir = ( cos >= 0 ? 1 : - 1 ),
    				sqrSin = 1 - cos * cos;

    			// Skip the Slerp for tiny steps to avoid numeric problems:
    			if ( sqrSin > Number.EPSILON ) {

    				var sin = Math.sqrt( sqrSin ),
    					len = Math.atan2( sin, cos * dir );

    				s = Math.sin( s * len ) / sin;
    				t = Math.sin( t * len ) / sin;

    			}

    			var tDir = t * dir;

    			x0 = x0 * s + x1 * tDir;
    			y0 = y0 * s + y1 * tDir;
    			z0 = z0 * s + z1 * tDir;
    			w0 = w0 * s + w1 * tDir;

    			// Normalize in case we just did a lerp:
    			if ( s === 1 - t ) {

    				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

    				x0 *= f;
    				y0 *= f;
    				z0 *= f;
    				w0 *= f;

    			}

    		}

    		dst[ dstOffset ] = x0;
    		dst[ dstOffset + 1 ] = y0;
    		dst[ dstOffset + 2 ] = z0;
    		dst[ dstOffset + 3 ] = w0;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author *kile / http://kile.stravaganza.org/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector3( x, y, z ) {

    	this.x = x || 0;
    	this.y = y || 0;
    	this.z = z || 0;

    }

    Vector3.prototype = {

    	constructor: Vector3,

    	isVector3: true,

    	set: function ( x, y, z ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setZ: function ( z ) {

    		this.z = z;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y, this.z );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;

    		return this;

    	},

    	multiply: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
    			return this.multiplyVectors( v, w );

    		}

    		this.x *= v.x;
    		this.y *= v.y;
    		this.z *= v.z;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;
    			this.z *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;
    			this.z = 0;

    		}

    		return this;

    	},

    	multiplyVectors: function ( a, b ) {

    		this.x = a.x * b.x;
    		this.y = a.y * b.y;
    		this.z = a.z * b.z;

    		return this;

    	},

    	applyEuler: function () {

    		var quaternion;

    		return function applyEuler( euler ) {

    			if ( (euler && euler.isEuler) === false ) {

    				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

    			}

    			if ( quaternion === undefined ) quaternion = new Quaternion();

    			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

    		};

    	}(),

    	applyAxisAngle: function () {

    		var quaternion;

    		return function applyAxisAngle( axis, angle ) {

    			if ( quaternion === undefined ) quaternion = new Quaternion();

    			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

    		};

    	}(),

    	applyMatrix3: function ( m ) {

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    		return this;

    	},

    	applyMatrix4: function ( m ) {

    		// input: THREE.Matrix4 affine matrix

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    		return this;

    	},

    	applyProjection: function ( m ) {

    		// input: THREE.Matrix4 projection matrix

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;
    		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    		return this;

    	},

    	applyQuaternion: function ( q ) {

    		var x = this.x, y = this.y, z = this.z;
    		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

    		// calculate quat * vector

    		var ix =  qw * x + qy * z - qz * y;
    		var iy =  qw * y + qz * x - qx * z;
    		var iz =  qw * z + qx * y - qy * x;
    		var iw = - qx * x - qy * y - qz * z;

    		// calculate result * inverse quat

    		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    		return this;

    	},

    	project: function () {

    		var matrix;

    		return function project( camera ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
    			return this.applyProjection( matrix );

    		};

    	}(),

    	unproject: function () {

    		var matrix;

    		return function unproject( camera ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
    			return this.applyProjection( matrix );

    		};

    	}(),

    	transformDirection: function ( m ) {

    		// input: THREE.Matrix4 affine matrix
    		// vector interpreted as a direction

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    		return this.normalize();

    	},

    	divide: function ( v ) {

    		this.x /= v.x;
    		this.y /= v.y;
    		this.z /= v.z;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector3();
    				max = new Vector3();

    			}

    			min.set( minVal, minVal, minVal );
    			max.set( maxVal, maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	clampLength: function ( min, max ) {

    		var length = this.length();

    		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    	},

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y + this.z * this.z;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    	},

    	lengthManhattan: function () {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	cross: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
    			return this.crossVectors( v, w );

    		}

    		var x = this.x, y = this.y, z = this.z;

    		this.x = y * v.z - z * v.y;
    		this.y = z * v.x - x * v.z;
    		this.z = x * v.y - y * v.x;

    		return this;

    	},

    	crossVectors: function ( a, b ) {

    		var ax = a.x, ay = a.y, az = a.z;
    		var bx = b.x, by = b.y, bz = b.z;

    		this.x = ay * bz - az * by;
    		this.y = az * bx - ax * bz;
    		this.z = ax * by - ay * bx;

    		return this;

    	},

    	projectOnVector: function ( vector ) {

    		var scalar = vector.dot( this ) / vector.lengthSq();

    		return this.copy( vector ).multiplyScalar( scalar );

    	},

    	projectOnPlane: function () {

    		var v1;

    		return function projectOnPlane( planeNormal ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			v1.copy( this ).projectOnVector( planeNormal );

    			return this.sub( v1 );

    		};

    	}(),

    	reflect: function () {

    		// reflect incident vector off plane orthogonal to normal
    		// normal is assumed to have unit length

    		var v1;

    		return function reflect( normal ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    		};

    	}(),

    	angleTo: function ( v ) {

    		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

    		// clamp, to handle numerical problems

    		return Math.acos( exports.Math.clamp( theta, - 1, 1 ) );

    	},

    	distanceTo: function ( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	},

    	distanceToSquared: function ( v ) {

    		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

    		return dx * dx + dy * dy + dz * dz;

    	},

    	distanceToManhattan: function ( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

    	},

    	setFromSpherical: function( s ) {

    		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

    		this.x = sinPhiRadius * Math.sin( s.theta );
    		this.y = Math.cos( s.phi ) * s.radius;
    		this.z = sinPhiRadius * Math.cos( s.theta );

    		return this;

    	},

    	setFromMatrixPosition: function ( m ) {

    		return this.setFromMatrixColumn( m, 3 );

    	},

    	setFromMatrixScale: function ( m ) {

    		var sx = this.setFromMatrixColumn( m, 0 ).length();
    		var sy = this.setFromMatrixColumn( m, 1 ).length();
    		var sz = this.setFromMatrixColumn( m, 2 ).length();

    		this.x = sx;
    		this.y = sy;
    		this.z = sz;

    		return this;

    	},

    	setFromMatrixColumn: function ( m, index ) {

    		if ( typeof m === 'number' ) {

    			console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
    			var temp = m
    			m = index;
    			index = temp;

    		}

    		return this.fromArray( m.elements, index * 4 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];
    		this.z = attribute.array[ index + 2 ];

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Matrix4() {

    	this.elements = new Float32Array( [

    		1, 0, 0, 0,
    		0, 1, 0, 0,
    		0, 0, 1, 0,
    		0, 0, 0, 1

    	] );

    	if ( arguments.length > 0 ) {

    		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    	}

    }

    Matrix4.prototype = {

    	constructor: Matrix4,

    	isMatrix4: true,

    	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    		var te = this.elements;

    		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    		return this;

    	},

    	identity: function () {

    		this.set(

    			1, 0, 0, 0,
    			0, 1, 0, 0,
    			0, 0, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	clone: function () {

    		return new Matrix4().fromArray( this.elements );

    	},

    	copy: function ( m ) {

    		this.elements.set( m.elements );

    		return this;

    	},

    	copyPosition: function ( m ) {

    		var te = this.elements;
    		var me = m.elements;

    		te[ 12 ] = me[ 12 ];
    		te[ 13 ] = me[ 13 ];
    		te[ 14 ] = me[ 14 ];

    		return this;

    	},

    	extractBasis: function ( xAxis, yAxis, zAxis ) {

    		xAxis.setFromMatrixColumn( this, 0 );
    		yAxis.setFromMatrixColumn( this, 1 );
    		zAxis.setFromMatrixColumn( this, 2 );

    		return this;

    	},

    	makeBasis: function ( xAxis, yAxis, zAxis ) {

    		this.set(
    			xAxis.x, yAxis.x, zAxis.x, 0,
    			xAxis.y, yAxis.y, zAxis.y, 0,
    			xAxis.z, yAxis.z, zAxis.z, 0,
    			0,       0,       0,       1
    		);

    		return this;

    	},

    	extractRotation: function () {

    		var v1;

    		return function extractRotation( m ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			var te = this.elements;
    			var me = m.elements;

    			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
    			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
    			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

    			te[ 0 ] = me[ 0 ] * scaleX;
    			te[ 1 ] = me[ 1 ] * scaleX;
    			te[ 2 ] = me[ 2 ] * scaleX;

    			te[ 4 ] = me[ 4 ] * scaleY;
    			te[ 5 ] = me[ 5 ] * scaleY;
    			te[ 6 ] = me[ 6 ] * scaleY;

    			te[ 8 ] = me[ 8 ] * scaleZ;
    			te[ 9 ] = me[ 9 ] * scaleZ;
    			te[ 10 ] = me[ 10 ] * scaleZ;

    			return this;

    		};

    	}(),

    	makeRotationFromEuler: function ( euler ) {

    		if ( (euler && euler.isEuler) === false ) {

    			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    		}

    		var te = this.elements;

    		var x = euler.x, y = euler.y, z = euler.z;
    		var a = Math.cos( x ), b = Math.sin( x );
    		var c = Math.cos( y ), d = Math.sin( y );
    		var e = Math.cos( z ), f = Math.sin( z );

    		if ( euler.order === 'XYZ' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - c * f;
    			te[ 8 ] = d;

    			te[ 1 ] = af + be * d;
    			te[ 5 ] = ae - bf * d;
    			te[ 9 ] = - b * c;

    			te[ 2 ] = bf - ae * d;
    			te[ 6 ] = be + af * d;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YXZ' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce + df * b;
    			te[ 4 ] = de * b - cf;
    			te[ 8 ] = a * d;

    			te[ 1 ] = a * f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b;

    			te[ 2 ] = cf * b - de;
    			te[ 6 ] = df + ce * b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZXY' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce - df * b;
    			te[ 4 ] = - a * f;
    			te[ 8 ] = de + cf * b;

    			te[ 1 ] = cf + de * b;
    			te[ 5 ] = a * e;
    			te[ 9 ] = df - ce * b;

    			te[ 2 ] = - a * d;
    			te[ 6 ] = b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZYX' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = be * d - af;
    			te[ 8 ] = ae * d + bf;

    			te[ 1 ] = c * f;
    			te[ 5 ] = bf * d + ae;
    			te[ 9 ] = af * d - be;

    			te[ 2 ] = - d;
    			te[ 6 ] = b * c;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YZX' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = bd - ac * f;
    			te[ 8 ] = bc * f + ad;

    			te[ 1 ] = f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b * e;

    			te[ 2 ] = - d * e;
    			te[ 6 ] = ad * f + bc;
    			te[ 10 ] = ac - bd * f;

    		} else if ( euler.order === 'XZY' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - f;
    			te[ 8 ] = d * e;

    			te[ 1 ] = ac * f + bd;
    			te[ 5 ] = a * e;
    			te[ 9 ] = ad * f - bc;

    			te[ 2 ] = bc * f - ad;
    			te[ 6 ] = b * e;
    			te[ 10 ] = bd * f + ac;

    		}

    		// last column
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// bottom row
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	},

    	makeRotationFromQuaternion: function ( q ) {

    		var te = this.elements;

    		var x = q.x, y = q.y, z = q.z, w = q.w;
    		var x2 = x + x, y2 = y + y, z2 = z + z;
    		var xx = x * x2, xy = x * y2, xz = x * z2;
    		var yy = y * y2, yz = y * z2, zz = z * z2;
    		var wx = w * x2, wy = w * y2, wz = w * z2;

    		te[ 0 ] = 1 - ( yy + zz );
    		te[ 4 ] = xy - wz;
    		te[ 8 ] = xz + wy;

    		te[ 1 ] = xy + wz;
    		te[ 5 ] = 1 - ( xx + zz );
    		te[ 9 ] = yz - wx;

    		te[ 2 ] = xz - wy;
    		te[ 6 ] = yz + wx;
    		te[ 10 ] = 1 - ( xx + yy );

    		// last column
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// bottom row
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	},

    	lookAt: function () {

    		var x, y, z;

    		return function lookAt( eye, target, up ) {

    			if ( x === undefined ) {

    				x = new Vector3();
    				y = new Vector3();
    				z = new Vector3();

    			}

    			var te = this.elements;

    			z.subVectors( eye, target ).normalize();

    			if ( z.lengthSq() === 0 ) {

    				z.z = 1;

    			}

    			x.crossVectors( up, z ).normalize();

    			if ( x.lengthSq() === 0 ) {

    				z.z += 0.0001;
    				x.crossVectors( up, z ).normalize();

    			}

    			y.crossVectors( z, x );


    			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
    			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
    			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

    			return this;

    		};

    	}(),

    	multiply: function ( m, n ) {

    		if ( n !== undefined ) {

    			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
    			return this.multiplyMatrices( m, n );

    		}

    		return this.multiplyMatrices( this, m );

    	},

    	premultiply: function ( m ) {

    		return this.multiplyMatrices( m, this );

    	},

    	multiplyMatrices: function ( a, b ) {

    		var ae = a.elements;
    		var be = b.elements;
    		var te = this.elements;

    		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    		return this;

    	},

    	multiplyToArray: function ( a, b, r ) {

    		var te = this.elements;

    		this.multiplyMatrices( a, b );

    		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
    		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
    		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
    		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

    		return this;

    	},

    	multiplyScalar: function ( s ) {

    		var te = this.elements;

    		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    		return this;

    	},

    	applyToVector3Array: function () {

    		var v1;

    		return function applyToVector3Array( array, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = array.length;

    			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

    				v1.fromArray( array, j );
    				v1.applyMatrix4( this );
    				v1.toArray( array, j );

    			}

    			return array;

    		};

    	}(),

    	applyToBuffer: function () {

    		var v1;

    		return function applyToBuffer( buffer, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = buffer.length / buffer.itemSize;

    			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

    				v1.x = buffer.getX( j );
    				v1.y = buffer.getY( j );
    				v1.z = buffer.getZ( j );

    				v1.applyMatrix4( this );

    				buffer.setXYZ( v1.x, v1.y, v1.z );

    			}

    			return buffer;

    		};

    	}(),

    	determinant: function () {

    		var te = this.elements;

    		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    		//TODO: make this more efficient
    		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    		return (
    			n41 * (
    				+ n14 * n23 * n32
    				 - n13 * n24 * n32
    				 - n14 * n22 * n33
    				 + n12 * n24 * n33
    				 + n13 * n22 * n34
    				 - n12 * n23 * n34
    			) +
    			n42 * (
    				+ n11 * n23 * n34
    				 - n11 * n24 * n33
    				 + n14 * n21 * n33
    				 - n13 * n21 * n34
    				 + n13 * n24 * n31
    				 - n14 * n23 * n31
    			) +
    			n43 * (
    				+ n11 * n24 * n32
    				 - n11 * n22 * n34
    				 - n14 * n21 * n32
    				 + n12 * n21 * n34
    				 + n14 * n22 * n31
    				 - n12 * n24 * n31
    			) +
    			n44 * (
    				- n13 * n22 * n31
    				 - n11 * n23 * n32
    				 + n11 * n22 * n33
    				 + n13 * n21 * n32
    				 - n12 * n21 * n33
    				 + n12 * n23 * n31
    			)

    		);

    	},

    	transpose: function () {

    		var te = this.elements;
    		var tmp;

    		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    		return this;

    	},

    	flattenToArrayOffset: function ( array, offset ) {

    		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
    				"- just use .toArray instead." );

    		return this.toArray( array, offset );

    	},

    	getPosition: function () {

    		var v1;

    		return function getPosition() {

    			if ( v1 === undefined ) v1 = new Vector3();
    			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

    			return v1.setFromMatrixColumn( this, 3 );

    		};

    	}(),

    	setPosition: function ( v ) {

    		var te = this.elements;

    		te[ 12 ] = v.x;
    		te[ 13 ] = v.y;
    		te[ 14 ] = v.z;

    		return this;

    	},

    	getInverse: function ( m, throwOnDegenerate ) {

    		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    		var te = this.elements,
    			me = m.elements,

    			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
    			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
    			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
    			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

    			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
    			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
    			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
    			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    		if ( det === 0 ) {

    			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

    			if ( throwOnDegenerate === true ) {

    				throw new Error( msg );

    			} else {

    				console.warn( msg );

    			}

    			return this.identity();

    		}

    		var detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
    		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
    		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

    		te[ 4 ] = t12 * detInv;
    		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
    		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
    		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

    		te[ 8 ] = t13 * detInv;
    		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
    		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
    		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

    		te[ 12 ] = t14 * detInv;
    		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
    		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
    		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

    		return this;

    	},

    	scale: function ( v ) {

    		var te = this.elements;
    		var x = v.x, y = v.y, z = v.z;

    		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    		return this;

    	},

    	getMaxScaleOnAxis: function () {

    		var te = this.elements;

    		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

    	},

    	makeTranslation: function ( x, y, z ) {

    		this.set(

    			1, 0, 0, x,
    			0, 1, 0, y,
    			0, 0, 1, z,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationX: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			1, 0,  0, 0,
    			0, c, - s, 0,
    			0, s,  c, 0,
    			0, 0,  0, 1

    		);

    		return this;

    	},

    	makeRotationY: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			 c, 0, s, 0,
    			 0, 1, 0, 0,
    			- s, 0, c, 0,
    			 0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationZ: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			c, - s, 0, 0,
    			s,  c, 0, 0,
    			0,  0, 1, 0,
    			0,  0, 0, 1

    		);

    		return this;

    	},

    	makeRotationAxis: function ( axis, angle ) {

    		// Based on http://www.gamedev.net/reference/articles/article1199.asp

    		var c = Math.cos( angle );
    		var s = Math.sin( angle );
    		var t = 1 - c;
    		var x = axis.x, y = axis.y, z = axis.z;
    		var tx = t * x, ty = t * y;

    		this.set(

    			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
    			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
    			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
    			0, 0, 0, 1

    		);

    		 return this;

    	},

    	makeScale: function ( x, y, z ) {

    		this.set(

    			x, 0, 0, 0,
    			0, y, 0, 0,
    			0, 0, z, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	compose: function ( position, quaternion, scale ) {

    		this.makeRotationFromQuaternion( quaternion );
    		this.scale( scale );
    		this.setPosition( position );

    		return this;

    	},

    	decompose: function () {

    		var vector, matrix;

    		return function decompose( position, quaternion, scale ) {

    			if ( vector === undefined ) {

    				vector = new Vector3();
    				matrix = new Matrix4();

    			}

    			var te = this.elements;

    			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
    			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
    			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

    			// if determine is negative, we need to invert one scale
    			var det = this.determinant();
    			if ( det < 0 ) {

    				sx = - sx;

    			}

    			position.x = te[ 12 ];
    			position.y = te[ 13 ];
    			position.z = te[ 14 ];

    			// scale the rotation part

    			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

    			var invSX = 1 / sx;
    			var invSY = 1 / sy;
    			var invSZ = 1 / sz;

    			matrix.elements[ 0 ] *= invSX;
    			matrix.elements[ 1 ] *= invSX;
    			matrix.elements[ 2 ] *= invSX;

    			matrix.elements[ 4 ] *= invSY;
    			matrix.elements[ 5 ] *= invSY;
    			matrix.elements[ 6 ] *= invSY;

    			matrix.elements[ 8 ] *= invSZ;
    			matrix.elements[ 9 ] *= invSZ;
    			matrix.elements[ 10 ] *= invSZ;

    			quaternion.setFromRotationMatrix( matrix );

    			scale.x = sx;
    			scale.y = sy;
    			scale.z = sz;

    			return this;

    		};

    	}(),

    	makeFrustum: function ( left, right, bottom, top, near, far ) {

    		var te = this.elements;
    		var x = 2 * near / ( right - left );
    		var y = 2 * near / ( top - bottom );

    		var a = ( right + left ) / ( right - left );
    		var b = ( top + bottom ) / ( top - bottom );
    		var c = - ( far + near ) / ( far - near );
    		var d = - 2 * far * near / ( far - near );

    		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
    		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

    		return this;

    	},

    	makePerspective: function ( fov, aspect, near, far ) {

    		var ymax = near * Math.tan( exports.Math.DEG2RAD * fov * 0.5 );
    		var ymin = - ymax;
    		var xmin = ymin * aspect;
    		var xmax = ymax * aspect;

    		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

    	},

    	makeOrthographic: function ( left, right, top, bottom, near, far ) {

    		var te = this.elements;
    		var w = 1.0 / ( right - left );
    		var h = 1.0 / ( top - bottom );
    		var p = 1.0 / ( far - near );

    		var x = ( right + left ) * w;
    		var y = ( top + bottom ) * h;
    		var z = ( far + near ) * p;

    		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
    		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

    		return this;

    	},

    	equals: function ( matrix ) {

    		var te = this.elements;
    		var me = matrix.elements;

    		for ( var i = 0; i < 16; i ++ ) {

    			if ( te[ i ] !== me[ i ] ) return false;

    		}

    		return true;

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		for( var i = 0; i < 16; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		var te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];
    		array[ offset + 3 ] = te[ 3 ];

    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];
    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];

    		array[ offset + 8 ]  = te[ 8 ];
    		array[ offset + 9 ]  = te[ 9 ];
    		array[ offset + 10 ] = te[ 10 ];
    		array[ offset + 11 ] = te[ 11 ];

    		array[ offset + 12 ] = te[ 12 ];
    		array[ offset + 13 ] = te[ 13 ];
    		array[ offset + 14 ] = te[ 14 ];
    		array[ offset + 15 ] = te[ 15 ];

    		return array;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    	images = images !== undefined ? images : [];
    	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

    	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.flipY = false;

    }

    CubeTexture.prototype = Object.create( Texture.prototype );
    CubeTexture.prototype.constructor = CubeTexture;

    CubeTexture.prototype.isCubeTexture = true;

    Object.defineProperty( CubeTexture.prototype, 'images', {

    	get: function () {

    		return this.image;

    	},

    	set: function ( value ) {

    		this.image = value;

    	}

    } );

    var emptyTexture = new Texture();
    var emptyCubeTexture = new CubeTexture();

    // --- Base for inner nodes (including the root) ---

    function UniformContainer() {

    	this.seq = [];
    	this.map = {};

    }

    // --- Utilities ---

    // Array Caches (provide typed arrays for temporary by size)

    var arrayCacheF32 = [];
    var arrayCacheI32 = [];

    // Flattening for arrays of vectors and matrices

    function flatten( array, nBlocks, blockSize ) {

    	var firstElem = array[ 0 ];

    	if ( firstElem <= 0 || firstElem > 0 ) return array;
    	// unoptimized: ! isNaN( firstElem )
    	// see http://jacksondunstan.com/articles/983

    	var n = nBlocks * blockSize,
    		r = arrayCacheF32[ n ];

    	if ( r === undefined ) {

    		r = new Float32Array( n );
    		arrayCacheF32[ n ] = r;

    	}

    	if ( nBlocks !== 0 ) {

    		firstElem.toArray( r, 0 );

    		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

    			offset += blockSize;
    			array[ i ].toArray( r, offset );

    		}

    	}

    	return r;

    }

    // Texture unit allocation

    function allocTexUnits( renderer, n ) {

    	var r = arrayCacheI32[ n ];

    	if ( r === undefined ) {

    		r = new Int32Array( n );
    		arrayCacheI32[ n ] = r;

    	}

    	for ( var i = 0; i !== n; ++ i )
    		r[ i ] = renderer.allocTextureUnit();

    	return r;

    }

    // --- Setters ---

    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.

    // Single scalar

    function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
    function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

    // Single float vector (from flat array or THREE.VectorN)

    function setValue2fv( gl, v ) {

    	if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
    	else gl.uniform2f( this.addr, v.x, v.y );

    }

    function setValue3fv( gl, v ) {

    	if ( v.x !== undefined )
    		gl.uniform3f( this.addr, v.x, v.y, v.z );
    	else if ( v.r !== undefined )
    		gl.uniform3f( this.addr, v.r, v.g, v.b );
    	else
    		gl.uniform3fv( this.addr, v );

    }

    function setValue4fv( gl, v ) {

    	if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
    	else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

    }

    // Single matrix (from flat array or MatrixN)

    function setValue2fm( gl, v ) {

    	gl.uniformMatrix2fv( this.addr, false, v.elements || v );

    }

    function setValue3fm( gl, v ) {

    	gl.uniformMatrix3fv( this.addr, false, v.elements || v );

    }

    function setValue4fm( gl, v ) {

    	gl.uniformMatrix4fv( this.addr, false, v.elements || v );

    }

    // Single texture (2D / Cube)

    function setValueT1( gl, v, renderer ) {

    	var unit = renderer.allocTextureUnit();
    	gl.uniform1i( this.addr, unit );
    	renderer.setTexture2D( v || emptyTexture, unit );

    }

    function setValueT6( gl, v, renderer ) {

    	var unit = renderer.allocTextureUnit();
    	gl.uniform1i( this.addr, unit );
    	renderer.setTextureCube( v || emptyCubeTexture, unit );

    }

    // Integer / Boolean vectors or arrays thereof (always flat arrays)

    function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
    function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
    function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

    // Helper to pick the right setter for the singular case

    function getSingularSetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValue1f; // FLOAT
    		case 0x8b50: return setValue2fv; // _VEC2
    		case 0x8b51: return setValue3fv; // _VEC3
    		case 0x8b52: return setValue4fv; // _VEC4

    		case 0x8b5a: return setValue2fm; // _MAT2
    		case 0x8b5b: return setValue3fm; // _MAT3
    		case 0x8b5c: return setValue4fm; // _MAT4

    		case 0x8b5e: return setValueT1; // SAMPLER_2D
    		case 0x8b60: return setValueT6; // SAMPLER_CUBE

    		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
    		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
    		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    	}

    }

    // Array of scalars

    function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
    function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

    // Array of vectors (flat or from THREE classes)

    function setValueV2a( gl, v ) {

    	gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

    }

    function setValueV3a( gl, v ) {

    	gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

    }

    function setValueV4a( gl, v ) {

    	gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

    }

    // Array of matrices (flat or from THREE clases)

    function setValueM2a( gl, v ) {

    	gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

    }

    function setValueM3a( gl, v ) {

    	gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

    }

    function setValueM4a( gl, v ) {

    	gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

    }

    // Array of textures (2D / Cube)

    function setValueT1a( gl, v, renderer ) {

    	var n = v.length,
    		units = allocTexUnits( renderer, n );

    	gl.uniform1iv( this.addr, units );

    	for ( var i = 0; i !== n; ++ i ) {

    		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

    	}

    }

    function setValueT6a( gl, v, renderer ) {

    	var n = v.length,
    		units = allocTexUnits( renderer, n );

    	gl.uniform1iv( this.addr, units );

    	for ( var i = 0; i !== n; ++ i ) {

    		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

    	}

    }

    // Helper to pick the right setter for a pure (bottom-level) array

    function getPureArraySetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValue1fv; // FLOAT
    		case 0x8b50: return setValueV2a; // _VEC2
    		case 0x8b51: return setValueV3a; // _VEC3
    		case 0x8b52: return setValueV4a; // _VEC4

    		case 0x8b5a: return setValueM2a; // _MAT2
    		case 0x8b5b: return setValueM3a; // _MAT3
    		case 0x8b5c: return setValueM4a; // _MAT4

    		case 0x8b5e: return setValueT1a; // SAMPLER_2D
    		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

    		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
    		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
    		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    	}

    }

    // --- Uniform Classes ---

    function SingleUniform( id, activeInfo, addr ) {

    	this.id = id;
    	this.addr = addr;
    	this.setValue = getSingularSetter( activeInfo.type );

    	// this.path = activeInfo.name; // DEBUG

    }

    function PureArrayUniform( id, activeInfo, addr ) {

    	this.id = id;
    	this.addr = addr;
    	this.size = activeInfo.size;
    	this.setValue = getPureArraySetter( activeInfo.type );

    	// this.path = activeInfo.name; // DEBUG

    }

    function StructuredUniform( id ) {

    	this.id = id;

    	UniformContainer.call( this ); // mix-in

    }

    StructuredUniform.prototype.setValue = function( gl, value ) {

    	// Note: Don't need an extra 'renderer' parameter, since samplers
    	// are not allowed in structured uniforms.

    	var seq = this.seq;

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ];
    		u.setValue( gl, value[ u.id ] );

    	}

    };

    // --- Top-level ---

    // Parser - builds up the property tree from the path strings

    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

    // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.

    function addUniform( container, uniformObject ) {

    	container.seq.push( uniformObject );
    	container.map[ uniformObject.id ] = uniformObject;

    }

    function parseUniform( activeInfo, addr, container ) {

    	var path = activeInfo.name,
    		pathLength = path.length;

    	// reset RegExp object, because of the early exit of a previous run
    	RePathPart.lastIndex = 0;

    	for (; ;) {

    		var match = RePathPart.exec( path ),
    			matchEnd = RePathPart.lastIndex,

    			id = match[ 1 ],
    			idIsIndex = match[ 2 ] === ']',
    			subscript = match[ 3 ];

    		if ( idIsIndex ) id = id | 0; // convert to integer

    		if ( subscript === undefined ||
    				subscript === '[' && matchEnd + 2 === pathLength ) {
    			// bare name or "pure" bottom-level array "[0]" suffix

    			addUniform( container, subscript === undefined ?
    					new SingleUniform( id, activeInfo, addr ) :
    					new PureArrayUniform( id, activeInfo, addr ) );

    			break;

    		} else {
    			// step into inner node / create it in case it doesn't exist

    			var map = container.map,
    				next = map[ id ];

    			if ( next === undefined ) {

    				next = new StructuredUniform( id );
    				addUniform( container, next );

    			}

    			container = next;

    		}

    	}

    }

    // Root Container

    function WebGLUniforms( gl, program, renderer ) {

    	UniformContainer.call( this );

    	this.renderer = renderer;

    	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

    	for ( var i = 0; i !== n; ++ i ) {

    		var info = gl.getActiveUniform( program, i ),
    			path = info.name,
    			addr = gl.getUniformLocation( program, path );

    		parseUniform( info, addr, this );

    	}

    }

    WebGLUniforms.prototype.setValue = function( gl, name, value ) {

    	var u = this.map[ name ];

    	if ( u !== undefined ) u.setValue( gl, value, this.renderer );

    };

    WebGLUniforms.prototype.set = function( gl, object, name ) {

    	var u = this.map[ name ];

    	if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

    };

    WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

    	var v = object[ name ];

    	if ( v !== undefined ) this.setValue( gl, name, v );

    };


    // Static interface

    WebGLUniforms.upload = function( gl, seq, values, renderer ) {

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ],
    			v = values[ u.id ];

    		if ( v.needsUpdate !== false ) {
    			// note: always updating when .needsUpdate is undefined

    			u.setValue( gl, v.value, renderer );

    		}

    	}

    };

    WebGLUniforms.seqWithValue = function( seq, values ) {

    	var r = [];

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ];
    		if ( u.id in values ) r.push( u );

    	}

    	return r;

    };

    WebGLUniforms.splitDynamic = function( seq, values ) {

    	var r = null,
    		n = seq.length,
    		w = 0;

    	for ( var i = 0; i !== n; ++ i ) {

    		var u = seq[ i ],
    			v = values[ u.id ];

    		if ( v && v.dynamic === true ) {

    			if ( r === null ) r = [];
    			r.push( u );

    		} else {

    			// in-place compact 'seq', removing the matches
    			if ( w < i ) seq[ w ] = u;
    			++ w;

    		}

    	}

    	if ( w < n ) seq.length = w;

    	return r;

    };

    WebGLUniforms.evalDynamic = function( seq, values, object, material, camera ) {

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var v = values[ seq[ i ].id ],
    			f = v.onUpdateCallback;

    		if ( f !== undefined ) f.call( v, object, material, camera );

    	}

    };

    /**
     * Uniform Utilities
     */

    exports.UniformsUtils = {

    	merge: function ( uniforms ) {

    		var merged = {};

    		for ( var u = 0; u < uniforms.length; u ++ ) {

    			var tmp = this.clone( uniforms[ u ] );

    			for ( var p in tmp ) {

    				merged[ p ] = tmp[ p ];

    			}

    		}

    		return merged;

    	},

    	clone: function ( uniforms_src ) {

    		var uniforms_dst = {};

    		for ( var u in uniforms_src ) {

    			uniforms_dst[ u ] = {};

    			for ( var p in uniforms_src[ u ] ) {

    				var parameter_src = uniforms_src[ u ][ p ];

    				if ( (parameter_src && parameter_src.isColor) ||
    					 (parameter_src && parameter_src.isVector2) ||
    					 (parameter_src && parameter_src.isVector3) ||
    					 (parameter_src && parameter_src.isVector4) ||
    					 (parameter_src && parameter_src.isMatrix3) ||
    					 (parameter_src && parameter_src.isMatrix4) ||
    					 (parameter_src && parameter_src.isTexture) ) {

    					uniforms_dst[ u ][ p ] = parameter_src.clone();

    				} else if ( Array.isArray( parameter_src ) ) {

    					uniforms_dst[ u ][ p ] = parameter_src.slice();

    				} else {

    					uniforms_dst[ u ][ p ] = parameter_src;

    				}

    			}

    		}

    		return uniforms_dst;

    	}

    };

    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

    var begin_vertex = "\nvec3 transformed = vec3( position );\n";

    var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

    var bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n";

    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";

    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

    var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

    var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

    var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

    var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

    var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

    var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

    var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

    var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

    var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";

    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

    var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

    var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

    var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";

    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

    var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

    var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

    var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

    var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

    var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

    var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

    var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

    var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

    var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";

    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";

    var normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";

    var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var ShaderChunk = {
    	alphamap_fragment: alphamap_fragment,
    	alphamap_pars_fragment: alphamap_pars_fragment,
    	alphatest_fragment: alphatest_fragment,
    	aomap_fragment: aomap_fragment,
    	aomap_pars_fragment: aomap_pars_fragment,
    	begin_vertex: begin_vertex,
    	beginnormal_vertex: beginnormal_vertex,
    	bsdfs: bsdfs,
    	bumpmap_pars_fragment: bumpmap_pars_fragment,
    	clipping_planes_fragment: clipping_planes_fragment,
    	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    	clipping_planes_vertex: clipping_planes_vertex,
    	color_fragment: color_fragment,
    	color_pars_fragment: color_pars_fragment,
    	color_pars_vertex: color_pars_vertex,
    	color_vertex: color_vertex,
    	common: common,
    	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    	defaultnormal_vertex: defaultnormal_vertex,
    	displacementmap_pars_vertex: displacementmap_pars_vertex,
    	displacementmap_vertex: displacementmap_vertex,
    	emissivemap_fragment: emissivemap_fragment,
    	emissivemap_pars_fragment: emissivemap_pars_fragment,
    	encodings_fragment: encodings_fragment,
    	encodings_pars_fragment: encodings_pars_fragment,
    	envmap_fragment: envmap_fragment,
    	envmap_pars_fragment: envmap_pars_fragment,
    	envmap_pars_vertex: envmap_pars_vertex,
    	envmap_vertex: envmap_vertex,
    	fog_fragment: fog_fragment,
    	fog_pars_fragment: fog_pars_fragment,
    	lightmap_fragment: lightmap_fragment,
    	lightmap_pars_fragment: lightmap_pars_fragment,
    	lights_lambert_vertex: lights_lambert_vertex,
    	lights_pars: lights_pars,
    	lights_phong_fragment: lights_phong_fragment,
    	lights_phong_pars_fragment: lights_phong_pars_fragment,
    	lights_physical_fragment: lights_physical_fragment,
    	lights_physical_pars_fragment: lights_physical_pars_fragment,
    	lights_template: lights_template,
    	logdepthbuf_fragment: logdepthbuf_fragment,
    	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    	logdepthbuf_vertex: logdepthbuf_vertex,
    	map_fragment: map_fragment,
    	map_pars_fragment: map_pars_fragment,
    	map_particle_fragment: map_particle_fragment,
    	map_particle_pars_fragment: map_particle_pars_fragment,
    	metalnessmap_fragment: metalnessmap_fragment,
    	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    	morphnormal_vertex: morphnormal_vertex,
    	morphtarget_pars_vertex: morphtarget_pars_vertex,
    	morphtarget_vertex: morphtarget_vertex,
    	normal_flip: normal_flip,
    	normal_fragment: normal_fragment,
    	normalmap_pars_fragment: normalmap_pars_fragment,
    	packing: packing,
    	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    	project_vertex: project_vertex,
    	roughnessmap_fragment: roughnessmap_fragment,
    	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    	shadowmap_pars_fragment: shadowmap_pars_fragment,
    	shadowmap_pars_vertex: shadowmap_pars_vertex,
    	shadowmap_vertex: shadowmap_vertex,
    	shadowmask_pars_fragment: shadowmask_pars_fragment,
    	skinbase_vertex: skinbase_vertex,
    	skinning_pars_vertex: skinning_pars_vertex,
    	skinning_vertex: skinning_vertex,
    	skinnormal_vertex: skinnormal_vertex,
    	specularmap_fragment: specularmap_fragment,
    	specularmap_pars_fragment: specularmap_pars_fragment,
    	tonemapping_fragment: tonemapping_fragment,
    	tonemapping_pars_fragment: tonemapping_pars_fragment,
    	uv_pars_fragment: uv_pars_fragment,
    	uv_pars_vertex: uv_pars_vertex,
    	uv_vertex: uv_vertex,
    	uv2_pars_fragment: uv2_pars_fragment,
    	uv2_pars_vertex: uv2_pars_vertex,
    	uv2_vertex: uv2_vertex,
    	worldpos_vertex: worldpos_vertex,

    	cube_frag: cube_frag,
    	cube_vert: cube_vert,
    	depth_frag: depth_frag,
    	depth_vert: depth_vert,
    	distanceRGBA_frag: distanceRGBA_frag,
    	distanceRGBA_vert: distanceRGBA_vert,
    	equirect_frag: equirect_frag,
    	equirect_vert: equirect_vert,
    	linedashed_frag: linedashed_frag,
    	linedashed_vert: linedashed_vert,
    	meshbasic_frag: meshbasic_frag,
    	meshbasic_vert: meshbasic_vert,
    	meshlambert_frag: meshlambert_frag,
    	meshlambert_vert: meshlambert_vert,
    	meshphong_frag: meshphong_frag,
    	meshphong_vert: meshphong_vert,
    	meshphysical_frag: meshphysical_frag,
    	meshphysical_vert: meshphysical_vert,
    	normal_frag: normal_frag,
    	normal_vert: normal_vert,
    	points_frag: points_frag,
    	points_vert: points_vert,
    	shadow_frag: shadow_frag,
    	shadow_vert: shadow_vert
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Color( r, g, b ) {

    	if ( g === undefined && b === undefined ) {

    		// r is THREE.Color, hex or string
    		return this.set( r );

    	}

    	return this.setRGB( r, g, b );

    }

    Color.prototype = {

    	constructor: Color,

    	isColor: true,

    	r: 1, g: 1, b: 1,

    	set: function ( value ) {

    		if ( (value && value.isColor) ) {

    			this.copy( value );

    		} else if ( typeof value === 'number' ) {

    			this.setHex( value );

    		} else if ( typeof value === 'string' ) {

    			this.setStyle( value );

    		}

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.r = scalar;
    		this.g = scalar;
    		this.b = scalar;

    	},

    	setHex: function ( hex ) {

    		hex = Math.floor( hex );

    		this.r = ( hex >> 16 & 255 ) / 255;
    		this.g = ( hex >> 8 & 255 ) / 255;
    		this.b = ( hex & 255 ) / 255;

    		return this;

    	},

    	setRGB: function ( r, g, b ) {

    		this.r = r;
    		this.g = g;
    		this.b = b;

    		return this;

    	},

    	setHSL: function () {

    		function hue2rgb( p, q, t ) {

    			if ( t < 0 ) t += 1;
    			if ( t > 1 ) t -= 1;
    			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
    			if ( t < 1 / 2 ) return q;
    			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
    			return p;

    		}

    		return function setHSL( h, s, l ) {

    			// h,s,l ranges are in 0.0 - 1.0
    			h = exports.Math.euclideanModulo( h, 1 );
    			s = exports.Math.clamp( s, 0, 1 );
    			l = exports.Math.clamp( l, 0, 1 );

    			if ( s === 0 ) {

    				this.r = this.g = this.b = l;

    			} else {

    				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
    				var q = ( 2 * l ) - p;

    				this.r = hue2rgb( q, p, h + 1 / 3 );
    				this.g = hue2rgb( q, p, h );
    				this.b = hue2rgb( q, p, h - 1 / 3 );

    			}

    			return this;

    		};

    	}(),

    	setStyle: function ( style ) {

    		function handleAlpha( string ) {

    			if ( string === undefined ) return;

    			if ( parseFloat( string ) < 1 ) {

    				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

    			}

    		}


    		var m;

    		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

    			// rgb / hsl

    			var color;
    			var name = m[ 1 ];
    			var components = m[ 2 ];

    			switch ( name ) {

    				case 'rgb':
    				case 'rgba':

    					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// rgb(255,0,0) rgba(255,0,0,0.5)
    						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
    						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
    						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

    						handleAlpha( color[ 5 ] );

    						return this;

    					}

    					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
    						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
    						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
    						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

    						handleAlpha( color[ 5 ] );

    						return this;

    					}

    					break;

    				case 'hsl':
    				case 'hsla':

    					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
    						var h = parseFloat( color[ 1 ] ) / 360;
    						var s = parseInt( color[ 2 ], 10 ) / 100;
    						var l = parseInt( color[ 3 ], 10 ) / 100;

    						handleAlpha( color[ 5 ] );

    						return this.setHSL( h, s, l );

    					}

    					break;

    			}

    		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

    			// hex color

    			var hex = m[ 1 ];
    			var size = hex.length;

    			if ( size === 3 ) {

    				// #ff0
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

    				return this;

    			} else if ( size === 6 ) {

    				// #ff0000
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

    				return this;

    			}

    		}

    		if ( style && style.length > 0 ) {

    			// color keywords
    			var hex = exports.ColorKeywords[ style ];

    			if ( hex !== undefined ) {

    				// red
    				this.setHex( hex );

    			} else {

    				// unknown color
    				console.warn( 'THREE.Color: Unknown color ' + style );

    			}

    		}

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this.r, this.g, this.b );

    	},

    	copy: function ( color ) {

    		this.r = color.r;
    		this.g = color.g;
    		this.b = color.b;

    		return this;

    	},

    	copyGammaToLinear: function ( color, gammaFactor ) {

    		if ( gammaFactor === undefined ) gammaFactor = 2.0;

    		this.r = Math.pow( color.r, gammaFactor );
    		this.g = Math.pow( color.g, gammaFactor );
    		this.b = Math.pow( color.b, gammaFactor );

    		return this;

    	},

    	copyLinearToGamma: function ( color, gammaFactor ) {

    		if ( gammaFactor === undefined ) gammaFactor = 2.0;

    		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

    		this.r = Math.pow( color.r, safeInverse );
    		this.g = Math.pow( color.g, safeInverse );
    		this.b = Math.pow( color.b, safeInverse );

    		return this;

    	},

    	convertGammaToLinear: function () {

    		var r = this.r, g = this.g, b = this.b;

    		this.r = r * r;
    		this.g = g * g;
    		this.b = b * b;

    		return this;

    	},

    	convertLinearToGamma: function () {

    		this.r = Math.sqrt( this.r );
    		this.g = Math.sqrt( this.g );
    		this.b = Math.sqrt( this.b );

    		return this;

    	},

    	getHex: function () {

    		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    	},

    	getHexString: function () {

    		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

    	},

    	getHSL: function ( optionalTarget ) {

    		// h,s,l ranges are in 0.0 - 1.0

    		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    		var r = this.r, g = this.g, b = this.b;

    		var max = Math.max( r, g, b );
    		var min = Math.min( r, g, b );

    		var hue, saturation;
    		var lightness = ( min + max ) / 2.0;

    		if ( min === max ) {

    			hue = 0;
    			saturation = 0;

    		} else {

    			var delta = max - min;

    			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

    			switch ( max ) {

    				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
    				case g: hue = ( b - r ) / delta + 2; break;
    				case b: hue = ( r - g ) / delta + 4; break;

    			}

    			hue /= 6;

    		}

    		hsl.h = hue;
    		hsl.s = saturation;
    		hsl.l = lightness;

    		return hsl;

    	},

    	getStyle: function () {

    		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    	},

    	offsetHSL: function ( h, s, l ) {

    		var hsl = this.getHSL();

    		hsl.h += h; hsl.s += s; hsl.l += l;

    		this.setHSL( hsl.h, hsl.s, hsl.l );

    		return this;

    	},

    	add: function ( color ) {

    		this.r += color.r;
    		this.g += color.g;
    		this.b += color.b;

    		return this;

    	},

    	addColors: function ( color1, color2 ) {

    		this.r = color1.r + color2.r;
    		this.g = color1.g + color2.g;
    		this.b = color1.b + color2.b;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.r += s;
    		this.g += s;
    		this.b += s;

    		return this;

    	},

    	sub: function( color ) {

    		this.r = Math.max( 0, this.r - color.r );
    		this.g = Math.max( 0, this.g - color.g );
    		this.b = Math.max( 0, this.b - color.b );

    		return this;

    	},

    	multiply: function ( color ) {

    		this.r *= color.r;
    		this.g *= color.g;
    		this.b *= color.b;

    		return this;

    	},

    	multiplyScalar: function ( s ) {

    		this.r *= s;
    		this.g *= s;
    		this.b *= s;

    		return this;

    	},

    	lerp: function ( color, alpha ) {

    		this.r += ( color.r - this.r ) * alpha;
    		this.g += ( color.g - this.g ) * alpha;
    		this.b += ( color.b - this.b ) * alpha;

    		return this;

    	},

    	equals: function ( c ) {

    		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.r = array[ offset ];
    		this.g = array[ offset + 1 ];
    		this.b = array[ offset + 2 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.r;
    		array[ offset + 1 ] = this.g;
    		array[ offset + 2 ] = this.b;

    		return array;

    	},

    	toJSON: function () {

    		return this.getHex();

    	}

    };

    exports.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

    /**
     * Uniforms library for shared webgl shaders
     */

    var UniformsLib = {

    	common: {

    		diffuse: { value: new Color( 0xeeeeee ) },
    		opacity: { value: 1.0 },

    		map: { value: null },
    		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },

    		specularMap: { value: null },
    		alphaMap: { value: null },

    		envMap: { value: null },
    		flipEnvMap: { value: - 1 },
    		reflectivity: { value: 1.0 },
    		refractionRatio: { value: 0.98 }

    	},

    	aomap: {

    		aoMap: { value: null },
    		aoMapIntensity: { value: 1 }

    	},

    	lightmap: {

    		lightMap: { value: null },
    		lightMapIntensity: { value: 1 }

    	},

    	emissivemap: {

    		emissiveMap: { value: null }

    	},

    	bumpmap: {

    		bumpMap: { value: null },
    		bumpScale: { value: 1 }

    	},

    	normalmap: {

    		normalMap: { value: null },
    		normalScale: { value: new Vector2( 1, 1 ) }

    	},

    	displacementmap: {

    		displacementMap: { value: null },
    		displacementScale: { value: 1 },
    		displacementBias: { value: 0 }

    	},

    	roughnessmap: {

    		roughnessMap: { value: null }

    	},

    	metalnessmap: {

    		metalnessMap: { value: null }

    	},

    	fog: {

    		fogDensity: { value: 0.00025 },
    		fogNear: { value: 1 },
    		fogFar: { value: 2000 },
    		fogColor: { value: new Color( 0xffffff ) }

    	},

    	lights: {

    		ambientLightColor: { value: [] },

    		directionalLights: { value: [], properties: {
    			direction: {},
    			color: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		directionalShadowMap: { value: [] },
    		directionalShadowMatrix: { value: [] },

    		spotLights: { value: [], properties: {
    			color: {},
    			position: {},
    			direction: {},
    			distance: {},
    			coneCos: {},
    			penumbraCos: {},
    			decay: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		spotShadowMap: { value: [] },
    		spotShadowMatrix: { value: [] },

    		pointLights: { value: [], properties: {
    			color: {},
    			position: {},
    			decay: {},
    			distance: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		pointShadowMap: { value: [] },
    		pointShadowMatrix: { value: [] },

    		hemisphereLights: { value: [], properties: {
    			direction: {},
    			skyColor: {},
    			groundColor: {}
    		} }

    	},

    	points: {

    		diffuse: { value: new Color( 0xeeeeee ) },
    		opacity: { value: 1.0 },
    		size: { value: 1.0 },
    		scale: { value: 1.0 },
    		map: { value: null },
    		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     */

    var ShaderLib = {

    	basic: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.fog

    		] ),

    		vertexShader: ShaderChunk.meshbasic_vert,
    		fragmentShader: ShaderChunk.meshbasic_frag

    	},

    	lambert: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) }
    			}

    		] ),

    		vertexShader: ShaderChunk.meshlambert_vert,
    		fragmentShader: ShaderChunk.meshlambert_frag

    	},

    	phong: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) },
    				specular : { value: new Color( 0x111111 ) },
    				shininess: { value: 30 }
    			}

    		] ),

    		vertexShader: ShaderChunk.meshphong_vert,
    		fragmentShader: ShaderChunk.meshphong_frag

    	},

    	standard: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.roughnessmap,
    			UniformsLib.metalnessmap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) },
    				roughness: { value: 0.5 },
    				metalness: { value: 0 },
    				envMapIntensity : { value: 1 }, // temporary
    			}

    		] ),

    		vertexShader: ShaderChunk.meshphysical_vert,
    		fragmentShader: ShaderChunk.meshphysical_frag

    	},

    	points: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.points,
    			UniformsLib.fog

    		] ),

    		vertexShader: ShaderChunk.points_vert,
    		fragmentShader: ShaderChunk.points_frag

    	},

    	dashed: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.fog,

    			{
    				scale    : { value: 1 },
    				dashSize : { value: 1 },
    				totalSize: { value: 2 }
    			}

    		] ),

    		vertexShader: ShaderChunk.linedashed_vert,
    		fragmentShader: ShaderChunk.linedashed_frag

    	},

    	depth: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.displacementmap

    		] ),

    		vertexShader: ShaderChunk.depth_vert,
    		fragmentShader: ShaderChunk.depth_frag

    	},

    	normal: {

    		uniforms: {

    			opacity : { value: 1.0 }

    		},

    		vertexShader: ShaderChunk.normal_vert,
    		fragmentShader: ShaderChunk.normal_frag

    	},

    	/* -------------------------------------------------------------------------
    	//	Cube map shader
    	 ------------------------------------------------------------------------- */

    	cube: {

    		uniforms: {
    			tCube: { value: null },
    			tFlip: { value: - 1 },
    			opacity: { value: 1.0 }
    		},

    		vertexShader: ShaderChunk.cube_vert,
    		fragmentShader: ShaderChunk.cube_frag

    	},

    	/* -------------------------------------------------------------------------
    	//	Cube map shader
    	 ------------------------------------------------------------------------- */

    	equirect: {

    		uniforms: {
    			tEquirect: { value: null },
    			tFlip: { value: - 1 }
    		},

    		vertexShader: ShaderChunk.equirect_vert,
    		fragmentShader: ShaderChunk.equirect_frag

    	},

    	distanceRGBA: {

    		uniforms: {

    			lightPos: { value: new Vector3() }

    		},

    		vertexShader: ShaderChunk.distanceRGBA_vert,
    		fragmentShader: ShaderChunk.distanceRGBA_frag

    	}

    };

    ShaderLib.physical = {

    	uniforms: exports.UniformsUtils.merge( [

    		ShaderLib.standard.uniforms,

    		{
    			clearCoat: { value: 0 },
    			clearCoatRoughness: { value: 0 }
    		}

    	] ),

    	vertexShader: ShaderChunk.meshphysical_vert,
    	fragmentShader: ShaderChunk.meshphysical_frag

    };

    /**
     * @author bhouston / http://clara.io
     */

    function Box2( min, max ) {

    	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
    	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

    }

    Box2.prototype = {

    	constructor: Box2,

    	set: function ( min, max ) {

    		this.min.copy( min );
    		this.max.copy( max );

    		return this;

    	},

    	setFromPoints: function ( points ) {

    		this.makeEmpty();

    		for ( var i = 0, il = points.length; i < il; i ++ ) {

    			this.expandByPoint( points[ i ] );

    		}

    		return this;

    	},

    	setFromCenterAndSize: function () {

    		var v1 = new Vector2();

    		return function setFromCenterAndSize( center, size ) {

    			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
    			this.min.copy( center ).sub( halfSize );
    			this.max.copy( center ).add( halfSize );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( box ) {

    		this.min.copy( box.min );
    		this.max.copy( box.max );

    		return this;

    	},

    	makeEmpty: function () {

    		this.min.x = this.min.y = + Infinity;
    		this.max.x = this.max.y = - Infinity;

    		return this;

    	},

    	isEmpty: function () {

    		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    	},

    	getSize: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

    	},

    	expandByPoint: function ( point ) {

    		this.min.min( point );
    		this.max.max( point );

    		return this;

    	},

    	expandByVector: function ( vector ) {

    		this.min.sub( vector );
    		this.max.add( vector );

    		return this;

    	},

    	expandByScalar: function ( scalar ) {

    		this.min.addScalar( - scalar );
    		this.max.addScalar( scalar );

    		return this;

    	},

    	containsPoint: function ( point ) {

    		if ( point.x < this.min.x || point.x > this.max.x ||
    		     point.y < this.min.y || point.y > this.max.y ) {

    			return false;

    		}

    		return true;

    	},

    	containsBox: function ( box ) {

    		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
    		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

    			return true;

    		}

    		return false;

    	},

    	getParameter: function ( point, optionalTarget ) {

    		// This can potentially have a divide by zero if the box
    		// has a size dimension of 0.

    		var result = optionalTarget || new Vector2();

    		return result.set(
    			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
    			( point.y - this.min.y ) / ( this.max.y - this.min.y )
    		);

    	},

    	intersectsBox: function ( box ) {

    		// using 6 splitting planes to rule out intersections.

    		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
    		     box.max.y < this.min.y || box.min.y > this.max.y ) {

    			return false;

    		}

    		return true;

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return result.copy( point ).clamp( this.min, this.max );

    	},

    	distanceToPoint: function () {

    		var v1 = new Vector2();

    		return function distanceToPoint( point ) {

    			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
    			return clampedPoint.sub( point ).length();

    		};

    	}(),

    	intersect: function ( box ) {

    		this.min.max( box.min );
    		this.max.min( box.max );

    		return this;

    	},

    	union: function ( box ) {

    		this.min.min( box.min );
    		this.max.max( box.max );

    		return this;

    	},

    	translate: function ( offset ) {

    		this.min.add( offset );
    		this.max.add( offset );

    		return this;

    	},

    	equals: function ( box ) {

    		return box.min.equals( this.min ) && box.max.equals( this.max );

    	}

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlarePlugin( renderer, flares ) {

    	var gl = renderer.context;
    	var state = renderer.state;

    	var vertexBuffer, elementBuffer;
    	var shader, program, attributes, uniforms;

    	var tempTexture, occlusionTexture;

    	function init() {

    		var vertices = new Float32Array( [
    			- 1, - 1,  0, 0,
    			 1, - 1,  1, 0,
    			 1,  1,  1, 1,
    			- 1,  1,  0, 1
    		] );

    		var faces = new Uint16Array( [
    			0, 1, 2,
    			0, 2, 3
    		] );

    		// buffers

    		vertexBuffer     = gl.createBuffer();
    		elementBuffer    = gl.createBuffer();

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    		// textures

    		tempTexture      = gl.createTexture();
    		occlusionTexture = gl.createTexture();

    		state.bindTexture( gl.TEXTURE_2D, tempTexture );
    		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    		shader = {

    			vertexShader: [

    				"uniform lowp int renderType;",

    				"uniform vec3 screenPosition;",
    				"uniform vec2 scale;",
    				"uniform float rotation;",

    				"uniform sampler2D occlusionMap;",

    				"attribute vec2 position;",
    				"attribute vec2 uv;",

    				"varying vec2 vUV;",
    				"varying float vVisibility;",

    				"void main() {",

    					"vUV = uv;",

    					"vec2 pos = position;",

    					"if ( renderType == 2 ) {",

    						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

    						"vVisibility =        visibility.r / 9.0;",
    						"vVisibility *= 1.0 - visibility.g / 9.0;",
    						"vVisibility *=       visibility.b / 9.0;",
    						"vVisibility *= 1.0 - visibility.a / 9.0;",

    						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
    						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

    					"}",

    					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

    				"}"

    			].join( "\n" ),

    			fragmentShader: [

    				"uniform lowp int renderType;",

    				"uniform sampler2D map;",
    				"uniform float opacity;",
    				"uniform vec3 color;",

    				"varying vec2 vUV;",
    				"varying float vVisibility;",

    				"void main() {",

    					// pink square

    					"if ( renderType == 0 ) {",

    						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

    					// restore

    					"} else if ( renderType == 1 ) {",

    						"gl_FragColor = texture2D( map, vUV );",

    					// flare

    					"} else {",

    						"vec4 texture = texture2D( map, vUV );",
    						"texture.a *= opacity * vVisibility;",
    						"gl_FragColor = texture;",
    						"gl_FragColor.rgb *= color;",

    					"}",

    				"}"

    			].join( "\n" )

    		};

    		program = createProgram( shader );

    		attributes = {
    			vertex: gl.getAttribLocation ( program, "position" ),
    			uv:     gl.getAttribLocation ( program, "uv" )
    		};

    		uniforms = {
    			renderType:     gl.getUniformLocation( program, "renderType" ),
    			map:            gl.getUniformLocation( program, "map" ),
    			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
    			opacity:        gl.getUniformLocation( program, "opacity" ),
    			color:          gl.getUniformLocation( program, "color" ),
    			scale:          gl.getUniformLocation( program, "scale" ),
    			rotation:       gl.getUniformLocation( program, "rotation" ),
    			screenPosition: gl.getUniformLocation( program, "screenPosition" )
    		};

    	}

    	/*
    	 * Render lens flares
    	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
    	 *         reads these back and calculates occlusion.
    	 */

    	this.render = function ( scene, camera, viewport ) {

    		if ( flares.length === 0 ) return;

    		var tempPosition = new Vector3();

    		var invAspect = viewport.w / viewport.z,
    			halfViewportWidth = viewport.z * 0.5,
    			halfViewportHeight = viewport.w * 0.5;

    		var size = 16 / viewport.w,
    			scale = new Vector2( size * invAspect, size );

    		var screenPosition = new Vector3( 1, 1, 0 ),
    			screenPositionPixels = new Vector2( 1, 1 );

    		var validArea = new Box2();

    		validArea.min.set( 0, 0 );
    		validArea.max.set( viewport.z - 16, viewport.w - 16 );

    		if ( program === undefined ) {

    			init();

    		}

    		gl.useProgram( program );

    		state.initAttributes();
    		state.enableAttribute( attributes.vertex );
    		state.enableAttribute( attributes.uv );
    		state.disableUnusedAttributes();

    		// loop through all lens flares to update their occlusion and positions
    		// setup gl and common used attribs/uniforms

    		gl.uniform1i( uniforms.occlusionMap, 0 );
    		gl.uniform1i( uniforms.map, 1 );

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
    		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    		state.disable( gl.CULL_FACE );
    		state.setDepthWrite( false );

    		for ( var i = 0, l = flares.length; i < l; i ++ ) {

    			size = 16 / viewport.w;
    			scale.set( size * invAspect, size );

    			// calc object screen position

    			var flare = flares[ i ];

    			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

    			tempPosition.applyMatrix4( camera.matrixWorldInverse );
    			tempPosition.applyProjection( camera.projectionMatrix );

    			// setup arrays for gl programs

    			screenPosition.copy( tempPosition );

    			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

    			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
    			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

    			// screen cull

    			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

    				// save current RGB to temp texture

    				state.activeTexture( gl.TEXTURE0 );
    				state.bindTexture( gl.TEXTURE_2D, null );
    				state.activeTexture( gl.TEXTURE1 );
    				state.bindTexture( gl.TEXTURE_2D, tempTexture );
    				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


    				// render pink quad

    				gl.uniform1i( uniforms.renderType, 0 );
    				gl.uniform2f( uniforms.scale, scale.x, scale.y );
    				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

    				state.disable( gl.BLEND );
    				state.enable( gl.DEPTH_TEST );

    				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


    				// copy result to occlusionMap

    				state.activeTexture( gl.TEXTURE0 );
    				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


    				// restore graphics

    				gl.uniform1i( uniforms.renderType, 1 );
    				state.disable( gl.DEPTH_TEST );

    				state.activeTexture( gl.TEXTURE1 );
    				state.bindTexture( gl.TEXTURE_2D, tempTexture );
    				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


    				// update object positions

    				flare.positionScreen.copy( screenPosition );

    				if ( flare.customUpdateCallback ) {

    					flare.customUpdateCallback( flare );

    				} else {

    					flare.updateLensFlares();

    				}

    				// render flares

    				gl.uniform1i( uniforms.renderType, 2 );
    				state.enable( gl.BLEND );

    				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

    					var sprite = flare.lensFlares[ j ];

    					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

    						screenPosition.x = sprite.x;
    						screenPosition.y = sprite.y;
    						screenPosition.z = sprite.z;

    						size = sprite.size * sprite.scale / viewport.w;

    						scale.x = size * invAspect;
    						scale.y = size;

    						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
    						gl.uniform2f( uniforms.scale, scale.x, scale.y );
    						gl.uniform1f( uniforms.rotation, sprite.rotation );

    						gl.uniform1f( uniforms.opacity, sprite.opacity );
    						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

    						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
    						renderer.setTexture2D( sprite.texture, 1 );

    						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    					}

    				}

    			}

    		}

    		// restore gl

    		state.enable( gl.CULL_FACE );
    		state.enable( gl.DEPTH_TEST );
    		state.setDepthWrite( true );

    		renderer.resetGLState();

    	};

    	function createProgram( shader ) {

    		var program = gl.createProgram();

    		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
    		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

    		var prefix = "precision " + renderer.getPrecision() + " float;\n";

    		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
    		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

    		gl.compileShader( fragmentShader );
    		gl.compileShader( vertexShader );

    		gl.attachShader( program, fragmentShader );
    		gl.attachShader( program, vertexShader );

    		gl.linkProgram( program );

    		return program;

    	}

    }

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function SpritePlugin( renderer, sprites ) {

    	var gl = renderer.context;
    	var state = renderer.state;

    	var vertexBuffer, elementBuffer;
    	var program, attributes, uniforms;

    	var texture;

    	// decompose matrixWorld

    	var spritePosition = new Vector3();
    	var spriteRotation = new Quaternion();
    	var spriteScale = new Vector3();

    	function init() {

    		var vertices = new Float32Array( [
    			- 0.5, - 0.5,  0, 0,
    			  0.5, - 0.5,  1, 0,
    			  0.5,   0.5,  1, 1,
    			- 0.5,   0.5,  0, 1
    		] );

    		var faces = new Uint16Array( [
    			0, 1, 2,
    			0, 2, 3
    		] );

    		vertexBuffer  = gl.createBuffer();
    		elementBuffer = gl.createBuffer();

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    		program = createProgram();

    		attributes = {
    			position:			gl.getAttribLocation ( program, 'position' ),
    			uv:					gl.getAttribLocation ( program, 'uv' )
    		};

    		uniforms = {
    			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
    			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

    			rotation:			gl.getUniformLocation( program, 'rotation' ),
    			scale:				gl.getUniformLocation( program, 'scale' ),

    			color:				gl.getUniformLocation( program, 'color' ),
    			map:				gl.getUniformLocation( program, 'map' ),
    			opacity:			gl.getUniformLocation( program, 'opacity' ),

    			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
    			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

    			fogType:			gl.getUniformLocation( program, 'fogType' ),
    			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
    			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
    			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
    			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

    			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
    		};

    		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    		canvas.width = 8;
    		canvas.height = 8;

    		var context = canvas.getContext( '2d' );
    		context.fillStyle = 'white';
    		context.fillRect( 0, 0, 8, 8 );

    		texture = new Texture( canvas );
    		texture.needsUpdate = true;

    	}

    	this.render = function ( scene, camera ) {

    		if ( sprites.length === 0 ) return;

    		// setup gl

    		if ( program === undefined ) {

    			init();

    		}

    		gl.useProgram( program );

    		state.initAttributes();
    		state.enableAttribute( attributes.position );
    		state.enableAttribute( attributes.uv );
    		state.disableUnusedAttributes();

    		state.disable( gl.CULL_FACE );
    		state.enable( gl.BLEND );

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
    		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

    		state.activeTexture( gl.TEXTURE0 );
    		gl.uniform1i( uniforms.map, 0 );

    		var oldFogType = 0;
    		var sceneFogType = 0;
    		var fog = scene.fog;

    		if ( fog ) {

    			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

    			if ( (fog && fog.isFog) ) {

    				gl.uniform1f( uniforms.fogNear, fog.near );
    				gl.uniform1f( uniforms.fogFar, fog.far );

    				gl.uniform1i( uniforms.fogType, 1 );
    				oldFogType = 1;
    				sceneFogType = 1;

    			} else if ( (fog && fog.isFogExp2) ) {

    				gl.uniform1f( uniforms.fogDensity, fog.density );

    				gl.uniform1i( uniforms.fogType, 2 );
    				oldFogType = 2;
    				sceneFogType = 2;

    			}

    		} else {

    			gl.uniform1i( uniforms.fogType, 0 );
    			oldFogType = 0;
    			sceneFogType = 0;

    		}


    		// update positions and sort

    		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

    			var sprite = sprites[ i ];

    			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
    			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

    		}

    		sprites.sort( painterSortStable );

    		// render all sprites

    		var scale = [];

    		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

    			var sprite = sprites[ i ];
    			var material = sprite.material;

    			if ( material.visible === false ) continue;

    			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
    			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

    			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

    			scale[ 0 ] = spriteScale.x;
    			scale[ 1 ] = spriteScale.y;

    			var fogType = 0;

    			if ( scene.fog && material.fog ) {

    				fogType = sceneFogType;

    			}

    			if ( oldFogType !== fogType ) {

    				gl.uniform1i( uniforms.fogType, fogType );
    				oldFogType = fogType;

    			}

    			if ( material.map !== null ) {

    				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
    				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

    			} else {

    				gl.uniform2f( uniforms.uvOffset, 0, 0 );
    				gl.uniform2f( uniforms.uvScale, 1, 1 );

    			}

    			gl.uniform1f( uniforms.opacity, material.opacity );
    			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

    			gl.uniform1f( uniforms.rotation, material.rotation );
    			gl.uniform2fv( uniforms.scale, scale );

    			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
    			state.setDepthTest( material.depthTest );
    			state.setDepthWrite( material.depthWrite );

    			if ( material.map ) {

    				renderer.setTexture2D( material.map, 0 );

    			} else {

    				renderer.setTexture2D( texture, 0 );

    			}

    			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    		}

    		// restore gl

    		state.enable( gl.CULL_FACE );

    		renderer.resetGLState();

    	};

    	function createProgram() {

    		var program = gl.createProgram();

    		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
    		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

    		gl.shaderSource( vertexShader, [

    			'precision ' + renderer.getPrecision() + ' float;',

    			'uniform mat4 modelViewMatrix;',
    			'uniform mat4 projectionMatrix;',
    			'uniform float rotation;',
    			'uniform vec2 scale;',
    			'uniform vec2 uvOffset;',
    			'uniform vec2 uvScale;',

    			'attribute vec2 position;',
    			'attribute vec2 uv;',

    			'varying vec2 vUV;',

    			'void main() {',

    				'vUV = uvOffset + uv * uvScale;',

    				'vec2 alignedPosition = position * scale;',

    				'vec2 rotatedPosition;',
    				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
    				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

    				'vec4 finalPosition;',

    				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
    				'finalPosition.xy += rotatedPosition;',
    				'finalPosition = projectionMatrix * finalPosition;',

    				'gl_Position = finalPosition;',

    			'}'

    		].join( '\n' ) );

    		gl.shaderSource( fragmentShader, [

    			'precision ' + renderer.getPrecision() + ' float;',

    			'uniform vec3 color;',
    			'uniform sampler2D map;',
    			'uniform float opacity;',

    			'uniform int fogType;',
    			'uniform vec3 fogColor;',
    			'uniform float fogDensity;',
    			'uniform float fogNear;',
    			'uniform float fogFar;',
    			'uniform float alphaTest;',

    			'varying vec2 vUV;',

    			'void main() {',

    				'vec4 texture = texture2D( map, vUV );',

    				'if ( texture.a < alphaTest ) discard;',

    				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

    				'if ( fogType > 0 ) {',

    					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
    					'float fogFactor = 0.0;',

    					'if ( fogType == 1 ) {',

    						'fogFactor = smoothstep( fogNear, fogFar, depth );',

    					'} else {',

    						'const float LOG2 = 1.442695;',
    						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
    						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

    					'}',

    					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

    				'}',

    			'}'

    		].join( '\n' ) );

    		gl.compileShader( vertexShader );
    		gl.compileShader( fragmentShader );

    		gl.attachShader( program, vertexShader );
    		gl.attachShader( program, fragmentShader );

    		gl.linkProgram( program );

    		return program;

    	}

    	function painterSortStable( a, b ) {

    		if ( a.renderOrder !== b.renderOrder ) {

    			return a.renderOrder - b.renderOrder;

    		} else if ( a.z !== b.z ) {

    			return b.z - a.z;

    		} else {

    			return b.id - a.id;

    		}

    	}

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Material() {

    	Object.defineProperty( this, 'id', { value: MaterialIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Material';

    	this.fog = true;
    	this.lights = true;

    	this.blending = NormalBlending;
    	this.side = FrontSide;
    	this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
    	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

    	this.opacity = 1;
    	this.transparent = false;

    	this.blendSrc = SrcAlphaFactor;
    	this.blendDst = OneMinusSrcAlphaFactor;
    	this.blendEquation = AddEquation;
    	this.blendSrcAlpha = null;
    	this.blendDstAlpha = null;
    	this.blendEquationAlpha = null;

    	this.depthFunc = LessEqualDepth;
    	this.depthTest = true;
    	this.depthWrite = true;

    	this.clippingPlanes = null;
    	this.clipShadows = false;

    	this.colorWrite = true;

    	this.precision = null; // override the renderer's default precision for this material

    	this.polygonOffset = false;
    	this.polygonOffsetFactor = 0;
    	this.polygonOffsetUnits = 0;

    	this.alphaTest = 0;
    	this.premultipliedAlpha = false;

    	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    	this.visible = true;

    	this._needsUpdate = true;

    }

    Material.prototype = {

    	constructor: Material,

    	isMaterial: true,

    	get needsUpdate() {

    		return this._needsUpdate;

    	},

    	set needsUpdate( value ) {

    		if ( value === true ) this.update();
    		this._needsUpdate = value;

    	},

    	setValues: function ( values ) {

    		if ( values === undefined ) return;

    		for ( var key in values ) {

    			var newValue = values[ key ];

    			if ( newValue === undefined ) {

    				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
    				continue;

    			}

    			var currentValue = this[ key ];

    			if ( currentValue === undefined ) {

    				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
    				continue;

    			}

    			if ( (currentValue && currentValue.isColor) ) {

    				currentValue.set( newValue );

    			} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {

    				currentValue.copy( newValue );

    			} else if ( key === 'overdraw' ) {

    				// ensure overdraw is backwards-compatible with legacy boolean type
    				this[ key ] = Number( newValue );

    			} else {

    				this[ key ] = newValue;

    			}

    		}

    	},

    	toJSON: function ( meta ) {

    		var isRoot = meta === undefined;

    		if ( isRoot ) {

    			meta = {
    				textures: {},
    				images: {}
    			};

    		}

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'Material',
    				generator: 'Material.toJSON'
    			}
    		};

    		// standard Material serialization
    		data.uuid = this.uuid;
    		data.type = this.type;

    		if ( this.name !== '' ) data.name = this.name;

    		if ( (this.color && this.color.isColor) ) data.color = this.color.getHex();

    		if ( this.roughness !== undefined ) data.roughness = this.roughness;
    		if ( this.metalness !== undefined ) data.metalness = this.metalness;

    		if ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();
    		if ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();
    		if ( this.shininess !== undefined ) data.shininess = this.shininess;

    		if ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;
    		if ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
    		if ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
    		if ( (this.bumpMap && this.bumpMap.isTexture) ) {

    			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
    			data.bumpScale = this.bumpScale;

    		}
    		if ( (this.normalMap && this.normalMap.isTexture) ) {

    			data.normalMap = this.normalMap.toJSON( meta ).uuid;
    			data.normalScale = this.normalScale.toArray();

    		}
    		if ( (this.displacementMap && this.displacementMap.isTexture) ) {

    			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
    			data.displacementScale = this.displacementScale;
    			data.displacementBias = this.displacementBias;

    		}
    		if ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
    		if ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

    		if ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
    		if ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

    		if ( (this.envMap && this.envMap.isTexture) ) {

    			data.envMap = this.envMap.toJSON( meta ).uuid;
    			data.reflectivity = this.reflectivity; // Scale behind envMap

    		}

    		if ( this.size !== undefined ) data.size = this.size;
    		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

    		if ( this.blending !== NormalBlending ) data.blending = this.blending;
    		if ( this.shading !== SmoothShading ) data.shading = this.shading;
    		if ( this.side !== FrontSide ) data.side = this.side;
    		if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

    		if ( this.opacity < 1 ) data.opacity = this.opacity;
    		if ( this.transparent === true ) data.transparent = this.transparent;

    		data.depthFunc = this.depthFunc;
    		data.depthTest = this.depthTest;
    		data.depthWrite = this.depthWrite;

    		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
    		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
    		if ( this.wireframe === true ) data.wireframe = this.wireframe;
    		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
    		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
    		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

    		data.skinning = this.skinning;
    		data.morphTargets = this.morphTargets;

    		// TODO: Copied from Object3D.toJSON

    		function extractFromCache( cache ) {

    			var values = [];

    			for ( var key in cache ) {

    				var data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}

    			return values;

    		}

    		if ( isRoot ) {

    			var textures = extractFromCache( meta.textures );
    			var images = extractFromCache( meta.images );

    			if ( textures.length > 0 ) data.textures = textures;
    			if ( images.length > 0 ) data.images = images;

    		}

    		return data;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.name = source.name;

    		this.fog = source.fog;
    		this.lights = source.lights;

    		this.blending = source.blending;
    		this.side = source.side;
    		this.shading = source.shading;
    		this.vertexColors = source.vertexColors;

    		this.opacity = source.opacity;
    		this.transparent = source.transparent;

    		this.blendSrc = source.blendSrc;
    		this.blendDst = source.blendDst;
    		this.blendEquation = source.blendEquation;
    		this.blendSrcAlpha = source.blendSrcAlpha;
    		this.blendDstAlpha = source.blendDstAlpha;
    		this.blendEquationAlpha = source.blendEquationAlpha;

    		this.depthFunc = source.depthFunc;
    		this.depthTest = source.depthTest;
    		this.depthWrite = source.depthWrite;

    		this.colorWrite = source.colorWrite;

    		this.precision = source.precision;

    		this.polygonOffset = source.polygonOffset;
    		this.polygonOffsetFactor = source.polygonOffsetFactor;
    		this.polygonOffsetUnits = source.polygonOffsetUnits;

    		this.alphaTest = source.alphaTest;

    		this.premultipliedAlpha = source.premultipliedAlpha;

    		this.overdraw = source.overdraw;

    		this.visible = source.visible;
    		this.clipShadows = source.clipShadows;

    		var srcPlanes = source.clippingPlanes,
    			dstPlanes = null;

    		if ( srcPlanes !== null ) {

    			var n = srcPlanes.length;
    			dstPlanes = new Array( n );

    			for ( var i = 0; i !== n; ++ i )
    				dstPlanes[ i ] = srcPlanes[ i ].clone();

    		}

    		this.clippingPlanes = dstPlanes;

    		return this;

    	},

    	update: function () {

    		this.dispatchEvent( { type: 'update' } );

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    };

    Object.assign( Material.prototype, EventDispatcher.prototype );

    var count$1 = 0;
    function MaterialIdCount() { return count$1++; };

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  defines: { "label" : "value" },
     *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
     *
     *  fragmentShader: <string>,
     *  vertexShader: <string>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  lights: <bool>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function ShaderMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'ShaderMaterial';

    	this.defines = {};
    	this.uniforms = {};

    	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    	this.linewidth = 1;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false; // set to use scene fog
    	this.lights = false; // set to use scene lights
    	this.clipping = false; // set to use user-defined clipping planes

    	this.skinning = false; // set to use skinning attribute streams
    	this.morphTargets = false; // set to use morph targets
    	this.morphNormals = false; // set to use morph normals

    	this.extensions = {
    		derivatives: false, // set to use derivatives
    		fragDepth: false, // set to use fragment depth values
    		drawBuffers: false, // set to use draw buffers
    		shaderTextureLOD: false // set to use shader texture LOD
    	};

    	// When rendered geometry doesn't include these attributes but the material does,
    	// use these default values in WebGL. This avoids errors when buffer data is missing.
    	this.defaultAttributeValues = {
    		'color': [ 1, 1, 1 ],
    		'uv': [ 0, 0 ],
    		'uv2': [ 0, 0 ]
    	};

    	this.index0AttributeName = undefined;

    	if ( parameters !== undefined ) {

    		if ( parameters.attributes !== undefined ) {

    			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

    		}

    		this.setValues( parameters );

    	}

    }

    ShaderMaterial.prototype = Object.create( Material.prototype );
    ShaderMaterial.prototype.constructor = ShaderMaterial;

    ShaderMaterial.prototype.isShaderMaterial = true;

    ShaderMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.fragmentShader = source.fragmentShader;
    	this.vertexShader = source.vertexShader;

    	this.uniforms = exports.UniformsUtils.clone( source.uniforms );

    	this.defines = source.defines;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	this.lights = source.lights;
    	this.clipping = source.clipping;

    	this.skinning = source.skinning;

    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	this.extensions = source.extensions;

    	return this;

    };

    ShaderMaterial.prototype.toJSON = function ( meta ) {

    	var data = Material.prototype.toJSON.call( this, meta );

    	data.uniforms = this.uniforms;
    	data.vertexShader = this.vertexShader;
    	data.fragmentShader = this.fragmentShader;

    	return data;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / https://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */

    function MeshDepthMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshDepthMaterial';

    	this.depthPacking = BasicDepthPacking;

    	this.skinning = false;
    	this.morphTargets = false;

    	this.map = null;

    	this.alphaMap = null;

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false;
    	this.lights = false;

    	this.setValues( parameters );

    }

    MeshDepthMaterial.prototype = Object.create( Material.prototype );
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

    MeshDepthMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.depthPacking = source.depthPacking;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;

    	this.map = source.map;

    	this.alphaMap = source.alphaMap;

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	return this;

    };

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Box3( min, max ) {

    	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
    	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

    }

    Box3.prototype = {

    	constructor: Box3,

    	isBox3: true,

    	set: function ( min, max ) {

    		this.min.copy( min );
    		this.max.copy( max );

    		return this;

    	},

    	setFromArray: function ( array ) {

    		var minX = + Infinity;
    		var minY = + Infinity;
    		var minZ = + Infinity;

    		var maxX = - Infinity;
    		var maxY = - Infinity;
    		var maxZ = - Infinity;

    		for ( var i = 0, l = array.length; i < l; i += 3 ) {

    			var x = array[ i ];
    			var y = array[ i + 1 ];
    			var z = array[ i + 2 ];

    			if ( x < minX ) minX = x;
    			if ( y < minY ) minY = y;
    			if ( z < minZ ) minZ = z;

    			if ( x > maxX ) maxX = x;
    			if ( y > maxY ) maxY = y;
    			if ( z > maxZ ) maxZ = z;

    		}

    		this.min.set( minX, minY, minZ );
    		this.max.set( maxX, maxY, maxZ );

    	},

    	setFromPoints: function ( points ) {

    		this.makeEmpty();

    		for ( var i = 0, il = points.length; i < il; i ++ ) {

    			this.expandByPoint( points[ i ] );

    		}

    		return this;

    	},

    	setFromCenterAndSize: function () {

    		var v1 = new Vector3();

    		return function setFromCenterAndSize( center, size ) {

    			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

    			this.min.copy( center ).sub( halfSize );
    			this.max.copy( center ).add( halfSize );

    			return this;

    		};

    	}(),

    	setFromObject: function () {

    		// Computes the world-axis-aligned bounding box of an object (including its children),
    		// accounting for both the object's, and children's, world transforms

    		var v1 = new Vector3();

    		return function setFromObject( object ) {

    			var scope = this;

    			object.updateMatrixWorld( true );

    			this.makeEmpty();

    			object.traverse( function ( node ) {

    				var geometry = node.geometry;

    				if ( geometry !== undefined ) {

    					if ( (geometry && geometry.isGeometry) ) {

    						var vertices = geometry.vertices;

    						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    							v1.copy( vertices[ i ] );
    							v1.applyMatrix4( node.matrixWorld );

    							scope.expandByPoint( v1 );

    						}

    					} else if ( (geometry && geometry.isBufferGeometry) ) {

    						var attribute = geometry.attributes.position;

    						if ( attribute !== undefined ) {

    							var array, offset, stride;

    							if ( (attribute && attribute.isInterleavedBufferAttribute) ) {

    								array = attribute.data.array;
    								offset = attribute.offset;
    								stride = attribute.data.stride;

    							} else {

    								array = attribute.array;
    								offset = 0;
    								stride = 3;

    							}

    							for ( var i = offset, il = array.length; i < il; i += stride ) {

    								v1.fromArray( array, i );
    								v1.applyMatrix4( node.matrixWorld );

    								scope.expandByPoint( v1 );

    							}

    						}

    					}

    				}

    			} );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( box ) {

    		this.min.copy( box.min );
    		this.max.copy( box.max );

    		return this;

    	},

    	makeEmpty: function () {

    		this.min.x = this.min.y = this.min.z = + Infinity;
    		this.max.x = this.max.y = this.max.z = - Infinity;

    		return this;

    	},

    	isEmpty: function () {

    		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    	},

    	getSize: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

    	},

    	expandByPoint: function ( point ) {

    		this.min.min( point );
    		this.max.max( point );

    		return this;

    	},

    	expandByVector: function ( vector ) {

    		this.min.sub( vector );
    		this.max.add( vector );

    		return this;

    	},

    	expandByScalar: function ( scalar ) {

    		this.min.addScalar( - scalar );
    		this.max.addScalar( scalar );

    		return this;

    	},

    	containsPoint: function ( point ) {

    		if ( point.x < this.min.x || point.x > this.max.x ||
    				 point.y < this.min.y || point.y > this.max.y ||
    				 point.z < this.min.z || point.z > this.max.z ) {

    			return false;

    		}

    		return true;

    	},

    	containsBox: function ( box ) {

    		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
    			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
    			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

    			return true;

    		}

    		return false;

    	},

    	getParameter: function ( point, optionalTarget ) {

    		// This can potentially have a divide by zero if the box
    		// has a size dimension of 0.

    		var result = optionalTarget || new Vector3();

    		return result.set(
    			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
    			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
    			( point.z - this.min.z ) / ( this.max.z - this.min.z )
    		);

    	},

    	intersectsBox: function ( box ) {

    		// using 6 splitting planes to rule out intersections.

    		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
    				 box.max.y < this.min.y || box.min.y > this.max.y ||
    				 box.max.z < this.min.z || box.min.z > this.max.z ) {

    			return false;

    		}

    		return true;

    	},

    	intersectsSphere: ( function () {

    		var closestPoint;

    		return function intersectsSphere( sphere ) {

    			if ( closestPoint === undefined ) closestPoint = new Vector3();

    			// Find the point on the AABB closest to the sphere center.
    			this.clampPoint( sphere.center, closestPoint );

    			// If that point is inside the sphere, the AABB and sphere intersect.
    			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

    		};

    	} )(),

    	intersectsPlane: function ( plane ) {

    		// We compute the minimum and maximum dot product values. If those values
    		// are on the same side (back or front) of the plane, then there is no intersection.

    		var min, max;

    		if ( plane.normal.x > 0 ) {

    			min = plane.normal.x * this.min.x;
    			max = plane.normal.x * this.max.x;

    		} else {

    			min = plane.normal.x * this.max.x;
    			max = plane.normal.x * this.min.x;

    		}

    		if ( plane.normal.y > 0 ) {

    			min += plane.normal.y * this.min.y;
    			max += plane.normal.y * this.max.y;

    		} else {

    			min += plane.normal.y * this.max.y;
    			max += plane.normal.y * this.min.y;

    		}

    		if ( plane.normal.z > 0 ) {

    			min += plane.normal.z * this.min.z;
    			max += plane.normal.z * this.max.z;

    		} else {

    			min += plane.normal.z * this.max.z;
    			max += plane.normal.z * this.min.z;

    		}

    		return ( min <= plane.constant && max >= plane.constant );

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.copy( point ).clamp( this.min, this.max );

    	},

    	distanceToPoint: function () {

    		var v1 = new Vector3();

    		return function distanceToPoint( point ) {

    			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
    			return clampedPoint.sub( point ).length();

    		};

    	}(),

    	getBoundingSphere: function () {

    		var v1 = new Vector3();

    		return function getBoundingSphere( optionalTarget ) {

    			var result = optionalTarget || new Sphere();

    			this.getCenter( result.center );

    			result.radius = this.size( v1 ).length() * 0.5;

    			return result;

    		};

    	}(),

    	intersect: function ( box ) {

    		this.min.max( box.min );
    		this.max.min( box.max );

    		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
    		if( this.isEmpty() ) this.makeEmpty();

    		return this;

    	},

    	union: function ( box ) {

    		this.min.min( box.min );
    		this.max.max( box.max );

    		return this;

    	},

    	applyMatrix4: function () {

    		var points = [
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3()
    		];

    		return function applyMatrix4( matrix ) {

    			// transform of empty box is an empty box.
    			if( this.isEmpty() ) return this;

    			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
    			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
    			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
    			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
    			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
    			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
    			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
    			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
    			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

    			this.setFromPoints( points );

    			return this;

    		};

    	}(),

    	translate: function ( offset ) {

    		this.min.add( offset );
    		this.max.add( offset );

    		return this;

    	},

    	equals: function ( box ) {

    		return box.min.equals( this.min ) && box.max.equals( this.max );

    	}

    };

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Sphere( center, radius ) {

    	this.center = ( center !== undefined ) ? center : new Vector3();
    	this.radius = ( radius !== undefined ) ? radius : 0;

    }

    Sphere.prototype = {

    	constructor: Sphere,

    	set: function ( center, radius ) {

    		this.center.copy( center );
    		this.radius = radius;

    		return this;

    	},

    	setFromPoints: function () {

    		var box = new Box3();

    		return function setFromPoints( points, optionalCenter ) {

    			var center = this.center;

    			if ( optionalCenter !== undefined ) {

    				center.copy( optionalCenter );

    			} else {

    				box.setFromPoints( points ).getCenter( center );

    			}

    			var maxRadiusSq = 0;

    			for ( var i = 0, il = points.length; i < il; i ++ ) {

    				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

    			}

    			this.radius = Math.sqrt( maxRadiusSq );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( sphere ) {

    		this.center.copy( sphere.center );
    		this.radius = sphere.radius;

    		return this;

    	},

    	empty: function () {

    		return ( this.radius <= 0 );

    	},

    	containsPoint: function ( point ) {

    		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    	},

    	distanceToPoint: function ( point ) {

    		return ( point.distanceTo( this.center ) - this.radius );

    	},

    	intersectsSphere: function ( sphere ) {

    		var radiusSum = this.radius + sphere.radius;

    		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    	},

    	intersectsBox: function ( box ) {

    		return box.intersectsSphere( this );

    	},

    	intersectsPlane: function ( plane ) {

    		// We use the following equation to compute the signed distance from
    		// the center of the sphere to the plane.
    		//
    		// distance = q * n - d
    		//
    		// If this distance is greater than the radius of the sphere,
    		// then there is no intersection.

    		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var deltaLengthSq = this.center.distanceToSquared( point );

    		var result = optionalTarget || new Vector3();

    		result.copy( point );

    		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

    			result.sub( this.center ).normalize();
    			result.multiplyScalar( this.radius ).add( this.center );

    		}

    		return result;

    	},

    	getBoundingBox: function ( optionalTarget ) {

    		var box = optionalTarget || new Box3();

    		box.set( this.center, this.center );
    		box.expandByScalar( this.radius );

    		return box;

    	},

    	applyMatrix4: function ( matrix ) {

    		this.center.applyMatrix4( matrix );
    		this.radius = this.radius * matrix.getMaxScaleOnAxis();

    		return this;

    	},

    	translate: function ( offset ) {

    		this.center.add( offset );

    		return this;

    	},

    	equals: function ( sphere ) {

    		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     * @author tschw
     */

    function Matrix3() {

    	this.elements = new Float32Array( [

    		1, 0, 0,
    		0, 1, 0,
    		0, 0, 1

    	] );

    	if ( arguments.length > 0 ) {

    		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    	}

    }

    Matrix3.prototype = {

    	constructor: Matrix3,

    	isMatrix3: true,

    	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    		var te = this.elements;

    		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
    		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
    		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

    		return this;

    	},

    	identity: function () {

    		this.set(

    			1, 0, 0,
    			0, 1, 0,
    			0, 0, 1

    		);

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().fromArray( this.elements );

    	},

    	copy: function ( m ) {

    		var me = m.elements;

    		this.set(

    			me[ 0 ], me[ 3 ], me[ 6 ],
    			me[ 1 ], me[ 4 ], me[ 7 ],
    			me[ 2 ], me[ 5 ], me[ 8 ]

    		);

    		return this;

    	},

    	setFromMatrix4: function( m ) {

    		var me = m.elements;

    		this.set(

    			me[ 0 ], me[ 4 ], me[  8 ],
    			me[ 1 ], me[ 5 ], me[  9 ],
    			me[ 2 ], me[ 6 ], me[ 10 ]

    		);

    		return this;

    	},

    	applyToVector3Array: function () {

    		var v1;

    		return function applyToVector3Array( array, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = array.length;

    			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

    				v1.fromArray( array, j );
    				v1.applyMatrix3( this );
    				v1.toArray( array, j );

    			}

    			return array;

    		};

    	}(),

    	applyToBuffer: function () {

    		var v1;

    		return function applyToBuffer( buffer, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = buffer.length / buffer.itemSize;

    			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

    				v1.x = buffer.getX( j );
    				v1.y = buffer.getY( j );
    				v1.z = buffer.getZ( j );

    				v1.applyMatrix3( this );

    				buffer.setXYZ( v1.x, v1.y, v1.z );

    			}

    			return buffer;

    		};

    	}(),

    	multiplyScalar: function ( s ) {

    		var te = this.elements;

    		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    		return this;

    	},

    	determinant: function () {

    		var te = this.elements;

    		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
    			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
    			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    	},

    	getInverse: function ( matrix, throwOnDegenerate ) {

    		if ( (matrix && matrix.isMatrix4) ) {

    			console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

    		}

    		var me = matrix.elements,
    			te = this.elements,

    			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
    			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
    			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

    			t11 = n33 * n22 - n32 * n23,
    			t12 = n32 * n13 - n33 * n12,
    			t13 = n23 * n12 - n22 * n13,

    			det = n11 * t11 + n21 * t12 + n31 * t13;

    		if ( det === 0 ) {

    			var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

    			if ( throwOnDegenerate === true ) {

    				throw new Error( msg );

    			} else {

    				console.warn( msg );

    			}

    			return this.identity();
    		}

    		var detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
    		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

    		te[ 3 ] = t12 * detInv;
    		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
    		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

    		te[ 6 ] = t13 * detInv;
    		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
    		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

    		return this;

    	},

    	transpose: function () {

    		var tmp, m = this.elements;

    		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    		return this;

    	},

    	flattenToArrayOffset: function ( array, offset ) {

    		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
    				"- just use .toArray instead." );

    		return this.toArray( array, offset );

    	},

    	getNormalMatrix: function ( matrix4 ) {

    		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

    	},

    	transposeIntoArray: function ( r ) {

    		var m = this.elements;

    		r[ 0 ] = m[ 0 ];
    		r[ 1 ] = m[ 3 ];
    		r[ 2 ] = m[ 6 ];
    		r[ 3 ] = m[ 1 ];
    		r[ 4 ] = m[ 4 ];
    		r[ 5 ] = m[ 7 ];
    		r[ 6 ] = m[ 2 ];
    		r[ 7 ] = m[ 5 ];
    		r[ 8 ] = m[ 8 ];

    		return this;

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		for( var i = 0; i < 9; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		var te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];

    		array[ offset + 3 ] = te[ 3 ];
    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];

    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];
    		array[ offset + 8 ]  = te[ 8 ];

    		return array;

    	}

    };

    /**
     * @author bhouston / http://clara.io
     */

    function Plane( normal, constant ) {

    	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
    	this.constant = ( constant !== undefined ) ? constant : 0;

    }

    Plane.prototype = {

    	constructor: Plane,

    	set: function ( normal, constant ) {

    		this.normal.copy( normal );
    		this.constant = constant;

    		return this;

    	},

    	setComponents: function ( x, y, z, w ) {

    		this.normal.set( x, y, z );
    		this.constant = w;

    		return this;

    	},

    	setFromNormalAndCoplanarPoint: function ( normal, point ) {

    		this.normal.copy( normal );
    		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

    		return this;

    	},

    	setFromCoplanarPoints: function () {

    		var v1 = new Vector3();
    		var v2 = new Vector3();

    		return function setFromCoplanarPoints( a, b, c ) {

    			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

    			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

    			this.setFromNormalAndCoplanarPoint( normal, a );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( plane ) {

    		this.normal.copy( plane.normal );
    		this.constant = plane.constant;

    		return this;

    	},

    	normalize: function () {

    		// Note: will lead to a divide by zero if the plane is invalid.

    		var inverseNormalLength = 1.0 / this.normal.length();
    		this.normal.multiplyScalar( inverseNormalLength );
    		this.constant *= inverseNormalLength;

    		return this;

    	},

    	negate: function () {

    		this.constant *= - 1;
    		this.normal.negate();

    		return this;

    	},

    	distanceToPoint: function ( point ) {

    		return this.normal.dot( point ) + this.constant;

    	},

    	distanceToSphere: function ( sphere ) {

    		return this.distanceToPoint( sphere.center ) - sphere.radius;

    	},

    	projectPoint: function ( point, optionalTarget ) {

    		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

    	},

    	orthoPoint: function ( point, optionalTarget ) {

    		var perpendicularMagnitude = this.distanceToPoint( point );

    		var result = optionalTarget || new Vector3();
    		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

    	},

    	intersectLine: function () {

    		var v1 = new Vector3();

    		return function intersectLine( line, optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			var direction = line.delta( v1 );

    			var denominator = this.normal.dot( direction );

    			if ( denominator === 0 ) {

    				// line is coplanar, return origin
    				if ( this.distanceToPoint( line.start ) === 0 ) {

    					return result.copy( line.start );

    				}

    				// Unsure if this is the correct method to handle this case.
    				return undefined;

    			}

    			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

    			if ( t < 0 || t > 1 ) {

    				return undefined;

    			}

    			return result.copy( direction ).multiplyScalar( t ).add( line.start );

    		};

    	}(),

    	intersectsLine: function ( line ) {

    		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    		var startSign = this.distanceToPoint( line.start );
    		var endSign = this.distanceToPoint( line.end );

    		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    	},

    	intersectsBox: function ( box ) {

    		return box.intersectsPlane( this );

    	},

    	intersectsSphere: function ( sphere ) {

    		return sphere.intersectsPlane( this );

    	},

    	coplanarPoint: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.copy( this.normal ).multiplyScalar( - this.constant );

    	},

    	applyMatrix4: function () {

    		var v1 = new Vector3();
    		var m1 = new Matrix3();

    		return function applyMatrix4( matrix, optionalNormalMatrix ) {

    			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

    			// transform normal based on theory here:
    			// http://www.songho.ca/opengl/gl_normaltransform.html
    			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
    			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

    			// recalculate constant (like in setFromNormalAndCoplanarPoint)
    			this.constant = - referencePoint.dot( normal );

    			return this;

    		};

    	}(),

    	translate: function ( offset ) {

    		this.constant = this.constant - offset.dot( this.normal );

    		return this;

    	},

    	equals: function ( plane ) {

    		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / http://clara.io
     */

    function Frustum( p0, p1, p2, p3, p4, p5 ) {

    	this.planes = [

    		( p0 !== undefined ) ? p0 : new Plane(),
    		( p1 !== undefined ) ? p1 : new Plane(),
    		( p2 !== undefined ) ? p2 : new Plane(),
    		( p3 !== undefined ) ? p3 : new Plane(),
    		( p4 !== undefined ) ? p4 : new Plane(),
    		( p5 !== undefined ) ? p5 : new Plane()

    	];

    }

    Frustum.prototype = {

    	constructor: Frustum,

    	set: function ( p0, p1, p2, p3, p4, p5 ) {

    		var planes = this.planes;

    		planes[ 0 ].copy( p0 );
    		planes[ 1 ].copy( p1 );
    		planes[ 2 ].copy( p2 );
    		planes[ 3 ].copy( p3 );
    		planes[ 4 ].copy( p4 );
    		planes[ 5 ].copy( p5 );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( frustum ) {

    		var planes = this.planes;

    		for ( var i = 0; i < 6; i ++ ) {

    			planes[ i ].copy( frustum.planes[ i ] );

    		}

    		return this;

    	},

    	setFromMatrix: function ( m ) {

    		var planes = this.planes;
    		var me = m.elements;
    		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    		return this;

    	},

    	intersectsObject: function () {

    		var sphere = new Sphere();

    		return function intersectsObject( object ) {

    			var geometry = object.geometry;

    			if ( geometry.boundingSphere === null )
    				geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere )
    				.applyMatrix4( object.matrixWorld );

    			return this.intersectsSphere( sphere );

    		};

    	}(),

    	intersectsSprite: function () {

    		var sphere = new Sphere();

    		return function intersectsSprite( sprite ) {

    			sphere.center.set( 0, 0, 0 );
    			sphere.radius = 0.7071067811865476;
    			sphere.applyMatrix4( sprite.matrixWorld );

    			return this.intersectsSphere( sphere );

    		};

    	}(),

    	intersectsSphere: function ( sphere ) {

    		var planes = this.planes;
    		var center = sphere.center;
    		var negRadius = - sphere.radius;

    		for ( var i = 0; i < 6; i ++ ) {

    			var distance = planes[ i ].distanceToPoint( center );

    			if ( distance < negRadius ) {

    				return false;

    			}

    		}

    		return true;

    	},

    	intersectsBox: function () {

    		var p1 = new Vector3(),
    			p2 = new Vector3();

    		return function intersectsBox( box ) {

    			var planes = this.planes;

    			for ( var i = 0; i < 6 ; i ++ ) {

    				var plane = planes[ i ];

    				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
    				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
    				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
    				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
    				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
    				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

    				var d1 = plane.distanceToPoint( p1 );
    				var d2 = plane.distanceToPoint( p2 );

    				// if both outside plane, no intersection

    				if ( d1 < 0 && d2 < 0 ) {

    					return false;

    				}

    			}

    			return true;

    		};

    	}(),


    	containsPoint: function ( point ) {

    		var planes = this.planes;

    		for ( var i = 0; i < 6; i ++ ) {

    			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

    				return false;

    			}

    		}

    		return true;

    	}

    };

    function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

    	var _gl = _renderer.context,
    	_state = _renderer.state,
    	_frustum = new Frustum(),
    	_projScreenMatrix = new Matrix4(),

    	_lightShadows = _lights.shadows,

    	_shadowMapSize = new Vector2(),
    	_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

    	_lookTarget = new Vector3(),
    	_lightPositionWorld = new Vector3(),

    	_renderList = [],

    	_MorphingFlag = 1,
    	_SkinningFlag = 2,

    	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

    	_depthMaterials = new Array( _NumberOfMaterialVariants ),
    	_distanceMaterials = new Array( _NumberOfMaterialVariants ),

    	_materialCache = {};

    	var cubeDirections = [
    		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
    		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
    	];

    	var cubeUps = [
    		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
    		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
    	];

    	var cube2DViewPorts = [
    		new Vector4(), new Vector4(), new Vector4(),
    		new Vector4(), new Vector4(), new Vector4()
    	];

    	// init

    	var depthMaterialTemplate = new MeshDepthMaterial();
    	depthMaterialTemplate.depthPacking = RGBADepthPacking;
    	depthMaterialTemplate.clipping = true;

    	var distanceShader = ShaderLib[ "distanceRGBA" ];
    	var distanceUniforms = exports.UniformsUtils.clone( distanceShader.uniforms );

    	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

    		var useMorphing = ( i & _MorphingFlag ) !== 0;
    		var useSkinning = ( i & _SkinningFlag ) !== 0;

    		var depthMaterial = depthMaterialTemplate.clone();
    		depthMaterial.morphTargets = useMorphing;
    		depthMaterial.skinning = useSkinning;

    		_depthMaterials[ i ] = depthMaterial;

    		var distanceMaterial = new ShaderMaterial( {
    			defines: {
    				'USE_SHADOWMAP': ''
    			},
    			uniforms: distanceUniforms,
    			vertexShader: distanceShader.vertexShader,
    			fragmentShader: distanceShader.fragmentShader,
    			morphTargets: useMorphing,
    			skinning: useSkinning,
    			clipping: true
    		} );

    		_distanceMaterials[ i ] = distanceMaterial;

    	}

    	//

    	var scope = this;

    	this.enabled = false;

    	this.autoUpdate = true;
    	this.needsUpdate = false;

    	this.type = PCFShadowMap;

    	this.renderReverseSided = true;
    	this.renderSingleSided = true;

    	this.render = function ( scene, camera ) {

    		if ( scope.enabled === false ) return;
    		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

    		if ( _lightShadows.length === 0 ) return;

    		// Set GL state for depth map.
    		_state.clearColor( 1, 1, 1, 1 );
    		_state.disable( _gl.BLEND );
    		_state.setDepthTest( true );
    		_state.setScissorTest( false );

    		// render depth map

    		var faceCount, isPointLight;

    		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

    			var light = _lightShadows[ i ];
    			var shadow = light.shadow;

    			if ( shadow === undefined ) {

    				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
    				continue;

    			}

    			var shadowCamera = shadow.camera;

    			_shadowMapSize.copy( shadow.mapSize );
    			_shadowMapSize.min( _maxShadowMapSize );

    			if ( (light && light.isPointLight) ) {

    				faceCount = 6;
    				isPointLight = true;

    				var vpWidth = _shadowMapSize.x;
    				var vpHeight = _shadowMapSize.y;

    				// These viewports map a cube-map onto a 2D texture with the
    				// following orientation:
    				//
    				//  xzXZ
    				//   y Y
    				//
    				// X - Positive x direction
    				// x - Negative x direction
    				// Y - Positive y direction
    				// y - Negative y direction
    				// Z - Positive z direction
    				// z - Negative z direction

    				// positive X
    				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
    				// negative X
    				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
    				// positive Z
    				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
    				// negative Z
    				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
    				// positive Y
    				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
    				// negative Y
    				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

    				_shadowMapSize.x *= 4.0;
    				_shadowMapSize.y *= 2.0;

    			} else {

    				faceCount = 1;
    				isPointLight = false;

    			}

    			if ( shadow.map === null ) {

    				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

    				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

    				shadowCamera.updateProjectionMatrix();

    			}

    			if ( (shadow && shadow.isSpotLightShadow) ) {

    				shadow.update( light );

    			}

    			var shadowMap = shadow.map;
    			var shadowMatrix = shadow.matrix;

    			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
    			shadowCamera.position.copy( _lightPositionWorld );

    			_renderer.setRenderTarget( shadowMap );
    			_renderer.clear();

    			// render shadow map for each cube face (if omni-directional) or
    			// run a single pass if not

    			for ( var face = 0; face < faceCount; face ++ ) {

    				if ( isPointLight ) {

    					_lookTarget.copy( shadowCamera.position );
    					_lookTarget.add( cubeDirections[ face ] );
    					shadowCamera.up.copy( cubeUps[ face ] );
    					shadowCamera.lookAt( _lookTarget );

    					var vpDimensions = cube2DViewPorts[ face ];
    					_state.viewport( vpDimensions );

    				} else {

    					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
    					shadowCamera.lookAt( _lookTarget );

    				}

    				shadowCamera.updateMatrixWorld();
    				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

    				// compute shadow matrix

    				shadowMatrix.set(
    					0.5, 0.0, 0.0, 0.5,
    					0.0, 0.5, 0.0, 0.5,
    					0.0, 0.0, 0.5, 0.5,
    					0.0, 0.0, 0.0, 1.0
    				);

    				shadowMatrix.multiply( shadowCamera.projectionMatrix );
    				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

    				// update camera matrices and frustum

    				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
    				_frustum.setFromMatrix( _projScreenMatrix );

    				// set object matrices & frustum culling

    				_renderList.length = 0;

    				projectObject( scene, camera, shadowCamera );

    				// render shadow map
    				// render regular objects

    				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

    					var object = _renderList[ j ];
    					var geometry = _objects.update( object );
    					var material = object.material;

    					if ( (material && material.isMultiMaterial) ) {

    						var groups = geometry.groups;
    						var materials = material.materials;

    						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

    							var group = groups[ k ];
    							var groupMaterial = materials[ group.materialIndex ];

    							if ( groupMaterial.visible === true ) {

    								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
    								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

    							}

    						}

    					} else {

    						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
    						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

    					}

    				}

    			}

    		}

    		// Restore GL state.
    		var clearColor = _renderer.getClearColor(),
    		clearAlpha = _renderer.getClearAlpha();
    		_renderer.setClearColor( clearColor, clearAlpha );

    		scope.needsUpdate = false;

    	};

    	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

    		var geometry = object.geometry;

    		var result = null;

    		var materialVariants = _depthMaterials;
    		var customMaterial = object.customDepthMaterial;

    		if ( isPointLight ) {

    			materialVariants = _distanceMaterials;
    			customMaterial = object.customDistanceMaterial;

    		}

    		if ( ! customMaterial ) {

    			var useMorphing = false;

    			if ( material.morphTargets ) {

    				if ( (geometry && geometry.isBufferGeometry) ) {

    					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

    				} else if ( (geometry && geometry.isGeometry) ) {

    					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

    				}

    			}

    			var useSkinning = object.isSkinnedMesh && material.skinning;

    			var variantIndex = 0;

    			if ( useMorphing ) variantIndex |= _MorphingFlag;
    			if ( useSkinning ) variantIndex |= _SkinningFlag;

    			result = materialVariants[ variantIndex ];

    		} else {

    			result = customMaterial;

    		}

    		if ( _renderer.localClippingEnabled &&
    			 material.clipShadows === true &&
    				material.clippingPlanes.length !== 0 ) {

    			// in this case we need a unique material instance reflecting the
    			// appropriate state

    			var keyA = result.uuid, keyB = material.uuid;

    			var materialsForVariant = _materialCache[ keyA ];

    			if ( materialsForVariant === undefined ) {

    				materialsForVariant = {};
    				_materialCache[ keyA ] = materialsForVariant;

    			}

    			var cachedMaterial = materialsForVariant[ keyB ];

    			if ( cachedMaterial === undefined ) {

    				cachedMaterial = result.clone();
    				materialsForVariant[ keyB ] = cachedMaterial;

    			}

    			result = cachedMaterial;

    		}

    		result.visible = material.visible;
    		result.wireframe = material.wireframe;

    		var side = material.side;

    		if ( scope.renderSingleSided && side == DoubleSide ) {

    			side = FrontSide;

    		}

    		if ( scope.renderReverseSided ) {

    			if ( side === FrontSide ) side = BackSide;
    			else if ( side === BackSide ) side = FrontSide;

    		}

    		result.side = side;

    		result.clipShadows = material.clipShadows;
    		result.clippingPlanes = material.clippingPlanes;

    		result.wireframeLinewidth = material.wireframeLinewidth;
    		result.linewidth = material.linewidth;

    		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

    			result.uniforms.lightPos.value.copy( lightPositionWorld );

    		}

    		return result;

    	}

    	function projectObject( object, camera, shadowCamera ) {

    		if ( object.visible === false ) return;

    		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

    		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

    			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

    				var material = object.material;

    				if ( material.visible === true ) {

    					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
    					_renderList.push( object );

    				}

    			}

    		}

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			projectObject( children[ i ], camera, shadowCamera );

    		}

    	}

    }

    /**
     * @author bhouston / http://clara.io
     */

    function Ray( origin, direction ) {

    	this.origin = ( origin !== undefined ) ? origin : new Vector3();
    	this.direction = ( direction !== undefined ) ? direction : new Vector3();

    }

    Ray.prototype = {

    	constructor: Ray,

    	set: function ( origin, direction ) {

    		this.origin.copy( origin );
    		this.direction.copy( direction );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( ray ) {

    		this.origin.copy( ray.origin );
    		this.direction.copy( ray.direction );

    		return this;

    	},

    	at: function ( t, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    	},

    	lookAt: function ( v ) {

    		this.direction.copy( v ).sub( this.origin ).normalize();

    		return this;

    	},

    	recast: function () {

    		var v1 = new Vector3();

    		return function recast( t ) {

    			this.origin.copy( this.at( t, v1 ) );

    			return this;

    		};

    	}(),

    	closestPointToPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		result.subVectors( point, this.origin );
    		var directionDistance = result.dot( this.direction );

    		if ( directionDistance < 0 ) {

    			return result.copy( this.origin );

    		}

    		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    	},

    	distanceToPoint: function ( point ) {

    		return Math.sqrt( this.distanceSqToPoint( point ) );

    	},

    	distanceSqToPoint: function () {

    		var v1 = new Vector3();

    		return function distanceSqToPoint( point ) {

    			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

    			// point behind the ray

    			if ( directionDistance < 0 ) {

    				return this.origin.distanceToSquared( point );

    			}

    			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    			return v1.distanceToSquared( point );

    		};

    	}(),

    	distanceSqToSegment: function () {

    		var segCenter = new Vector3();
    		var segDir = new Vector3();
    		var diff = new Vector3();

    		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

    			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
    			// It returns the min distance between the ray and the segment
    			// defined by v0 and v1
    			// It can also set two optional targets :
    			// - The closest point on the ray
    			// - The closest point on the segment

    			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
    			segDir.copy( v1 ).sub( v0 ).normalize();
    			diff.copy( this.origin ).sub( segCenter );

    			var segExtent = v0.distanceTo( v1 ) * 0.5;
    			var a01 = - this.direction.dot( segDir );
    			var b0 = diff.dot( this.direction );
    			var b1 = - diff.dot( segDir );
    			var c = diff.lengthSq();
    			var det = Math.abs( 1 - a01 * a01 );
    			var s0, s1, sqrDist, extDet;

    			if ( det > 0 ) {

    				// The ray and segment are not parallel.

    				s0 = a01 * b1 - b0;
    				s1 = a01 * b0 - b1;
    				extDet = segExtent * det;

    				if ( s0 >= 0 ) {

    					if ( s1 >= - extDet ) {

    						if ( s1 <= extDet ) {

    							// region 0
    							// Minimum at interior points of ray and segment.

    							var invDet = 1 / det;
    							s0 *= invDet;
    							s1 *= invDet;
    							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

    						} else {

    							// region 1

    							s1 = segExtent;
    							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    						}

    					} else {

    						// region 5

    						s1 = - segExtent;
    						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					}

    				} else {

    					if ( s1 <= - extDet ) {

    						// region 4

    						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
    						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					} else if ( s1 <= extDet ) {

    						// region 3

    						s0 = 0;
    						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

    					} else {

    						// region 2

    						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
    						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					}

    				}

    			} else {

    				// Ray and segment are parallel.

    				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
    				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    			}

    			if ( optionalPointOnRay ) {

    				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

    			}

    			if ( optionalPointOnSegment ) {

    				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

    			}

    			return sqrDist;

    		};

    	}(),

    	intersectSphere: function () {

    		var v1 = new Vector3();

    		return function intersectSphere( sphere, optionalTarget ) {

    			v1.subVectors( sphere.center, this.origin );
    			var tca = v1.dot( this.direction );
    			var d2 = v1.dot( v1 ) - tca * tca;
    			var radius2 = sphere.radius * sphere.radius;

    			if ( d2 > radius2 ) return null;

    			var thc = Math.sqrt( radius2 - d2 );

    			// t0 = first intersect point - entrance on front of sphere
    			var t0 = tca - thc;

    			// t1 = second intersect point - exit point on back of sphere
    			var t1 = tca + thc;

    			// test to see if both t0 and t1 are behind the ray - if so, return null
    			if ( t0 < 0 && t1 < 0 ) return null;

    			// test to see if t0 is behind the ray:
    			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    			// in order to always return an intersect point that is in front of the ray.
    			if ( t0 < 0 ) return this.at( t1, optionalTarget );

    			// else t0 is in front of the ray, so return the first collision point scaled by t0
    			return this.at( t0, optionalTarget );

    		};

    	}(),

    	intersectsSphere: function ( sphere ) {

    		return this.distanceToPoint( sphere.center ) <= sphere.radius;

    	},

    	distanceToPlane: function ( plane ) {

    		var denominator = plane.normal.dot( this.direction );

    		if ( denominator === 0 ) {

    			// line is coplanar, return origin
    			if ( plane.distanceToPoint( this.origin ) === 0 ) {

    				return 0;

    			}

    			// Null is preferable to undefined since undefined means.... it is undefined

    			return null;

    		}

    		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    		// Return if the ray never intersects the plane

    		return t >= 0 ? t :  null;

    	},

    	intersectPlane: function ( plane, optionalTarget ) {

    		var t = this.distanceToPlane( plane );

    		if ( t === null ) {

    			return null;

    		}

    		return this.at( t, optionalTarget );

    	},



    	intersectsPlane: function ( plane ) {

    		// check if the ray lies on the plane first

    		var distToPoint = plane.distanceToPoint( this.origin );

    		if ( distToPoint === 0 ) {

    			return true;

    		}

    		var denominator = plane.normal.dot( this.direction );

    		if ( denominator * distToPoint < 0 ) {

    			return true;

    		}

    		// ray origin is behind the plane (and is pointing behind it)

    		return false;

    	},

    	intersectBox: function ( box, optionalTarget ) {

    		var tmin, tmax, tymin, tymax, tzmin, tzmax;

    		var invdirx = 1 / this.direction.x,
    			invdiry = 1 / this.direction.y,
    			invdirz = 1 / this.direction.z;

    		var origin = this.origin;

    		if ( invdirx >= 0 ) {

    			tmin = ( box.min.x - origin.x ) * invdirx;
    			tmax = ( box.max.x - origin.x ) * invdirx;

    		} else {

    			tmin = ( box.max.x - origin.x ) * invdirx;
    			tmax = ( box.min.x - origin.x ) * invdirx;

    		}

    		if ( invdiry >= 0 ) {

    			tymin = ( box.min.y - origin.y ) * invdiry;
    			tymax = ( box.max.y - origin.y ) * invdiry;

    		} else {

    			tymin = ( box.max.y - origin.y ) * invdiry;
    			tymax = ( box.min.y - origin.y ) * invdiry;

    		}

    		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    		// These lines also handle the case where tmin or tmax is NaN
    		// (result of 0 * Infinity). x !== x returns true if x is NaN

    		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    		if ( invdirz >= 0 ) {

    			tzmin = ( box.min.z - origin.z ) * invdirz;
    			tzmax = ( box.max.z - origin.z ) * invdirz;

    		} else {

    			tzmin = ( box.max.z - origin.z ) * invdirz;
    			tzmax = ( box.min.z - origin.z ) * invdirz;

    		}

    		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    		//return point closest to the ray (positive side)

    		if ( tmax < 0 ) return null;

    		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    	},

    	intersectsBox: ( function () {

    		var v = new Vector3();

    		return function intersectsBox( box ) {

    			return this.intersectBox( box, v ) !== null;

    		};

    	} )(),

    	intersectTriangle: function () {

    		// Compute the offset origin, edges, and normal.
    		var diff = new Vector3();
    		var edge1 = new Vector3();
    		var edge2 = new Vector3();
    		var normal = new Vector3();

    		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

    			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

    			edge1.subVectors( b, a );
    			edge2.subVectors( c, a );
    			normal.crossVectors( edge1, edge2 );

    			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
    			var DdN = this.direction.dot( normal );
    			var sign;

    			if ( DdN > 0 ) {

    				if ( backfaceCulling ) return null;
    				sign = 1;

    			} else if ( DdN < 0 ) {

    				sign = - 1;
    				DdN = - DdN;

    			} else {

    				return null;

    			}

    			diff.subVectors( this.origin, a );
    			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

    			// b1 < 0, no intersection
    			if ( DdQxE2 < 0 ) {

    				return null;

    			}

    			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

    			// b2 < 0, no intersection
    			if ( DdE1xQ < 0 ) {

    				return null;

    			}

    			// b1+b2 > 1, no intersection
    			if ( DdQxE2 + DdE1xQ > DdN ) {

    				return null;

    			}

    			// Line intersects triangle, check if ray does.
    			var QdN = - sign * diff.dot( normal );

    			// t < 0, no intersection
    			if ( QdN < 0 ) {

    				return null;

    			}

    			// Ray intersects triangle.
    			return this.at( QdN / DdN, optionalTarget );

    		};

    	}(),

    	applyMatrix4: function ( matrix4 ) {

    		this.direction.add( this.origin ).applyMatrix4( matrix4 );
    		this.origin.applyMatrix4( matrix4 );
    		this.direction.sub( this.origin );
    		this.direction.normalize();

    		return this;

    	},

    	equals: function ( ray ) {

    		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Euler( x, y, z, order ) {

    	this._x = x || 0;
    	this._y = y || 0;
    	this._z = z || 0;
    	this._order = order || Euler.DefaultOrder;

    }

    Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

    Euler.DefaultOrder = 'XYZ';

    Euler.prototype = {

    	constructor: Euler,

    	isEuler: true,

    	get x () {

    		return this._x;

    	},

    	set x ( value ) {

    		this._x = value;
    		this.onChangeCallback();

    	},

    	get y () {

    		return this._y;

    	},

    	set y ( value ) {

    		this._y = value;
    		this.onChangeCallback();

    	},

    	get z () {

    		return this._z;

    	},

    	set z ( value ) {

    		this._z = value;
    		this.onChangeCallback();

    	},

    	get order () {

    		return this._order;

    	},

    	set order ( value ) {

    		this._order = value;
    		this.onChangeCallback();

    	},

    	set: function ( x, y, z, order ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._order = order || this._order;

    		this.onChangeCallback();

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this._x, this._y, this._z, this._order );

    	},

    	copy: function ( euler ) {

    		this._x = euler._x;
    		this._y = euler._y;
    		this._z = euler._z;
    		this._order = euler._order;

    		this.onChangeCallback();

    		return this;

    	},

    	setFromRotationMatrix: function ( m, order, update ) {

    		var clamp = exports.Math.clamp;

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var te = m.elements;
    		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		order = order || this._order;

    		if ( order === 'XYZ' ) {

    			this._y = Math.asin( clamp( m13, - 1, 1 ) );

    			if ( Math.abs( m13 ) < 0.99999 ) {

    				this._x = Math.atan2( - m23, m33 );
    				this._z = Math.atan2( - m12, m11 );

    			} else {

    				this._x = Math.atan2( m32, m22 );
    				this._z = 0;

    			}

    		} else if ( order === 'YXZ' ) {

    			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

    			if ( Math.abs( m23 ) < 0.99999 ) {

    				this._y = Math.atan2( m13, m33 );
    				this._z = Math.atan2( m21, m22 );

    			} else {

    				this._y = Math.atan2( - m31, m11 );
    				this._z = 0;

    			}

    		} else if ( order === 'ZXY' ) {

    			this._x = Math.asin( clamp( m32, - 1, 1 ) );

    			if ( Math.abs( m32 ) < 0.99999 ) {

    				this._y = Math.atan2( - m31, m33 );
    				this._z = Math.atan2( - m12, m22 );

    			} else {

    				this._y = 0;
    				this._z = Math.atan2( m21, m11 );

    			}

    		} else if ( order === 'ZYX' ) {

    			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

    			if ( Math.abs( m31 ) < 0.99999 ) {

    				this._x = Math.atan2( m32, m33 );
    				this._z = Math.atan2( m21, m11 );

    			} else {

    				this._x = 0;
    				this._z = Math.atan2( - m12, m22 );

    			}

    		} else if ( order === 'YZX' ) {

    			this._z = Math.asin( clamp( m21, - 1, 1 ) );

    			if ( Math.abs( m21 ) < 0.99999 ) {

    				this._x = Math.atan2( - m23, m22 );
    				this._y = Math.atan2( - m31, m11 );

    			} else {

    				this._x = 0;
    				this._y = Math.atan2( m13, m33 );

    			}

    		} else if ( order === 'XZY' ) {

    			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

    			if ( Math.abs( m12 ) < 0.99999 ) {

    				this._x = Math.atan2( m32, m22 );
    				this._y = Math.atan2( m13, m11 );

    			} else {

    				this._x = Math.atan2( - m23, m33 );
    				this._y = 0;

    			}

    		} else {

    			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

    		}

    		this._order = order;

    		if ( update !== false ) this.onChangeCallback();

    		return this;

    	},

    	setFromQuaternion: function () {

    		var matrix;

    		return function setFromQuaternion( q, order, update ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.makeRotationFromQuaternion( q );

    			return this.setFromRotationMatrix( matrix, order, update );

    		};

    	}(),

    	setFromVector3: function ( v, order ) {

    		return this.set( v.x, v.y, v.z, order || this._order );

    	},

    	reorder: function () {

    		// WARNING: this discards revolution information -bhouston

    		var q = new Quaternion();

    		return function reorder( newOrder ) {

    			q.setFromEuler( this );

    			return this.setFromQuaternion( q, newOrder );

    		};

    	}(),

    	equals: function ( euler ) {

    		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    	},

    	fromArray: function ( array ) {

    		this._x = array[ 0 ];
    		this._y = array[ 1 ];
    		this._z = array[ 2 ];
    		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    		this.onChangeCallback();

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._order;

    		return array;

    	},

    	toVector3: function ( optionalResult ) {

    		if ( optionalResult ) {

    			return optionalResult.set( this._x, this._y, this._z );

    		} else {

    			return new Vector3( this._x, this._y, this._z );

    		}

    	},

    	onChange: function ( callback ) {

    		this.onChangeCallback = callback;

    		return this;

    	},

    	onChangeCallback: function () {}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Layers() {

    	this.mask = 1;

    }

    Layers.prototype = {

    	constructor: Layers,

    	set: function ( channel ) {

    		this.mask = 1 << channel;

    	},

    	enable: function ( channel ) {

    		this.mask |= 1 << channel;

    	},

    	toggle: function ( channel ) {

    		this.mask ^= 1 << channel;

    	},

    	disable: function ( channel ) {

    		this.mask &= ~ ( 1 << channel );

    	},

    	test: function ( layers ) {

    		return ( this.mask & layers.mask ) !== 0;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author elephantatwork / www.elephantatwork.ch
     */

    function Object3D() {

    	Object.defineProperty( this, 'id', { value: Object3DIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Object3D';

    	this.parent = null;
    	this.children = [];

    	this.up = Object3D.DefaultUp.clone();

    	var position = new Vector3();
    	var rotation = new Euler();
    	var quaternion = new Quaternion();
    	var scale = new Vector3( 1, 1, 1 );

    	function onRotationChange() {

    		quaternion.setFromEuler( rotation, false );

    	}

    	function onQuaternionChange() {

    		rotation.setFromQuaternion( quaternion, undefined, false );

    	}

    	rotation.onChange( onRotationChange );
    	quaternion.onChange( onQuaternionChange );

    	Object.defineProperties( this, {
    		position: {
    			enumerable: true,
    			value: position
    		},
    		rotation: {
    			enumerable: true,
    			value: rotation
    		},
    		quaternion: {
    			enumerable: true,
    			value: quaternion
    		},
    		scale: {
    			enumerable: true,
    			value: scale
    		},
    		modelViewMatrix: {
    			value: new Matrix4()
    		},
    		normalMatrix: {
    			value: new Matrix3()
    		}
    	} );

    	this.matrix = new Matrix4();
    	this.matrixWorld = new Matrix4();

    	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    	this.matrixWorldNeedsUpdate = false;

    	this.layers = new Layers();
    	this.visible = true;

    	this.castShadow = false;
    	this.receiveShadow = false;

    	this.frustumCulled = true;
    	this.renderOrder = 0;

    	this.userData = {};

    	this.onBeforeRender = null;

    }

    Object3D.DefaultUp = new Vector3( 0, 1, 0 );
    Object3D.DefaultMatrixAutoUpdate = true;

    Object.assign( Object3D.prototype, EventDispatcher.prototype, {

    	isObject3D: true,

    	applyMatrix: function ( matrix ) {

    		this.matrix.multiplyMatrices( matrix, this.matrix );

    		this.matrix.decompose( this.position, this.quaternion, this.scale );

    	},

    	setRotationFromAxisAngle: function ( axis, angle ) {

    		// assumes axis is normalized

    		this.quaternion.setFromAxisAngle( axis, angle );

    	},

    	setRotationFromEuler: function ( euler ) {

    		this.quaternion.setFromEuler( euler, true );

    	},

    	setRotationFromMatrix: function ( m ) {

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		this.quaternion.setFromRotationMatrix( m );

    	},

    	setRotationFromQuaternion: function ( q ) {

    		// assumes q is normalized

    		this.quaternion.copy( q );

    	},

    	rotateOnAxis: function () {

    		// rotate object on axis in object space
    		// axis is assumed to be normalized

    		var q1 = new Quaternion();

    		return function rotateOnAxis( axis, angle ) {

    			q1.setFromAxisAngle( axis, angle );

    			this.quaternion.multiply( q1 );

    			return this;

    		};

    	}(),

    	rotateX: function () {

    		var v1 = new Vector3( 1, 0, 0 );

    		return function rotateX( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	rotateY: function () {

    		var v1 = new Vector3( 0, 1, 0 );

    		return function rotateY( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	rotateZ: function () {

    		var v1 = new Vector3( 0, 0, 1 );

    		return function rotateZ( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	translateOnAxis: function () {

    		// translate object by distance along axis in object space
    		// axis is assumed to be normalized

    		var v1 = new Vector3();

    		return function translateOnAxis( axis, distance ) {

    			v1.copy( axis ).applyQuaternion( this.quaternion );

    			this.position.add( v1.multiplyScalar( distance ) );

    			return this;

    		};

    	}(),

    	translateX: function () {

    		var v1 = new Vector3( 1, 0, 0 );

    		return function translateX( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	translateY: function () {

    		var v1 = new Vector3( 0, 1, 0 );

    		return function translateY( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	translateZ: function () {

    		var v1 = new Vector3( 0, 0, 1 );

    		return function translateZ( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	localToWorld: function ( vector ) {

    		return vector.applyMatrix4( this.matrixWorld );

    	},

    	worldToLocal: function () {

    		var m1 = new Matrix4();

    		return function worldToLocal( vector ) {

    			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

    		};

    	}(),

    	lookAt: function () {

    		// This routine does not support objects with rotated and/or translated parent(s)

    		var m1 = new Matrix4();

    		return function lookAt( vector ) {

    			m1.lookAt( vector, this.position, this.up );

    			this.quaternion.setFromRotationMatrix( m1 );

    		};

    	}(),

    	add: function ( object ) {

    		if ( arguments.length > 1 ) {

    			for ( var i = 0; i < arguments.length; i ++ ) {

    				this.add( arguments[ i ] );

    			}

    			return this;

    		}

    		if ( object === this ) {

    			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
    			return this;

    		}

    		if ( (object && object.isObject3D) ) {

    			if ( object.parent !== null ) {

    				object.parent.remove( object );

    			}

    			object.parent = this;
    			object.dispatchEvent( { type: 'added' } );

    			this.children.push( object );

    		} else {

    			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

    		}

    		return this;

    	},

    	remove: function ( object ) {

    		if ( arguments.length > 1 ) {

    			for ( var i = 0; i < arguments.length; i ++ ) {

    				this.remove( arguments[ i ] );

    			}

    		}

    		var index = this.children.indexOf( object );

    		if ( index !== - 1 ) {

    			object.parent = null;

    			object.dispatchEvent( { type: 'removed' } );

    			this.children.splice( index, 1 );

    		}

    	},

    	getObjectById: function ( id ) {

    		return this.getObjectByProperty( 'id', id );

    	},

    	getObjectByName: function ( name ) {

    		return this.getObjectByProperty( 'name', name );

    	},

    	getObjectByProperty: function ( name, value ) {

    		if ( this[ name ] === value ) return this;

    		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

    			var child = this.children[ i ];
    			var object = child.getObjectByProperty( name, value );

    			if ( object !== undefined ) {

    				return object;

    			}

    		}

    		return undefined;

    	},

    	getWorldPosition: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		this.updateMatrixWorld( true );

    		return result.setFromMatrixPosition( this.matrixWorld );

    	},

    	getWorldQuaternion: function () {

    		var position = new Vector3();
    		var scale = new Vector3();

    		return function getWorldQuaternion( optionalTarget ) {

    			var result = optionalTarget || new Quaternion();

    			this.updateMatrixWorld( true );

    			this.matrixWorld.decompose( position, result, scale );

    			return result;

    		};

    	}(),

    	getWorldRotation: function () {

    		var quaternion = new Quaternion();

    		return function getWorldRotation( optionalTarget ) {

    			var result = optionalTarget || new Euler();

    			this.getWorldQuaternion( quaternion );

    			return result.setFromQuaternion( quaternion, this.rotation.order, false );

    		};

    	}(),

    	getWorldScale: function () {

    		var position = new Vector3();
    		var quaternion = new Quaternion();

    		return function getWorldScale( optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			this.updateMatrixWorld( true );

    			this.matrixWorld.decompose( position, quaternion, result );

    			return result;

    		};

    	}(),

    	getWorldDirection: function () {

    		var quaternion = new Quaternion();

    		return function getWorldDirection( optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			this.getWorldQuaternion( quaternion );

    			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

    		};

    	}(),

    	raycast: function () {},

    	traverse: function ( callback ) {

    		callback( this );

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverse( callback );

    		}

    	},

    	traverseVisible: function ( callback ) {

    		if ( this.visible === false ) return;

    		callback( this );

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverseVisible( callback );

    		}

    	},

    	traverseAncestors: function ( callback ) {

    		var parent = this.parent;

    		if ( parent !== null ) {

    			callback( parent );

    			parent.traverseAncestors( callback );

    		}

    	},

    	updateMatrix: function () {

    		this.matrix.compose( this.position, this.quaternion, this.scale );

    		this.matrixWorldNeedsUpdate = true;

    	},

    	updateMatrixWorld: function ( force ) {

    		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

    		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

    			if ( this.parent === null ) {

    				this.matrixWorld.copy( this.matrix );

    			} else {

    				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

    			}

    			this.matrixWorldNeedsUpdate = false;

    			force = true;

    		}

    		// update children

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].updateMatrixWorld( force );

    		}

    	},

    	toJSON: function ( meta ) {

    		// meta is '' when called from JSON.stringify
    		var isRootObject = ( meta === undefined || meta === '' );

    		var output = {};

    		// meta is a hash used to collect geometries, materials.
    		// not providing it implies that this is the root object
    		// being serialized.
    		if ( isRootObject ) {

    			// initialize meta obj
    			meta = {
    				geometries: {},
    				materials: {},
    				textures: {},
    				images: {}
    			};

    			output.metadata = {
    				version: 4.4,
    				type: 'Object',
    				generator: 'Object3D.toJSON'
    			};

    		}

    		// standard Object3D serialization

    		var object = {};

    		object.uuid = this.uuid;
    		object.type = this.type;

    		if ( this.name !== '' ) object.name = this.name;
    		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
    		if ( this.castShadow === true ) object.castShadow = true;
    		if ( this.receiveShadow === true ) object.receiveShadow = true;
    		if ( this.visible === false ) object.visible = false;

    		object.matrix = this.matrix.toArray();

    		//

    		if ( this.geometry !== undefined ) {

    			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

    				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

    			}

    			object.geometry = this.geometry.uuid;

    		}

    		if ( this.material !== undefined ) {

    			if ( meta.materials[ this.material.uuid ] === undefined ) {

    				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

    			}

    			object.material = this.material.uuid;

    		}

    		//

    		if ( this.children.length > 0 ) {

    			object.children = [];

    			for ( var i = 0; i < this.children.length; i ++ ) {

    				object.children.push( this.children[ i ].toJSON( meta ).object );

    			}

    		}

    		if ( isRootObject ) {

    			var geometries = extractFromCache( meta.geometries );
    			var materials = extractFromCache( meta.materials );
    			var textures = extractFromCache( meta.textures );
    			var images = extractFromCache( meta.images );

    			if ( geometries.length > 0 ) output.geometries = geometries;
    			if ( materials.length > 0 ) output.materials = materials;
    			if ( textures.length > 0 ) output.textures = textures;
    			if ( images.length > 0 ) output.images = images;

    		}

    		output.object = object;

    		return output;

    		// extract data from the cache hash
    		// remove metadata on each item
    		// and return as array
    		function extractFromCache( cache ) {

    			var values = [];
    			for ( var key in cache ) {

    				var data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}
    			return values;

    		}

    	},

    	clone: function ( recursive ) {

    		return new this.constructor().copy( this, recursive );

    	},

    	copy: function ( source, recursive ) {

    		if ( recursive === undefined ) recursive = true;

    		this.name = source.name;

    		this.up.copy( source.up );

    		this.position.copy( source.position );
    		this.quaternion.copy( source.quaternion );
    		this.scale.copy( source.scale );

    		this.matrix.copy( source.matrix );
    		this.matrixWorld.copy( source.matrixWorld );

    		this.matrixAutoUpdate = source.matrixAutoUpdate;
    		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

    		this.visible = source.visible;

    		this.castShadow = source.castShadow;
    		this.receiveShadow = source.receiveShadow;

    		this.frustumCulled = source.frustumCulled;
    		this.renderOrder = source.renderOrder;

    		this.userData = JSON.parse( JSON.stringify( source.userData ) );

    		if ( recursive === true ) {

    			for ( var i = 0; i < source.children.length; i ++ ) {

    				var child = source.children[ i ];
    				this.add( child.clone() );

    			}

    		}

    		return this;

    	}

    } );

    var count$2 = 0;
    function Object3DIdCount() { return count$2++; };

    /**
     * @author bhouston / http://clara.io
     */

    function Line3( start, end ) {

    	this.start = ( start !== undefined ) ? start : new Vector3();
    	this.end = ( end !== undefined ) ? end : new Vector3();

    }

    Line3.prototype = {

    	constructor: Line3,

    	set: function ( start, end ) {

    		this.start.copy( start );
    		this.end.copy( end );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( line ) {

    		this.start.copy( line.start );
    		this.end.copy( line.end );

    		return this;

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    	},

    	delta: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.subVectors( this.end, this.start );

    	},

    	distanceSq: function () {

    		return this.start.distanceToSquared( this.end );

    	},

    	distance: function () {

    		return this.start.distanceTo( this.end );

    	},

    	at: function ( t, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		return this.delta( result ).multiplyScalar( t ).add( this.start );

    	},

    	closestPointToPointParameter: function () {

    		var startP = new Vector3();
    		var startEnd = new Vector3();

    		return function closestPointToPointParameter( point, clampToLine ) {

    			startP.subVectors( point, this.start );
    			startEnd.subVectors( this.end, this.start );

    			var startEnd2 = startEnd.dot( startEnd );
    			var startEnd_startP = startEnd.dot( startP );

    			var t = startEnd_startP / startEnd2;

    			if ( clampToLine ) {

    				t = exports.Math.clamp( t, 0, 1 );

    			}

    			return t;

    		};

    	}(),

    	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

    		var t = this.closestPointToPointParameter( point, clampToLine );

    		var result = optionalTarget || new Vector3();

    		return this.delta( result ).multiplyScalar( t ).add( this.start );

    	},

    	applyMatrix4: function ( matrix ) {

    		this.start.applyMatrix4( matrix );
    		this.end.applyMatrix4( matrix );

    		return this;

    	},

    	equals: function ( line ) {

    		return line.start.equals( this.start ) && line.end.equals( this.end );

    	}

    };

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Triangle( a, b, c ) {

    	this.a = ( a !== undefined ) ? a : new Vector3();
    	this.b = ( b !== undefined ) ? b : new Vector3();
    	this.c = ( c !== undefined ) ? c : new Vector3();

    }

    Triangle.normal = function () {

    	var v0 = new Vector3();

    	return function normal( a, b, c, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		result.subVectors( c, b );
    		v0.subVectors( a, b );
    		result.cross( v0 );

    		var resultLengthSq = result.lengthSq();
    		if ( resultLengthSq > 0 ) {

    			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

    		}

    		return result.set( 0, 0, 0 );

    	};

    }();

    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    Triangle.barycoordFromPoint = function () {

    	var v0 = new Vector3();
    	var v1 = new Vector3();
    	var v2 = new Vector3();

    	return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

    		v0.subVectors( c, a );
    		v1.subVectors( b, a );
    		v2.subVectors( point, a );

    		var dot00 = v0.dot( v0 );
    		var dot01 = v0.dot( v1 );
    		var dot02 = v0.dot( v2 );
    		var dot11 = v1.dot( v1 );
    		var dot12 = v1.dot( v2 );

    		var denom = ( dot00 * dot11 - dot01 * dot01 );

    		var result = optionalTarget || new Vector3();

    		// collinear or singular triangle
    		if ( denom === 0 ) {

    			// arbitrary location outside of triangle?
    			// not sure if this is the best idea, maybe should be returning undefined
    			return result.set( - 2, - 1, - 1 );

    		}

    		var invDenom = 1 / denom;
    		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    		// barycentric coordinates must always sum to 1
    		return result.set( 1 - u - v, v, u );

    	};

    }();

    Triangle.containsPoint = function () {

    	var v1 = new Vector3();

    	return function containsPoint( point, a, b, c ) {

    		var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

    		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

    	};

    }();

    Triangle.prototype = {

    	constructor: Triangle,

    	set: function ( a, b, c ) {

    		this.a.copy( a );
    		this.b.copy( b );
    		this.c.copy( c );

    		return this;

    	},

    	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

    		this.a.copy( points[ i0 ] );
    		this.b.copy( points[ i1 ] );
    		this.c.copy( points[ i2 ] );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( triangle ) {

    		this.a.copy( triangle.a );
    		this.b.copy( triangle.b );
    		this.c.copy( triangle.c );

    		return this;

    	},

    	area: function () {

    		var v0 = new Vector3();
    		var v1 = new Vector3();

    		return function area() {

    			v0.subVectors( this.c, this.b );
    			v1.subVectors( this.a, this.b );

    			return v0.cross( v1 ).length() * 0.5;

    		};

    	}(),

    	midpoint: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    	},

    	normal: function ( optionalTarget ) {

    		return Triangle.normal( this.a, this.b, this.c, optionalTarget );

    	},

    	plane: function ( optionalTarget ) {

    		var result = optionalTarget || new Plane();

    		return result.setFromCoplanarPoints( this.a, this.b, this.c );

    	},

    	barycoordFromPoint: function ( point, optionalTarget ) {

    		return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    	},

    	containsPoint: function ( point ) {

    		return Triangle.containsPoint( point, this.a, this.b, this.c );

    	},

    	closestPointToPoint: function () {

    		var plane, edgeList, projectedPoint, closestPoint;

    		return function closestPointToPoint( point, optionalTarget ) {

    			if ( plane === undefined ) {

    				plane = new Plane();
    				edgeList = [ new Line3(), new Line3(), new Line3() ];
    				projectedPoint = new Vector3();
    				closestPoint = new Vector3();

    			}

    			var result = optionalTarget || new Vector3();
    			var minDistance = Infinity;

    			// project the point onto the plane of the triangle

    			plane.setFromCoplanarPoints( this.a, this.b, this.c );
    			plane.projectPoint( point, projectedPoint );

    			// check if the projection lies within the triangle

    			if( this.containsPoint( projectedPoint ) === true ) {

    				// if so, this is the closest point

    				result.copy( projectedPoint );

    			} else {

    				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

    				edgeList[ 0 ].set( this.a, this.b );
    				edgeList[ 1 ].set( this.b, this.c );
    				edgeList[ 2 ].set( this.c, this.a );

    				for( var i = 0; i < edgeList.length; i ++ ) {

    					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

    					var distance = projectedPoint.distanceToSquared( closestPoint );

    					if( distance < minDistance ) {

    						minDistance = distance;

    						result.copy( closestPoint );

    					}

    				}

    			}

    			return result;

    		};

    	}(),

    	equals: function ( triangle ) {

    		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Face3( a, b, c, normal, color, materialIndex ) {

    	this.a = a;
    	this.b = b;
    	this.c = c;

    	this.normal = (normal && normal.isVector3) ? normal : new Vector3();
    	this.vertexNormals = Array.isArray( normal ) ? normal : [];

    	this.color = (color && color.isColor) ? color : new Color();
    	this.vertexColors = Array.isArray( color ) ? color : [];

    	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

    }

    Face3.prototype = {

    	constructor: Face3,

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.a = source.a;
    		this.b = source.b;
    		this.c = source.c;

    		this.normal.copy( source.normal );
    		this.color.copy( source.color );

    		this.materialIndex = source.materialIndex;

    		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

    			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

    		}

    		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

    			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

    		}

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  shading: THREE.SmoothShading,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>
     * }
     */

    function MeshBasicMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshBasicMaterial';

    	this.color = new Color( 0xffffff ); // emissive

    	this.map = null;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;

    	this.lights = false;

    	this.setValues( parameters );

    }

    MeshBasicMaterial.prototype = Object.create( Material.prototype );
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

    MeshBasicMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferAttribute( array, itemSize, normalized ) {

    	if ( Array.isArray( array ) ) {

    		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

    	}

    	this.uuid = exports.Math.generateUUID();

    	this.array = array;
    	this.itemSize = itemSize;
    	this.count = array !== undefined ? array.length / itemSize : 0;
    	this.normalized = normalized === true;

    	this.dynamic = false;
    	this.updateRange = { offset: 0, count: - 1 };

    	this.version = 0;

    }

    BufferAttribute.prototype = {

    	constructor: BufferAttribute,

    	isBufferAttribute: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	setDynamic: function ( value ) {

    		this.dynamic = value;

    		return this;

    	},

    	copy: function ( source ) {

    		this.array = new source.array.constructor( source.array );
    		this.itemSize = source.itemSize;
    		this.count = source.count;
    		this.normalized = source.normalized;

    		this.dynamic = source.dynamic;

    		return this;

    	},

    	copyAt: function ( index1, attribute, index2 ) {

    		index1 *= this.itemSize;
    		index2 *= attribute.itemSize;

    		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	},

    	copyArray: function ( array ) {

    		this.array.set( array );

    		return this;

    	},

    	copyColorsArray: function ( colors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = colors.length; i < l; i ++ ) {

    			var color = colors[ i ];

    			if ( color === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
    				color = new Color();

    			}

    			array[ offset ++ ] = color.r;
    			array[ offset ++ ] = color.g;
    			array[ offset ++ ] = color.b;

    		}

    		return this;

    	},

    	copyIndicesArray: function ( indices ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = indices.length; i < l; i ++ ) {

    			var index = indices[ i ];

    			array[ offset ++ ] = index.a;
    			array[ offset ++ ] = index.b;
    			array[ offset ++ ] = index.c;

    		}

    		return this;

    	},

    	copyVector2sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
    				vector = new Vector2();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;

    		}

    		return this;

    	},

    	copyVector3sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
    				vector = new Vector3();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;
    			array[ offset ++ ] = vector.z;

    		}

    		return this;

    	},

    	copyVector4sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
    				vector = new Vector4();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;
    			array[ offset ++ ] = vector.z;
    			array[ offset ++ ] = vector.w;

    		}

    		return this;

    	},

    	set: function ( value, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.array.set( value, offset );

    		return this;

    	},

    	getX: function ( index ) {

    		return this.array[ index * this.itemSize ];

    	},

    	setX: function ( index, x ) {

    		this.array[ index * this.itemSize ] = x;

    		return this;

    	},

    	getY: function ( index ) {

    		return this.array[ index * this.itemSize + 1 ];

    	},

    	setY: function ( index, y ) {

    		this.array[ index * this.itemSize + 1 ] = y;

    		return this;

    	},

    	getZ: function ( index ) {

    		return this.array[ index * this.itemSize + 2 ];

    	},

    	setZ: function ( index, z ) {

    		this.array[ index * this.itemSize + 2 ] = z;

    		return this;

    	},

    	getW: function ( index ) {

    		return this.array[ index * this.itemSize + 3 ];

    	},

    	setW: function ( index, w ) {

    		this.array[ index * this.itemSize + 3 ] = w;

    		return this;

    	},

    	setXY: function ( index, x, y ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;

    		return this;

    	},

    	setXYZ: function ( index, x, y, z ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;

    		return this;

    	},

    	setXYZW: function ( index, x, y, z, w ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;
    		this.array[ index + 3 ] = w;

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	}

    };

    //

    function Int8Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int8Array( array ), itemSize );

    }

    function Uint8Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint8Array( array ), itemSize );

    }

    function Uint8ClampedAttribute( array, itemSize ) {

    	return new BufferAttribute( new Uint8ClampedArray( array ), itemSize );

    }

    function Int16Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int16Array( array ), itemSize );

    }

    function Uint16Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint16Array( array ), itemSize );

    }

    function Int32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int32Array( array ), itemSize );

    }

    function Uint32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint32Array( array ), itemSize );

    }

    function Float32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Float32Array( array ), itemSize );

    }

    function Float64Attribute( array, itemSize ) {

    	return new BufferAttribute( new Float64Array( array ), itemSize );

    }

    // Deprecated

    function DynamicBufferAttribute( array, itemSize ) {

    	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    	return new BufferAttribute( array, itemSize ).setDynamic( true );

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author kile / http://kile.stravaganza.org/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author bhouston / http://clara.io
     */

    function Geometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Geometry';

    	this.vertices = [];
    	this.colors = [];
    	this.faces = [];
    	this.faceVertexUvs = [ [] ];

    	this.morphTargets = [];
    	this.morphNormals = [];

    	this.skinWeights = [];
    	this.skinIndices = [];

    	this.lineDistances = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	// update flags

    	this.elementsNeedUpdate = false;
    	this.verticesNeedUpdate = false;
    	this.uvsNeedUpdate = false;
    	this.normalsNeedUpdate = false;
    	this.colorsNeedUpdate = false;
    	this.lineDistancesNeedUpdate = false;
    	this.groupsNeedUpdate = false;

    }

    Object.assign( Geometry.prototype, EventDispatcher.prototype, {

    	isGeometry: true,

    	applyMatrix: function ( matrix ) {

    		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

    		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

    			var vertex = this.vertices[ i ];
    			vertex.applyMatrix4( matrix );

    		}

    		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

    			var face = this.faces[ i ];
    			face.normal.applyMatrix3( normalMatrix ).normalize();

    			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

    				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

    			}

    		}

    		if ( this.boundingBox !== null ) {

    			this.computeBoundingBox();

    		}

    		if ( this.boundingSphere !== null ) {

    			this.computeBoundingSphere();

    		}

    		this.verticesNeedUpdate = true;
    		this.normalsNeedUpdate = true;

    		return this;

    	},

    	rotateX: function () {

    		// rotate geometry around world x-axis

    		var m1;

    		return function rotateX( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationX( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateY: function () {

    		// rotate geometry around world y-axis

    		var m1;

    		return function rotateY( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationY( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateZ: function () {

    		// rotate geometry around world z-axis

    		var m1;

    		return function rotateZ( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationZ( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	translate: function () {

    		// translate geometry

    		var m1;

    		return function translate( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeTranslation( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	scale: function () {

    		// scale geometry

    		var m1;

    		return function scale( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeScale( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	lookAt: function () {

    		var obj;

    		return function lookAt( vector ) {

    			if ( obj === undefined ) obj = new Object3D();

    			obj.lookAt( vector );

    			obj.updateMatrix();

    			this.applyMatrix( obj.matrix );

    		};

    	}(),

    	fromBufferGeometry: function ( geometry ) {

    		var scope = this;

    		var indices = geometry.index !== null ? geometry.index.array : undefined;
    		var attributes = geometry.attributes;

    		var positions = attributes.position.array;
    		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

    		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

    		var tempNormals = [];
    		var tempUVs = [];
    		var tempUVs2 = [];

    		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

    			scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

    			if ( normals !== undefined ) {

    				tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

    			}

    			if ( colors !== undefined ) {

    				scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

    			}

    			if ( uvs !== undefined ) {

    				tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

    			}

    			if ( uvs2 !== undefined ) {

    				tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

    			}

    		}

    		function addFace( a, b, c, materialIndex ) {

    			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
    			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

    			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

    			scope.faces.push( face );

    			if ( uvs !== undefined ) {

    				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

    			}

    			if ( uvs2 !== undefined ) {

    				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

    			}

    		}

    		if ( indices !== undefined ) {

    			var groups = geometry.groups;

    			if ( groups.length > 0 ) {

    				for ( var i = 0; i < groups.length; i ++ ) {

    					var group = groups[ i ];

    					var start = group.start;
    					var count = group.count;

    					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

    						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );

    					}

    				}

    			} else {

    				for ( var i = 0; i < indices.length; i += 3 ) {

    					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

    				}

    			}

    		} else {

    			for ( var i = 0; i < positions.length / 3; i += 3 ) {

    				addFace( i, i + 1, i + 2 );

    			}

    		}

    		this.computeFaceNormals();

    		if ( geometry.boundingBox !== null ) {

    			this.boundingBox = geometry.boundingBox.clone();

    		}

    		if ( geometry.boundingSphere !== null ) {

    			this.boundingSphere = geometry.boundingSphere.clone();

    		}

    		return this;

    	},

    	center: function () {

    		this.computeBoundingBox();

    		var offset = this.boundingBox.getCenter().negate();

    		this.translate( offset.x, offset.y, offset.z );

    		return offset;

    	},

    	normalize: function () {

    		this.computeBoundingSphere();

    		var center = this.boundingSphere.center;
    		var radius = this.boundingSphere.radius;

    		var s = radius === 0 ? 1 : 1.0 / radius;

    		var matrix = new Matrix4();
    		matrix.set(
    			s, 0, 0, - s * center.x,
    			0, s, 0, - s * center.y,
    			0, 0, s, - s * center.z,
    			0, 0, 0, 1
    		);

    		this.applyMatrix( matrix );

    		return this;

    	},

    	computeFaceNormals: function () {

    		var cb = new Vector3(), ab = new Vector3();

    		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			var face = this.faces[ f ];

    			var vA = this.vertices[ face.a ];
    			var vB = this.vertices[ face.b ];
    			var vC = this.vertices[ face.c ];

    			cb.subVectors( vC, vB );
    			ab.subVectors( vA, vB );
    			cb.cross( ab );

    			cb.normalize();

    			face.normal.copy( cb );

    		}

    	},

    	computeVertexNormals: function ( areaWeighted ) {

    		if ( areaWeighted === undefined ) areaWeighted = true;

    		var v, vl, f, fl, face, vertices;

    		vertices = new Array( this.vertices.length );

    		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

    			vertices[ v ] = new Vector3();

    		}

    		if ( areaWeighted ) {

    			// vertex normals weighted by triangle areas
    			// http://www.iquilezles.org/www/articles/normals/normals.htm

    			var vA, vB, vC;
    			var cb = new Vector3(), ab = new Vector3();

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				vA = this.vertices[ face.a ];
    				vB = this.vertices[ face.b ];
    				vC = this.vertices[ face.c ];

    				cb.subVectors( vC, vB );
    				ab.subVectors( vA, vB );
    				cb.cross( ab );

    				vertices[ face.a ].add( cb );
    				vertices[ face.b ].add( cb );
    				vertices[ face.c ].add( cb );

    			}

    		} else {

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				vertices[ face.a ].add( face.normal );
    				vertices[ face.b ].add( face.normal );
    				vertices[ face.c ].add( face.normal );

    			}

    		}

    		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

    			vertices[ v ].normalize();

    		}

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			var vertexNormals = face.vertexNormals;

    			if ( vertexNormals.length === 3 ) {

    				vertexNormals[ 0 ].copy( vertices[ face.a ] );
    				vertexNormals[ 1 ].copy( vertices[ face.b ] );
    				vertexNormals[ 2 ].copy( vertices[ face.c ] );

    			} else {

    				vertexNormals[ 0 ] = vertices[ face.a ].clone();
    				vertexNormals[ 1 ] = vertices[ face.b ].clone();
    				vertexNormals[ 2 ] = vertices[ face.c ].clone();

    			}

    		}

    		if ( this.faces.length > 0 ) {

    			this.normalsNeedUpdate = true;

    		}

    	},

    	computeMorphNormals: function () {

    		var i, il, f, fl, face;

    		// save original normals
    		// - create temp variables on first access
    		//   otherwise just copy (for faster repeated calls)

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			if ( ! face.__originalFaceNormal ) {

    				face.__originalFaceNormal = face.normal.clone();

    			} else {

    				face.__originalFaceNormal.copy( face.normal );

    			}

    			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

    			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

    				if ( ! face.__originalVertexNormals[ i ] ) {

    					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

    				} else {

    					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

    				}

    			}

    		}

    		// use temp geometry to compute face and vertex normals for each morph

    		var tmpGeo = new Geometry();
    		tmpGeo.faces = this.faces;

    		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

    			// create on first access

    			if ( ! this.morphNormals[ i ] ) {

    				this.morphNormals[ i ] = {};
    				this.morphNormals[ i ].faceNormals = [];
    				this.morphNormals[ i ].vertexNormals = [];

    				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
    				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

    				var faceNormal, vertexNormals;

    				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    					faceNormal = new Vector3();
    					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

    					dstNormalsFace.push( faceNormal );
    					dstNormalsVertex.push( vertexNormals );

    				}

    			}

    			var morphNormals = this.morphNormals[ i ];

    			// set vertices to morph target

    			tmpGeo.vertices = this.morphTargets[ i ].vertices;

    			// compute morph normals

    			tmpGeo.computeFaceNormals();
    			tmpGeo.computeVertexNormals();

    			// store morph normals

    			var faceNormal, vertexNormals;

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				faceNormal = morphNormals.faceNormals[ f ];
    				vertexNormals = morphNormals.vertexNormals[ f ];

    				faceNormal.copy( face.normal );

    				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
    				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
    				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

    			}

    		}

    		// restore original normals

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			face.normal = face.__originalFaceNormal;
    			face.vertexNormals = face.__originalVertexNormals;

    		}

    	},

    	computeTangents: function () {

    		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

    	},

    	computeLineDistances: function () {

    		var d = 0;
    		var vertices = this.vertices;

    		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    			if ( i > 0 ) {

    				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

    			}

    			this.lineDistances[ i ] = d;

    		}

    	},

    	computeBoundingBox: function () {

    		if ( this.boundingBox === null ) {

    			this.boundingBox = new Box3();

    		}

    		this.boundingBox.setFromPoints( this.vertices );

    	},

    	computeBoundingSphere: function () {

    		if ( this.boundingSphere === null ) {

    			this.boundingSphere = new Sphere();

    		}

    		this.boundingSphere.setFromPoints( this.vertices );

    	},

    	merge: function ( geometry, matrix, materialIndexOffset ) {

    		if ( (geometry && geometry.isGeometry) === false ) {

    			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
    			return;

    		}

    		var normalMatrix,
    		vertexOffset = this.vertices.length,
    		vertices1 = this.vertices,
    		vertices2 = geometry.vertices,
    		faces1 = this.faces,
    		faces2 = geometry.faces,
    		uvs1 = this.faceVertexUvs[ 0 ],
    		uvs2 = geometry.faceVertexUvs[ 0 ],
    		colors1 = this.colors,
    		colors2 = geometry.colors;

    		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

    		if ( matrix !== undefined ) {

    			normalMatrix = new Matrix3().getNormalMatrix( matrix );

    		}

    		// vertices

    		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

    			var vertex = vertices2[ i ];

    			var vertexCopy = vertex.clone();

    			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

    			vertices1.push( vertexCopy );

    		}

    		// colors

    		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

    			colors1.push( colors2[ i ].clone() );

    		}

    		// faces

    		for ( i = 0, il = faces2.length; i < il; i ++ ) {

    			var face = faces2[ i ], faceCopy, normal, color,
    			faceVertexNormals = face.vertexNormals,
    			faceVertexColors = face.vertexColors;

    			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
    			faceCopy.normal.copy( face.normal );

    			if ( normalMatrix !== undefined ) {

    				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

    			}

    			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

    				normal = faceVertexNormals[ j ].clone();

    				if ( normalMatrix !== undefined ) {

    					normal.applyMatrix3( normalMatrix ).normalize();

    				}

    				faceCopy.vertexNormals.push( normal );

    			}

    			faceCopy.color.copy( face.color );

    			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

    				color = faceVertexColors[ j ];
    				faceCopy.vertexColors.push( color.clone() );

    			}

    			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

    			faces1.push( faceCopy );

    		}

    		// uvs

    		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

    			var uv = uvs2[ i ], uvCopy = [];

    			if ( uv === undefined ) {

    				continue;

    			}

    			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

    				uvCopy.push( uv[ j ].clone() );

    			}

    			uvs1.push( uvCopy );

    		}

    	},

    	mergeMesh: function ( mesh ) {

    		if ( (mesh && mesh.isMesh) === false ) {

    			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
    			return;

    		}

    		mesh.matrixAutoUpdate && mesh.updateMatrix();

    		this.merge( mesh.geometry, mesh.matrix );

    	},

    	/*
    	 * Checks for duplicate vertices with hashmap.
    	 * Duplicated vertices are removed
    	 * and faces' vertices are updated.
    	 */

    	mergeVertices: function () {

    		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
    		var unique = [], changes = [];

    		var v, key;
    		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
    		var precision = Math.pow( 10, precisionPoints );
    		var i, il, face;
    		var indices, j, jl;

    		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

    			v = this.vertices[ i ];
    			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

    			if ( verticesMap[ key ] === undefined ) {

    				verticesMap[ key ] = i;
    				unique.push( this.vertices[ i ] );
    				changes[ i ] = unique.length - 1;

    			} else {

    				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
    				changes[ i ] = changes[ verticesMap[ key ] ];

    			}

    		}


    		// if faces are completely degenerate after merging vertices, we
    		// have to remove them from the geometry.
    		var faceIndicesToRemove = [];

    		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

    			face = this.faces[ i ];

    			face.a = changes[ face.a ];
    			face.b = changes[ face.b ];
    			face.c = changes[ face.c ];

    			indices = [ face.a, face.b, face.c ];

    			var dupIndex = - 1;

    			// if any duplicate vertices are found in a Face3
    			// we have to remove the face as nothing can be saved
    			for ( var n = 0; n < 3; n ++ ) {

    				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

    					dupIndex = n;
    					faceIndicesToRemove.push( i );
    					break;

    				}

    			}

    		}

    		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

    			var idx = faceIndicesToRemove[ i ];

    			this.faces.splice( idx, 1 );

    			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

    				this.faceVertexUvs[ j ].splice( idx, 1 );

    			}

    		}

    		// Use unique set of vertices

    		var diff = this.vertices.length - unique.length;
    		this.vertices = unique;
    		return diff;

    	},

    	sortFacesByMaterialIndex: function () {

    		var faces = this.faces;
    		var length = faces.length;

    		// tag faces

    		for ( var i = 0; i < length; i ++ ) {

    			faces[ i ]._id = i;

    		}

    		// sort faces

    		function materialIndexSort( a, b ) {

    			return a.materialIndex - b.materialIndex;

    		}

    		faces.sort( materialIndexSort );

    		// sort uvs

    		var uvs1 = this.faceVertexUvs[ 0 ];
    		var uvs2 = this.faceVertexUvs[ 1 ];

    		var newUvs1, newUvs2;

    		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
    		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

    		for ( var i = 0; i < length; i ++ ) {

    			var id = faces[ i ]._id;

    			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
    			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

    		}

    		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
    		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

    	},

    	toJSON: function () {

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'Geometry',
    				generator: 'Geometry.toJSON'
    			}
    		};

    		// standard Geometry serialization

    		data.uuid = this.uuid;
    		data.type = this.type;
    		if ( this.name !== '' ) data.name = this.name;

    		if ( this.parameters !== undefined ) {

    			var parameters = this.parameters;

    			for ( var key in parameters ) {

    				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

    			}

    			return data;

    		}

    		var vertices = [];

    		for ( var i = 0; i < this.vertices.length; i ++ ) {

    			var vertex = this.vertices[ i ];
    			vertices.push( vertex.x, vertex.y, vertex.z );

    		}

    		var faces = [];
    		var normals = [];
    		var normalsHash = {};
    		var colors = [];
    		var colorsHash = {};
    		var uvs = [];
    		var uvsHash = {};

    		for ( var i = 0; i < this.faces.length; i ++ ) {

    			var face = this.faces[ i ];

    			var hasMaterial = true;
    			var hasFaceUv = false; // deprecated
    			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
    			var hasFaceNormal = face.normal.length() > 0;
    			var hasFaceVertexNormal = face.vertexNormals.length > 0;
    			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
    			var hasFaceVertexColor = face.vertexColors.length > 0;

    			var faceType = 0;

    			faceType = setBit( faceType, 0, 0 ); // isQuad
    			faceType = setBit( faceType, 1, hasMaterial );
    			faceType = setBit( faceType, 2, hasFaceUv );
    			faceType = setBit( faceType, 3, hasFaceVertexUv );
    			faceType = setBit( faceType, 4, hasFaceNormal );
    			faceType = setBit( faceType, 5, hasFaceVertexNormal );
    			faceType = setBit( faceType, 6, hasFaceColor );
    			faceType = setBit( faceType, 7, hasFaceVertexColor );

    			faces.push( faceType );
    			faces.push( face.a, face.b, face.c );
    			faces.push( face.materialIndex );

    			if ( hasFaceVertexUv ) {

    				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

    				faces.push(
    					getUvIndex( faceVertexUvs[ 0 ] ),
    					getUvIndex( faceVertexUvs[ 1 ] ),
    					getUvIndex( faceVertexUvs[ 2 ] )
    				);

    			}

    			if ( hasFaceNormal ) {

    				faces.push( getNormalIndex( face.normal ) );

    			}

    			if ( hasFaceVertexNormal ) {

    				var vertexNormals = face.vertexNormals;

    				faces.push(
    					getNormalIndex( vertexNormals[ 0 ] ),
    					getNormalIndex( vertexNormals[ 1 ] ),
    					getNormalIndex( vertexNormals[ 2 ] )
    				);

    			}

    			if ( hasFaceColor ) {

    				faces.push( getColorIndex( face.color ) );

    			}

    			if ( hasFaceVertexColor ) {

    				var vertexColors = face.vertexColors;

    				faces.push(
    					getColorIndex( vertexColors[ 0 ] ),
    					getColorIndex( vertexColors[ 1 ] ),
    					getColorIndex( vertexColors[ 2 ] )
    				);

    			}

    		}

    		function setBit( value, position, enabled ) {

    			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

    		}

    		function getNormalIndex( normal ) {

    			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

    			if ( normalsHash[ hash ] !== undefined ) {

    				return normalsHash[ hash ];

    			}

    			normalsHash[ hash ] = normals.length / 3;
    			normals.push( normal.x, normal.y, normal.z );

    			return normalsHash[ hash ];

    		}

    		function getColorIndex( color ) {

    			var hash = color.r.toString() + color.g.toString() + color.b.toString();

    			if ( colorsHash[ hash ] !== undefined ) {

    				return colorsHash[ hash ];

    			}

    			colorsHash[ hash ] = colors.length;
    			colors.push( color.getHex() );

    			return colorsHash[ hash ];

    		}

    		function getUvIndex( uv ) {

    			var hash = uv.x.toString() + uv.y.toString();

    			if ( uvsHash[ hash ] !== undefined ) {

    				return uvsHash[ hash ];

    			}

    			uvsHash[ hash ] = uvs.length / 2;
    			uvs.push( uv.x, uv.y );

    			return uvsHash[ hash ];

    		}

    		data.data = {};

    		data.data.vertices = vertices;
    		data.data.normals = normals;
    		if ( colors.length > 0 ) data.data.colors = colors;
    		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
    		data.data.faces = faces;

    		return data;

    	},

    	clone: function () {

    		/*
    		// Handle primitives

    		var parameters = this.parameters;

    		if ( parameters !== undefined ) {

    			var values = [];

    			for ( var key in parameters ) {

    				values.push( parameters[ key ] );

    			}

    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;

    		}

    		return new this.constructor().copy( this );
    		*/

    		return new Geometry().copy( this );

    	},

    	copy: function ( source ) {

    		this.vertices = [];
    		this.faces = [];
    		this.faceVertexUvs = [ [] ];
    		this.colors = [];

    		var vertices = source.vertices;

    		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    			this.vertices.push( vertices[ i ].clone() );

    		}

    		var colors = source.colors;

    		for ( var i = 0, il = colors.length; i < il; i ++ ) {

    			this.colors.push( colors[ i ].clone() );

    		}

    		var faces = source.faces;

    		for ( var i = 0, il = faces.length; i < il; i ++ ) {

    			this.faces.push( faces[ i ].clone() );

    		}

    		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

    			var faceVertexUvs = source.faceVertexUvs[ i ];

    			if ( this.faceVertexUvs[ i ] === undefined ) {

    				this.faceVertexUvs[ i ] = [];

    			}

    			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

    				var uvs = faceVertexUvs[ j ], uvsCopy = [];

    				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

    					var uv = uvs[ k ];

    					uvsCopy.push( uv.clone() );

    				}

    				this.faceVertexUvs[ i ].push( uvsCopy );

    			}

    		}

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    var count$3 = 0;
    function GeometryIdCount() { return count$3++; };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectGeometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'DirectGeometry';

    	this.indices = [];
    	this.vertices = [];
    	this.normals = [];
    	this.colors = [];
    	this.uvs = [];
    	this.uvs2 = [];

    	this.groups = [];

    	this.morphTargets = {};

    	this.skinWeights = [];
    	this.skinIndices = [];

    	// this.lineDistances = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	// update flags

    	this.verticesNeedUpdate = false;
    	this.normalsNeedUpdate = false;
    	this.colorsNeedUpdate = false;
    	this.uvsNeedUpdate = false;
    	this.groupsNeedUpdate = false;

    }

    Object.assign( DirectGeometry.prototype, EventDispatcher.prototype, {

    	computeBoundingBox: Geometry.prototype.computeBoundingBox,
    	computeBoundingSphere: Geometry.prototype.computeBoundingSphere,

    	computeFaceNormals: function () {

    		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

    	},

    	computeVertexNormals: function () {

    		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

    	},

    	computeGroups: function ( geometry ) {

    		var group;
    		var groups = [];
    		var materialIndex;

    		var faces = geometry.faces;

    		for ( var i = 0; i < faces.length; i ++ ) {

    			var face = faces[ i ];

    			// materials

    			if ( face.materialIndex !== materialIndex ) {

    				materialIndex = face.materialIndex;

    				if ( group !== undefined ) {

    					group.count = ( i * 3 ) - group.start;
    					groups.push( group );

    				}

    				group = {
    					start: i * 3,
    					materialIndex: materialIndex
    				};

    			}

    		}

    		if ( group !== undefined ) {

    			group.count = ( i * 3 ) - group.start;
    			groups.push( group );

    		}

    		this.groups = groups;

    	},

    	fromGeometry: function ( geometry ) {

    		var faces = geometry.faces;
    		var vertices = geometry.vertices;
    		var faceVertexUvs = geometry.faceVertexUvs;

    		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
    		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

    		// morphs

    		var morphTargets = geometry.morphTargets;
    		var morphTargetsLength = morphTargets.length;

    		var morphTargetsPosition;

    		if ( morphTargetsLength > 0 ) {

    			morphTargetsPosition = [];

    			for ( var i = 0; i < morphTargetsLength; i ++ ) {

    				morphTargetsPosition[ i ] = [];

    			}

    			this.morphTargets.position = morphTargetsPosition;

    		}

    		var morphNormals = geometry.morphNormals;
    		var morphNormalsLength = morphNormals.length;

    		var morphTargetsNormal;

    		if ( morphNormalsLength > 0 ) {

    			morphTargetsNormal = [];

    			for ( var i = 0; i < morphNormalsLength; i ++ ) {

    				morphTargetsNormal[ i ] = [];

    			}

    			this.morphTargets.normal = morphTargetsNormal;

    		}

    		// skins

    		var skinIndices = geometry.skinIndices;
    		var skinWeights = geometry.skinWeights;

    		var hasSkinIndices = skinIndices.length === vertices.length;
    		var hasSkinWeights = skinWeights.length === vertices.length;

    		//

    		for ( var i = 0; i < faces.length; i ++ ) {

    			var face = faces[ i ];

    			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

    			var vertexNormals = face.vertexNormals;

    			if ( vertexNormals.length === 3 ) {

    				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

    			} else {

    				var normal = face.normal;

    				this.normals.push( normal, normal, normal );

    			}

    			var vertexColors = face.vertexColors;

    			if ( vertexColors.length === 3 ) {

    				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

    			} else {

    				var color = face.color;

    				this.colors.push( color, color, color );

    			}

    			if ( hasFaceVertexUv === true ) {

    				var vertexUvs = faceVertexUvs[ 0 ][ i ];

    				if ( vertexUvs !== undefined ) {

    					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

    				} else {

    					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

    					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

    				}

    			}

    			if ( hasFaceVertexUv2 === true ) {

    				var vertexUvs = faceVertexUvs[ 1 ][ i ];

    				if ( vertexUvs !== undefined ) {

    					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

    				} else {

    					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

    					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

    				}

    			}

    			// morphs

    			for ( var j = 0; j < morphTargetsLength; j ++ ) {

    				var morphTarget = morphTargets[ j ].vertices;

    				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

    			}

    			for ( var j = 0; j < morphNormalsLength; j ++ ) {

    				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

    				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

    			}

    			// skins

    			if ( hasSkinIndices ) {

    				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

    			}

    			if ( hasSkinWeights ) {

    				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

    			}

    		}

    		this.computeGroups( geometry );

    		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'BufferGeometry';

    	this.index = null;
    	this.attributes = {};

    	this.morphAttributes = {};

    	this.groups = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	this.drawRange = { start: 0, count: Infinity };

    }

    Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

    	isBufferGeometry: true,

    	getIndex: function () {

    		return this.index;

    	},

    	setIndex: function ( index ) {

    		this.index = index;

    	},

    	addAttribute: function ( name, attribute ) {

    		if ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {

    			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

    			this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

    			return;

    		}

    		if ( name === 'index' ) {

    			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
    			this.setIndex( attribute );

    			return;

    		}

    		this.attributes[ name ] = attribute;

    		return this;

    	},

    	getAttribute: function ( name ) {

    		return this.attributes[ name ];

    	},

    	removeAttribute: function ( name ) {

    		delete this.attributes[ name ];

    		return this;

    	},

    	addGroup: function ( start, count, materialIndex ) {

    		this.groups.push( {

    			start: start,
    			count: count,
    			materialIndex: materialIndex !== undefined ? materialIndex : 0

    		} );

    	},

    	clearGroups: function () {

    		this.groups = [];

    	},

    	setDrawRange: function ( start, count ) {

    		this.drawRange.start = start;
    		this.drawRange.count = count;

    	},

    	applyMatrix: function ( matrix ) {

    		var position = this.attributes.position;

    		if ( position !== undefined ) {

    			matrix.applyToVector3Array( position.array );
    			position.needsUpdate = true;

    		}

    		var normal = this.attributes.normal;

    		if ( normal !== undefined ) {

    			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

    			normalMatrix.applyToVector3Array( normal.array );
    			normal.needsUpdate = true;

    		}

    		if ( this.boundingBox !== null ) {

    			this.computeBoundingBox();

    		}

    		if ( this.boundingSphere !== null ) {

    			this.computeBoundingSphere();

    		}

    		return this;

    	},

    	rotateX: function () {

    		// rotate geometry around world x-axis

    		var m1;

    		return function rotateX( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationX( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateY: function () {

    		// rotate geometry around world y-axis

    		var m1;

    		return function rotateY( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationY( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateZ: function () {

    		// rotate geometry around world z-axis

    		var m1;

    		return function rotateZ( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationZ( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	translate: function () {

    		// translate geometry

    		var m1;

    		return function translate( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeTranslation( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	scale: function () {

    		// scale geometry

    		var m1;

    		return function scale( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeScale( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	lookAt: function () {

    		var obj;

    		return function lookAt( vector ) {

    			if ( obj === undefined ) obj = new Object3D();

    			obj.lookAt( vector );

    			obj.updateMatrix();

    			this.applyMatrix( obj.matrix );

    		};

    	}(),

    	center: function () {

    		this.computeBoundingBox();

    		var offset = this.boundingBox.getCenter().negate();

    		this.translate( offset.x, offset.y, offset.z );

    		return offset;

    	},

    	setFromObject: function ( object ) {

    		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

    		var geometry = object.geometry;

    		if ( (object && object.isPoints) || (object && object.isLine) ) {

    			var positions = new Float32Attribute( geometry.vertices.length * 3, 3 );
    			var colors = new Float32Attribute( geometry.colors.length * 3, 3 );

    			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
    			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

    			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

    				var lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );

    				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

    			}

    			if ( geometry.boundingSphere !== null ) {

    				this.boundingSphere = geometry.boundingSphere.clone();

    			}

    			if ( geometry.boundingBox !== null ) {

    				this.boundingBox = geometry.boundingBox.clone();

    			}

    		} else if ( (object && object.isMesh) ) {

    			if ( (geometry && geometry.isGeometry) ) {

    				this.fromGeometry( geometry );

    			}

    		}

    		return this;

    	},

    	updateFromObject: function ( object ) {

    		var geometry = object.geometry;

    		if ( (object && object.isMesh) ) {

    			var direct = geometry.__directGeometry;

    			if ( geometry.elementsNeedUpdate === true ) {

    				direct = undefined;
    				geometry.elementsNeedUpdate = false;

    			}

    			if ( direct === undefined ) {

    				return this.fromGeometry( geometry );

    			}

    			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
    			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
    			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
    			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
    			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

    			geometry.verticesNeedUpdate = false;
    			geometry.normalsNeedUpdate = false;
    			geometry.colorsNeedUpdate = false;
    			geometry.uvsNeedUpdate = false;
    			geometry.groupsNeedUpdate = false;

    			geometry = direct;

    		}

    		var attribute;

    		if ( geometry.verticesNeedUpdate === true ) {

    			attribute = this.attributes.position;

    			if ( attribute !== undefined ) {

    				attribute.copyVector3sArray( geometry.vertices );
    				attribute.needsUpdate = true;

    			}

    			geometry.verticesNeedUpdate = false;

    		}

    		if ( geometry.normalsNeedUpdate === true ) {

    			attribute = this.attributes.normal;

    			if ( attribute !== undefined ) {

    				attribute.copyVector3sArray( geometry.normals );
    				attribute.needsUpdate = true;

    			}

    			geometry.normalsNeedUpdate = false;

    		}

    		if ( geometry.colorsNeedUpdate === true ) {

    			attribute = this.attributes.color;

    			if ( attribute !== undefined ) {

    				attribute.copyColorsArray( geometry.colors );
    				attribute.needsUpdate = true;

    			}

    			geometry.colorsNeedUpdate = false;

    		}

    		if ( geometry.uvsNeedUpdate ) {

    			attribute = this.attributes.uv;

    			if ( attribute !== undefined ) {

    				attribute.copyVector2sArray( geometry.uvs );
    				attribute.needsUpdate = true;

    			}

    			geometry.uvsNeedUpdate = false;

    		}

    		if ( geometry.lineDistancesNeedUpdate ) {

    			attribute = this.attributes.lineDistance;

    			if ( attribute !== undefined ) {

    				attribute.copyArray( geometry.lineDistances );
    				attribute.needsUpdate = true;

    			}

    			geometry.lineDistancesNeedUpdate = false;

    		}

    		if ( geometry.groupsNeedUpdate ) {

    			geometry.computeGroups( object.geometry );
    			this.groups = geometry.groups;

    			geometry.groupsNeedUpdate = false;

    		}

    		return this;

    	},

    	fromGeometry: function ( geometry ) {

    		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

    		return this.fromDirectGeometry( geometry.__directGeometry );

    	},

    	fromDirectGeometry: function ( geometry ) {

    		var positions = new Float32Array( geometry.vertices.length * 3 );
    		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

    		if ( geometry.normals.length > 0 ) {

    			var normals = new Float32Array( geometry.normals.length * 3 );
    			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

    		}

    		if ( geometry.colors.length > 0 ) {

    			var colors = new Float32Array( geometry.colors.length * 3 );
    			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

    		}

    		if ( geometry.uvs.length > 0 ) {

    			var uvs = new Float32Array( geometry.uvs.length * 2 );
    			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

    		}

    		if ( geometry.uvs2.length > 0 ) {

    			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
    			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

    		}

    		if ( geometry.indices.length > 0 ) {

    			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
    			var indices = new TypeArray( geometry.indices.length * 3 );
    			this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

    		}

    		// groups

    		this.groups = geometry.groups;

    		// morphs

    		for ( var name in geometry.morphTargets ) {

    			var array = [];
    			var morphTargets = geometry.morphTargets[ name ];

    			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

    				var morphTarget = morphTargets[ i ];

    				var attribute = new Float32Attribute( morphTarget.length * 3, 3 );

    				array.push( attribute.copyVector3sArray( morphTarget ) );

    			}

    			this.morphAttributes[ name ] = array;

    		}

    		// skinning

    		if ( geometry.skinIndices.length > 0 ) {

    			var skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );
    			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

    		}

    		if ( geometry.skinWeights.length > 0 ) {

    			var skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );
    			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

    		}

    		//

    		if ( geometry.boundingSphere !== null ) {

    			this.boundingSphere = geometry.boundingSphere.clone();

    		}

    		if ( geometry.boundingBox !== null ) {

    			this.boundingBox = geometry.boundingBox.clone();

    		}

    		return this;

    	},

    	computeBoundingBox: function () {

    		if ( this.boundingBox === null ) {

    			this.boundingBox = new Box3();

    		}

    		var positions = this.attributes.position.array;

    		if ( positions !== undefined ) {

    			this.boundingBox.setFromArray( positions );

    		} else {

    			this.boundingBox.makeEmpty();

    		}

    		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

    			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

    		}

    	},

    	computeBoundingSphere: function () {

    		var box = new Box3();
    		var vector = new Vector3();

    		return function computeBoundingSphere() {

    			if ( this.boundingSphere === null ) {

    				this.boundingSphere = new Sphere();

    			}

    			var positions = this.attributes.position;

    			if ( positions ) {

    				var array = positions.array;
    				var center = this.boundingSphere.center;

    				box.setFromArray( array );
    				box.getCenter( center );

    				// hoping to find a boundingSphere with a radius smaller than the
    				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

    				var maxRadiusSq = 0;

    				for ( var i = 0, il = array.length; i < il; i += 3 ) {

    					vector.fromArray( array, i );
    					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

    				}

    				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

    				if ( isNaN( this.boundingSphere.radius ) ) {

    					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

    				}

    			}

    		};

    	}(),

    	computeFaceNormals: function () {

    		// backwards compatibility

    	},

    	computeVertexNormals: function () {

    		var index = this.index;
    		var attributes = this.attributes;
    		var groups = this.groups;

    		if ( attributes.position ) {

    			var positions = attributes.position.array;

    			if ( attributes.normal === undefined ) {

    				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

    			} else {

    				// reset existing normals to zero

    				var array = attributes.normal.array;

    				for ( var i = 0, il = array.length; i < il; i ++ ) {

    					array[ i ] = 0;

    				}

    			}

    			var normals = attributes.normal.array;

    			var vA, vB, vC,

    			pA = new Vector3(),
    			pB = new Vector3(),
    			pC = new Vector3(),

    			cb = new Vector3(),
    			ab = new Vector3();

    			// indexed elements

    			if ( index ) {

    				var indices = index.array;

    				if ( groups.length === 0 ) {

    					this.addGroup( 0, indices.length );

    				}

    				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

    					var group = groups[ j ];

    					var start = group.start;
    					var count = group.count;

    					for ( var i = start, il = start + count; i < il; i += 3 ) {

    						vA = indices[ i + 0 ] * 3;
    						vB = indices[ i + 1 ] * 3;
    						vC = indices[ i + 2 ] * 3;

    						pA.fromArray( positions, vA );
    						pB.fromArray( positions, vB );
    						pC.fromArray( positions, vC );

    						cb.subVectors( pC, pB );
    						ab.subVectors( pA, pB );
    						cb.cross( ab );

    						normals[ vA ] += cb.x;
    						normals[ vA + 1 ] += cb.y;
    						normals[ vA + 2 ] += cb.z;

    						normals[ vB ] += cb.x;
    						normals[ vB + 1 ] += cb.y;
    						normals[ vB + 2 ] += cb.z;

    						normals[ vC ] += cb.x;
    						normals[ vC + 1 ] += cb.y;
    						normals[ vC + 2 ] += cb.z;

    					}

    				}

    			} else {

    				// non-indexed elements (unconnected triangle soup)

    				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

    					pA.fromArray( positions, i );
    					pB.fromArray( positions, i + 3 );
    					pC.fromArray( positions, i + 6 );

    					cb.subVectors( pC, pB );
    					ab.subVectors( pA, pB );
    					cb.cross( ab );

    					normals[ i ] = cb.x;
    					normals[ i + 1 ] = cb.y;
    					normals[ i + 2 ] = cb.z;

    					normals[ i + 3 ] = cb.x;
    					normals[ i + 4 ] = cb.y;
    					normals[ i + 5 ] = cb.z;

    					normals[ i + 6 ] = cb.x;
    					normals[ i + 7 ] = cb.y;
    					normals[ i + 8 ] = cb.z;

    				}

    			}

    			this.normalizeNormals();

    			attributes.normal.needsUpdate = true;

    		}

    	},

    	merge: function ( geometry, offset ) {

    		if ( (geometry && geometry.isBufferGeometry) === false ) {

    			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
    			return;

    		}

    		if ( offset === undefined ) offset = 0;

    		var attributes = this.attributes;

    		for ( var key in attributes ) {

    			if ( geometry.attributes[ key ] === undefined ) continue;

    			var attribute1 = attributes[ key ];
    			var attributeArray1 = attribute1.array;

    			var attribute2 = geometry.attributes[ key ];
    			var attributeArray2 = attribute2.array;

    			var attributeSize = attribute2.itemSize;

    			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

    				attributeArray1[ j ] = attributeArray2[ i ];

    			}

    		}

    		return this;

    	},

    	normalizeNormals: function () {

    		var normals = this.attributes.normal.array;

    		var x, y, z, n;

    		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

    			x = normals[ i ];
    			y = normals[ i + 1 ];
    			z = normals[ i + 2 ];

    			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

    			normals[ i ] *= n;
    			normals[ i + 1 ] *= n;
    			normals[ i + 2 ] *= n;

    		}

    	},

    	toNonIndexed: function () {

    		if ( this.index === null ) {

    			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
    			return this;

    		}

    		var geometry2 = new BufferGeometry();

    		var indices = this.index.array;
    		var attributes = this.attributes;

    		for ( var name in attributes ) {

    			var attribute = attributes[ name ];

    			var array = attribute.array;
    			var itemSize = attribute.itemSize;

    			var array2 = new array.constructor( indices.length * itemSize );

    			var index = 0, index2 = 0;

    			for ( var i = 0, l = indices.length; i < l; i ++ ) {

    				index = indices[ i ] * itemSize;

    				for ( var j = 0; j < itemSize; j ++ ) {

    					array2[ index2 ++ ] = array[ index ++ ];

    				}

    			}

    			geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

    		}

    		return geometry2;

    	},

    	toJSON: function () {

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'BufferGeometry',
    				generator: 'BufferGeometry.toJSON'
    			}
    		};

    		// standard BufferGeometry serialization

    		data.uuid = this.uuid;
    		data.type = this.type;
    		if ( this.name !== '' ) data.name = this.name;

    		if ( this.parameters !== undefined ) {

    			var parameters = this.parameters;

    			for ( var key in parameters ) {

    				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

    			}

    			return data;

    		}

    		data.data = { attributes: {} };

    		var index = this.index;

    		if ( index !== null ) {

    			var array = Array.prototype.slice.call( index.array );

    			data.data.index = {
    				type: index.array.constructor.name,
    				array: array
    			};

    		}

    		var attributes = this.attributes;

    		for ( var key in attributes ) {

    			var attribute = attributes[ key ];

    			var array = Array.prototype.slice.call( attribute.array );

    			data.data.attributes[ key ] = {
    				itemSize: attribute.itemSize,
    				type: attribute.array.constructor.name,
    				array: array,
    				normalized: attribute.normalized
    			};

    		}

    		var groups = this.groups;

    		if ( groups.length > 0 ) {

    			data.data.groups = JSON.parse( JSON.stringify( groups ) );

    		}

    		var boundingSphere = this.boundingSphere;

    		if ( boundingSphere !== null ) {

    			data.data.boundingSphere = {
    				center: boundingSphere.center.toArray(),
    				radius: boundingSphere.radius
    			};

    		}

    		return data;

    	},

    	clone: function () {

    		/*
    		// Handle primitives

    		var parameters = this.parameters;

    		if ( parameters !== undefined ) {

    			var values = [];

    			for ( var key in parameters ) {

    				values.push( parameters[ key ] );

    			}

    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;

    		}

    		return new this.constructor().copy( this );
    		*/

    		return new BufferGeometry().copy( this );

    	},

    	copy: function ( source ) {

    		var index = source.index;

    		if ( index !== null ) {

    			this.setIndex( index.clone() );

    		}

    		var attributes = source.attributes;

    		for ( var name in attributes ) {

    			var attribute = attributes[ name ];
    			this.addAttribute( name, attribute.clone() );

    		}

    		var groups = source.groups;

    		for ( var i = 0, l = groups.length; i < l; i ++ ) {

    			var group = groups[ i ];
    			this.addGroup( group.start, group.count, group.materialIndex );

    		}

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    BufferGeometry.MaxIndex = 65535;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author jonobr1 / http://jonobr1.com/
     */

    function Mesh( geometry, material ) {

    	Object3D.call( this );

    	this.type = 'Mesh';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

    	this.drawMode = TrianglesDrawMode;

    	this.updateMorphTargets();

    }

    Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Mesh,

    	isMesh: true,

    	setDrawMode: function ( value ) {

    		this.drawMode = value;

    	},

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.drawMode = source.drawMode;

    		return this;

    	},

    	updateMorphTargets: function () {

    		var morphTargets = this.geometry.morphTargets;

    		if ( morphTargets !== undefined && morphTargets.length > 0 ) {

    			this.morphTargetInfluences = [];
    			this.morphTargetDictionary = {};

    			for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

    				this.morphTargetInfluences.push( 0 );
    				this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

    			}

    		}

    	},

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		var vA = new Vector3();
    		var vB = new Vector3();
    		var vC = new Vector3();

    		var tempA = new Vector3();
    		var tempB = new Vector3();
    		var tempC = new Vector3();

    		var uvA = new Vector2();
    		var uvB = new Vector2();
    		var uvC = new Vector2();

    		var barycoord = new Vector3();

    		var intersectionPoint = new Vector3();
    		var intersectionPointWorld = new Vector3();

    		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

    			Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

    			uv1.multiplyScalar( barycoord.x );
    			uv2.multiplyScalar( barycoord.y );
    			uv3.multiplyScalar( barycoord.z );

    			uv1.add( uv2 ).add( uv3 );

    			return uv1.clone();

    		}

    		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

    			var intersect;
    			var material = object.material;

    			if ( material.side === BackSide ) {

    				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

    			} else {

    				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

    			}

    			if ( intersect === null ) return null;

    			intersectionPointWorld.copy( point );
    			intersectionPointWorld.applyMatrix4( object.matrixWorld );

    			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

    			if ( distance < raycaster.near || distance > raycaster.far ) return null;

    			return {
    				distance: distance,
    				point: intersectionPointWorld.clone(),
    				object: object
    			};

    		}

    		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

    			vA.fromArray( positions, a * 3 );
    			vB.fromArray( positions, b * 3 );
    			vC.fromArray( positions, c * 3 );

    			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

    			if ( intersection ) {

    				if ( uvs ) {

    					uvA.fromArray( uvs, a * 2 );
    					uvB.fromArray( uvs, b * 2 );
    					uvC.fromArray( uvs, c * 2 );

    					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

    				}

    				intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
    				intersection.faceIndex = a;

    			}

    			return intersection;

    		}

    		return function raycast( raycaster, intersects ) {

    			var geometry = this.geometry;
    			var material = this.material;
    			var matrixWorld = this.matrixWorld;

    			if ( material === undefined ) return;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			// Check boundingBox before continuing

    			if ( geometry.boundingBox !== null ) {

    				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

    			}

    			var uvs, intersection;

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var a, b, c;
    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( attributes.uv !== undefined ) {

    					uvs = attributes.uv.array;

    				}

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, l = indices.length; i < l; i += 3 ) {

    						a = indices[ i ];
    						b = indices[ i + 1 ];
    						c = indices[ i + 2 ];

    						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

    						if ( intersection ) {

    							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
    							intersects.push( intersection );

    						}

    					}

    				} else {


    					for ( var i = 0, l = positions.length; i < l; i += 9 ) {

    						a = i / 3;
    						b = a + 1;
    						c = a + 2;

    						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

    						if ( intersection ) {

    							intersection.index = a; // triangle number in positions buffer semantics
    							intersects.push( intersection );

    						}

    					}

    				}

    			} else if ( (geometry && geometry.isGeometry) ) {

    				var fvA, fvB, fvC;
    				var isFaceMaterial = (material && material.isMultiMaterial);
    				var materials = isFaceMaterial === true ? material.materials : null;

    				var vertices = geometry.vertices;
    				var faces = geometry.faces;
    				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
    				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

    				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

    					var face = faces[ f ];
    					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

    					if ( faceMaterial === undefined ) continue;

    					fvA = vertices[ face.a ];
    					fvB = vertices[ face.b ];
    					fvC = vertices[ face.c ];

    					if ( faceMaterial.morphTargets === true ) {

    						var morphTargets = geometry.morphTargets;
    						var morphInfluences = this.morphTargetInfluences;

    						vA.set( 0, 0, 0 );
    						vB.set( 0, 0, 0 );
    						vC.set( 0, 0, 0 );

    						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

    							var influence = morphInfluences[ t ];

    							if ( influence === 0 ) continue;

    							var targets = morphTargets[ t ].vertices;

    							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
    							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
    							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

    						}

    						vA.add( fvA );
    						vB.add( fvB );
    						vC.add( fvC );

    						fvA = vA;
    						fvB = vB;
    						fvC = vC;

    					}

    					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

    					if ( intersection ) {

    						if ( uvs ) {

    							var uvs_f = uvs[ f ];
    							uvA.copy( uvs_f[ 0 ] );
    							uvB.copy( uvs_f[ 1 ] );
    							uvC.copy( uvs_f[ 2 ] );

    							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

    						}

    						intersection.face = face;
    						intersection.faceIndex = f;
    						intersects.push( intersection );

    					}

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    	BufferGeometry.call( this );

    	this.type = 'BoxBufferGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		depth: depth,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		depthSegments: depthSegments
    	};

    	var scope = this;

    	// segments
    	widthSegments = Math.floor( widthSegments ) || 1;
    	heightSegments = Math.floor( heightSegments ) || 1;
    	depthSegments = Math.floor( depthSegments ) || 1;

    	// these are used to calculate buffer length
    	var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
    	var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );

    	// buffers
    	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
    	var vertices = new Float32Array( vertexCount * 3 );
    	var normals = new Float32Array( vertexCount * 3 );
    	var uvs = new Float32Array( vertexCount * 2 );

    	// offset variables
    	var vertexBufferOffset = 0;
    	var uvBufferOffset = 0;
    	var indexBufferOffset = 0;
    	var numberOfVertices = 0;

    	// group variables
    	var groupStart = 0;

    	// build each side of the box geometry
    	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
    	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
    	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
    	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
    	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
    	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

    	// build geometry
    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    	// helper functions

    	function calculateVertexCount( w, h, d ) {

    		var vertices = 0;

    		// calculate the amount of vertices for each side (plane)
    		vertices += (w + 1) * (h + 1) * 2; // xy
    		vertices += (w + 1) * (d + 1) * 2; // xz
    		vertices += (d + 1) * (h + 1) * 2; // zy

    		return vertices;

    	}

    	function calculateIndexCount( w, h, d ) {

    		var index = 0;

    		// calculate the amount of squares for each side
    		index += w * h * 2; // xy
    		index += w * d * 2; // xz
    		index += d * h * 2; // zy

    		return index * 6; // two triangles per square => six vertices per square

    	}

    	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

    		var segmentWidth	= width / gridX;
    		var segmentHeight = height / gridY;

    		var widthHalf = width / 2;
    		var heightHalf = height / 2;
    		var depthHalf = depth / 2;

    		var gridX1 = gridX + 1;
    		var gridY1 = gridY + 1;

    		var vertexCounter = 0;
    		var groupCount = 0;

    		var vector = new Vector3();

    		// generate vertices, normals and uvs

    		for ( var iy = 0; iy < gridY1; iy ++ ) {

    			var y = iy * segmentHeight - heightHalf;

    			for ( var ix = 0; ix < gridX1; ix ++ ) {

    				var x = ix * segmentWidth - widthHalf;

    				// set values to correct vector component
    				vector[ u ] = x * udir;
    				vector[ v ] = y * vdir;
    				vector[ w ] = depthHalf;

    				// now apply vector to vertex buffer
    				vertices[ vertexBufferOffset ] = vector.x;
    				vertices[ vertexBufferOffset + 1 ] = vector.y;
    				vertices[ vertexBufferOffset + 2 ] = vector.z;

    				// set values to correct vector component
    				vector[ u ] = 0;
    				vector[ v ] = 0;
    				vector[ w ] = depth > 0 ? 1 : - 1;

    				// now apply vector to normal buffer
    				normals[ vertexBufferOffset ] = vector.x;
    				normals[ vertexBufferOffset + 1 ] = vector.y;
    				normals[ vertexBufferOffset + 2 ] = vector.z;

    				// uvs
    				uvs[ uvBufferOffset ] = ix / gridX;
    				uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

    				// update offsets and counters
    				vertexBufferOffset += 3;
    				uvBufferOffset += 2;
    				vertexCounter += 1;

    			}

    		}

    		// 1. you need three indices to draw a single face
    		// 2. a single segment consists of two faces
    		// 3. so we need to generate six (2*3) indices per segment

    		for ( iy = 0; iy < gridY; iy ++ ) {

    			for ( ix = 0; ix < gridX; ix ++ ) {

    				// indices
    				var a = numberOfVertices + ix + gridX1 * iy;
    				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
    				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
    				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

    				// face one
    				indices[ indexBufferOffset ] = a;
    				indices[ indexBufferOffset + 1 ] = b;
    				indices[ indexBufferOffset + 2 ] = d;

    				// face two
    				indices[ indexBufferOffset + 3 ] = b;
    				indices[ indexBufferOffset + 4 ] = c;
    				indices[ indexBufferOffset + 5 ] = d;

    				// update offsets and counters
    				indexBufferOffset += 6;
    				groupCount += 6;

    			}

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, materialIndex );

    		// calculate new start value for groups
    		groupStart += groupCount;

    		// update total number of vertices
    		numberOfVertices += vertexCounter;

    	}

    }

    BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */

    function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

    	BufferGeometry.call( this );

    	this.type = 'PlaneBufferGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments
    	};

    	var width_half = width / 2;
    	var height_half = height / 2;

    	var gridX = Math.floor( widthSegments ) || 1;
    	var gridY = Math.floor( heightSegments ) || 1;

    	var gridX1 = gridX + 1;
    	var gridY1 = gridY + 1;

    	var segment_width = width / gridX;
    	var segment_height = height / gridY;

    	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
    	var normals = new Float32Array( gridX1 * gridY1 * 3 );
    	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

    	var offset = 0;
    	var offset2 = 0;

    	for ( var iy = 0; iy < gridY1; iy ++ ) {

    		var y = iy * segment_height - height_half;

    		for ( var ix = 0; ix < gridX1; ix ++ ) {

    			var x = ix * segment_width - width_half;

    			vertices[ offset ] = x;
    			vertices[ offset + 1 ] = - y;

    			normals[ offset + 2 ] = 1;

    			uvs[ offset2 ] = ix / gridX;
    			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

    			offset += 3;
    			offset2 += 2;

    		}

    	}

    	offset = 0;

    	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

    	for ( var iy = 0; iy < gridY; iy ++ ) {

    		for ( var ix = 0; ix < gridX; ix ++ ) {

    			var a = ix + gridX1 * iy;
    			var b = ix + gridX1 * ( iy + 1 );
    			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
    			var d = ( ix + 1 ) + gridX1 * iy;

    			indices[ offset ] = a;
    			indices[ offset + 1 ] = b;
    			indices[ offset + 2 ] = d;

    			indices[ offset + 3 ] = b;
    			indices[ offset + 4 ] = c;
    			indices[ offset + 5 ] = d;

    			offset += 6;

    		}

    	}

    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    }

    PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author WestLangley / http://github.com/WestLangley
    */

    function Camera() {

    	Object3D.call( this );

    	this.type = 'Camera';

    	this.matrixWorldInverse = new Matrix4();
    	this.projectionMatrix = new Matrix4();

    }

    Camera.prototype = Object.create( Object3D.prototype );
    Camera.prototype.constructor = Camera;

    Camera.prototype.isCamera = true;

    Camera.prototype.getWorldDirection = function () {

    	var quaternion = new Quaternion();

    	return function getWorldDirection( optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		this.getWorldQuaternion( quaternion );

    		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    	};

    }();

    Camera.prototype.lookAt = function () {

    	// This routine does not support cameras with rotated and/or translated parent(s)

    	var m1 = new Matrix4();

    	return function lookAt( vector ) {

    		m1.lookAt( this.position, vector, this.up );

    		this.quaternion.setFromRotationMatrix( m1 );

    	};

    }();

    Camera.prototype.clone = function () {

    	return new this.constructor().copy( this );

    };

    Camera.prototype.copy = function ( source ) {

    	Object3D.prototype.copy.call( this, source );

    	this.matrixWorldInverse.copy( source.matrixWorldInverse );
    	this.projectionMatrix.copy( source.projectionMatrix );

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author greggman / http://games.greggman.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author tschw
     */

    function PerspectiveCamera( fov, aspect, near, far ) {

    	Camera.call( this );

    	this.type = 'PerspectiveCamera';

    	this.fov = fov !== undefined ? fov : 50;
    	this.zoom = 1;

    	this.near = near !== undefined ? near : 0.1;
    	this.far = far !== undefined ? far : 2000;
    	this.focus = 10;

    	this.aspect = aspect !== undefined ? aspect : 1;
    	this.view = null;

    	this.filmGauge = 35;	// width of the film (default in millimeters)
    	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

    	this.updateProjectionMatrix();

    }

    PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    	constructor: PerspectiveCamera,

    	isPerspectiveCamera: true,

    	copy: function ( source ) {

    		Camera.prototype.copy.call( this, source );

    		this.fov = source.fov;
    		this.zoom = source.zoom;

    		this.near = source.near;
    		this.far = source.far;
    		this.focus = source.focus;

    		this.aspect = source.aspect;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		this.filmGauge = source.filmGauge;
    		this.filmOffset = source.filmOffset;

    		return this;

    	},

    	/**
    	 * Sets the FOV by focal length in respect to the current .filmGauge.
    	 *
    	 * The default film gauge is 35, so that the focal length can be specified for
    	 * a 35mm (full frame) camera.
    	 *
    	 * Values for focal length and film gauge must have the same unit.
    	 */
    	setFocalLength: function ( focalLength ) {

    		// see http://www.bobatkins.com/photography/technical/field_of_view.html
    		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

    		this.fov = exports.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
    		this.updateProjectionMatrix();

    	},

    	/**
    	 * Calculates the focal length from the current .fov and .filmGauge.
    	 */
    	getFocalLength: function () {

    		var vExtentSlope = Math.tan( exports.Math.DEG2RAD * 0.5 * this.fov );

    		return 0.5 * this.getFilmHeight() / vExtentSlope;

    	},

    	getEffectiveFOV: function () {

    		return exports.Math.RAD2DEG * 2 * Math.atan(
    				Math.tan( exports.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

    	},

    	getFilmWidth: function () {

    		// film not completely covered in portrait format (aspect < 1)
    		return this.filmGauge * Math.min( this.aspect, 1 );

    	},

    	getFilmHeight: function () {

    		// film not completely covered in landscape format (aspect > 1)
    		return this.filmGauge / Math.max( this.aspect, 1 );

    	},

    	/**
    	 * Sets an offset in a larger frustum. This is useful for multi-window or
    	 * multi-monitor/multi-machine setups.
    	 *
    	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
    	 * the monitors are in grid like this
    	 *
    	 *   +---+---+---+
    	 *   | A | B | C |
    	 *   +---+---+---+
    	 *   | D | E | F |
    	 *   +---+---+---+
    	 *
    	 * then for each monitor you would call it like this
    	 *
    	 *   var w = 1920;
    	 *   var h = 1080;
    	 *   var fullWidth = w * 3;
    	 *   var fullHeight = h * 2;
    	 *
    	 *   --A--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
    	 *   --B--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
    	 *   --C--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
    	 *   --D--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
    	 *   --E--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
    	 *   --F--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
    	 *
    	 *   Note there is no reason monitors have to be the same size or in a grid.
    	 */
    	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

    		this.aspect = fullWidth / fullHeight;

    		this.view = {
    			fullWidth: fullWidth,
    			fullHeight: fullHeight,
    			offsetX: x,
    			offsetY: y,
    			width: width,
    			height: height
    		};

    		this.updateProjectionMatrix();

    	},

    	clearViewOffset: function() {

    		this.view = null;
    		this.updateProjectionMatrix();

    	},

    	updateProjectionMatrix: function () {

    		var near = this.near,
    			top = near * Math.tan(
    					exports.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
    			height = 2 * top,
    			width = this.aspect * height,
    			left = - 0.5 * width,
    			view = this.view;

    		if ( view !== null ) {

    			var fullWidth = view.fullWidth,
    				fullHeight = view.fullHeight;

    			left += view.offsetX * width / fullWidth;
    			top -= view.offsetY * height / fullHeight;
    			width *= view.width / fullWidth;
    			height *= view.height / fullHeight;

    		}

    		var skew = this.filmOffset;
    		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

    		this.projectionMatrix.makeFrustum(
    				left, left + width, top - height, top, near, this.far );

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.fov = this.fov;
    		data.object.zoom = this.zoom;

    		data.object.near = this.near;
    		data.object.far = this.far;
    		data.object.focus = this.focus;

    		data.object.aspect = this.aspect;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		data.object.filmGauge = this.filmGauge;
    		data.object.filmOffset = this.filmOffset;

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author arose / http://github.com/arose
     */

    function OrthographicCamera( left, right, top, bottom, near, far ) {

    	Camera.call( this );

    	this.type = 'OrthographicCamera';

    	this.zoom = 1;
    	this.view = null;

    	this.left = left;
    	this.right = right;
    	this.top = top;
    	this.bottom = bottom;

    	this.near = ( near !== undefined ) ? near : 0.1;
    	this.far = ( far !== undefined ) ? far : 2000;

    	this.updateProjectionMatrix();

    }

    OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    	constructor: OrthographicCamera,

    	isOrthographicCamera: true,

    	copy: function ( source ) {

    		Camera.prototype.copy.call( this, source );

    		this.left = source.left;
    		this.right = source.right;
    		this.top = source.top;
    		this.bottom = source.bottom;
    		this.near = source.near;
    		this.far = source.far;

    		this.zoom = source.zoom;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		return this;

    	},

    	setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

    		this.view = {
    			fullWidth: fullWidth,
    			fullHeight: fullHeight,
    			offsetX: x,
    			offsetY: y,
    			width: width,
    			height: height
    		};

    		this.updateProjectionMatrix();

    	},

    	clearViewOffset: function() {

    		this.view = null;
    		this.updateProjectionMatrix();

    	},

    	updateProjectionMatrix: function () {

    		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    		var cx = ( this.right + this.left ) / 2;
    		var cy = ( this.top + this.bottom ) / 2;

    		var left = cx - dx;
    		var right = cx + dx;
    		var top = cy + dy;
    		var bottom = cy - dy;

    		if ( this.view !== null ) {

    			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
    			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
    			var scaleW = ( this.right - this.left ) / this.view.width;
    			var scaleH = ( this.top - this.bottom ) / this.view.height;

    			left += scaleW * ( this.view.offsetX / zoomW );
    			right = left + scaleW * ( this.view.width / zoomW );
    			top -= scaleH * ( this.view.offsetY / zoomH );
    			bottom = top - scaleH * ( this.view.height / zoomH );

    		}

    		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.zoom = this.zoom;
    		data.object.left = this.left;
    		data.object.right = this.right;
    		data.object.top = this.top;
    		data.object.bottom = this.bottom;
    		data.object.near = this.near;
    		data.object.far = this.far;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		return data;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

    	var mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	var type, size;

    	function setIndex( index ) {

    		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

    			type = gl.UNSIGNED_INT;
    			size = 4;

    		} else {

    			type = gl.UNSIGNED_SHORT;
    			size = 2;

    		}

    	}

    	function render( start, count ) {

    		gl.drawElements( mode, count, type, start * size );

    		infoRender.calls ++;
    		infoRender.vertices += count;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

    	}

    	function renderInstances( geometry, start, count ) {

    		var extension = extensions.get( 'ANGLE_instanced_arrays' );

    		if ( extension === null ) {

    			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    			return;

    		}

    		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

    		infoRender.calls ++;
    		infoRender.vertices += count * geometry.maxInstancedCount;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

    	}

    	return {

    		setMode: setMode,
    		setIndex: setIndex,
    		render: render,
    		renderInstances: renderInstances

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLBufferRenderer( gl, extensions, infoRender ) {

    	var mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	function render( start, count ) {

    		gl.drawArrays( mode, start, count );

    		infoRender.calls ++;
    		infoRender.vertices += count;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

    	}

    	function renderInstances( geometry ) {

    		var extension = extensions.get( 'ANGLE_instanced_arrays' );

    		if ( extension === null ) {

    			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    			return;

    		}

    		var position = geometry.attributes.position;

    		var count = 0;

    		if ( (position && position.isInterleavedBufferAttribute) ) {

    			count = position.data.count;

    			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

    		} else {

    			count = position.count;

    			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

    		}

    		infoRender.calls ++;
    		infoRender.vertices += count * geometry.maxInstancedCount;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

    	}

    	return {
    		setMode: setMode,
    		render: render,
    		renderInstances: renderInstances
    	};

    }

    function WebGLLights() {

    	var lights = {};

    	return {

    		get: function ( light ) {

    			if ( lights[ light.id ] !== undefined ) {

    				return lights[ light.id ];

    			}

    			var uniforms;

    			switch ( light.type ) {

    				case 'DirectionalLight':
    					uniforms = {
    						direction: new Vector3(),
    						color: new Color(),

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'SpotLight':
    					uniforms = {
    						position: new Vector3(),
    						direction: new Vector3(),
    						color: new Color(),
    						distance: 0,
    						coneCos: 0,
    						penumbraCos: 0,
    						decay: 0,

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'PointLight':
    					uniforms = {
    						position: new Vector3(),
    						color: new Color(),
    						distance: 0,
    						decay: 0,

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'HemisphereLight':
    					uniforms = {
    						direction: new Vector3(),
    						skyColor: new Color(),
    						groundColor: new Color()
    					};
    					break;

    			}

    			lights[ light.id ] = uniforms;

    			return uniforms;

    		}

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function addLineNumbers( string ) {

    	var lines = string.split( '\n' );

    	for ( var i = 0; i < lines.length; i ++ ) {

    		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    	}

    	return lines.join( '\n' );

    }

    function WebGLShader( gl, type, string ) {

    	var shader = gl.createShader( type );

    	gl.shaderSource( shader, string );
    	gl.compileShader( shader );

    	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

    		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    	}

    	if ( gl.getShaderInfoLog( shader ) !== '' ) {

    		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

    	}

    	// --enable-privileged-webgl-extension
    	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    	return shader;

    }

    var programIdCount = 0;

    function getEncodingComponents( encoding ) {

    	switch ( encoding ) {

    		case LinearEncoding:
    			return [ 'Linear','( value )' ];
    		case sRGBEncoding:
    			return [ 'sRGB','( value )' ];
    		case RGBEEncoding:
    			return [ 'RGBE','( value )' ];
    		case RGBM7Encoding:
    			return [ 'RGBM','( value, 7.0 )' ];
    		case RGBM16Encoding:
    			return [ 'RGBM','( value, 16.0 )' ];
    		case RGBDEncoding:
    			return [ 'RGBD','( value, 256.0 )' ];
    		case GammaEncoding:
    			return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
    		default:
    			throw new Error( 'unsupported encoding: ' + encoding );

    	}

    }

    function getTexelDecodingFunction( functionName, encoding ) {

    	var components = getEncodingComponents( encoding );
    	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

    }

    function getTexelEncodingFunction( functionName, encoding ) {

    	var components = getEncodingComponents( encoding );
    	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

    }

    function getToneMappingFunction( functionName, toneMapping ) {

    	var toneMappingName;

    	switch ( toneMapping ) {

    		case LinearToneMapping:
    			toneMappingName = "Linear";
    			break;

    		case ReinhardToneMapping:
    			toneMappingName = "Reinhard";
    			break;

    		case Uncharted2ToneMapping:
    			toneMappingName = "Uncharted2";
    			break;

    		case CineonToneMapping:
    			toneMappingName = "OptimizedCineon";
    			break;

    		default:
    			throw new Error( 'unsupported toneMapping: ' + toneMapping );

    	}

    	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

    }

    function generateExtensions( extensions, parameters, rendererExtensions ) {

    	extensions = extensions || {};

    	var chunks = [
    		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
    		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
    		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
    		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
    	];

    	return chunks.filter( filterEmptyLine ).join( '\n' );

    }

    function generateDefines( defines ) {

    	var chunks = [];

    	for ( var name in defines ) {

    		var value = defines[ name ];

    		if ( value === false ) continue;

    		chunks.push( '#define ' + name + ' ' + value );

    	}

    	return chunks.join( '\n' );

    }

    function fetchAttributeLocations( gl, program, identifiers ) {

    	var attributes = {};

    	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

    	for ( var i = 0; i < n; i ++ ) {

    		var info = gl.getActiveAttrib( program, i );
    		var name = info.name;

    		// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

    		attributes[ name ] = gl.getAttribLocation( program, name );

    	}

    	return attributes;

    }

    function filterEmptyLine( string ) {

    	return string !== '';

    }

    function replaceLightNums( string, parameters ) {

    	return string
    		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
    		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
    		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
    		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

    }

    function parseIncludes( string ) {

    	var pattern = /#include +<([\w\d.]+)>/g;

    	function replace( match, include ) {

    		var replace = ShaderChunk[ include ];

    		if ( replace === undefined ) {

    			throw new Error( 'Can not resolve #include <' + include + '>' );

    		}

    		return parseIncludes( replace );

    	}

    	return string.replace( pattern, replace );

    }

    function unrollLoops( string ) {

    	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

    	function replace( match, start, end, snippet ) {

    		var unroll = '';

    		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

    			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

    		}

    		return unroll;

    	}

    	return string.replace( pattern, replace );

    }

    function WebGLProgram( renderer, code, material, parameters ) {

    	var gl = renderer.context;

    	var extensions = material.extensions;
    	var defines = material.defines;

    	var vertexShader = material.__webglShader.vertexShader;
    	var fragmentShader = material.__webglShader.fragmentShader;

    	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    	if ( parameters.shadowMapType === PCFShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    	}

    	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

    	if ( parameters.envMap ) {

    		switch ( material.envMap.mapping ) {

    			case CubeReflectionMapping:
    			case CubeRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    				break;

    			case CubeUVReflectionMapping:
    			case CubeUVRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
    				break;

    			case EquirectangularReflectionMapping:
    			case EquirectangularRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
    				break;

    			case SphericalReflectionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
    				break;

    		}

    		switch ( material.envMap.mapping ) {

    			case CubeRefractionMapping:
    			case EquirectangularRefractionMapping:
    				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
    				break;

    		}

    		switch ( material.combine ) {

    			case MultiplyOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
    				break;

    			case MixOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
    				break;

    			case AddOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
    				break;

    		}

    	}

    	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

    	// console.log( 'building new program ' );

    	//

    	var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

    	var customDefines = generateDefines( defines );

    	//

    	var program = gl.createProgram();

    	var prefixVertex, prefixFragment;

    	if ( material.isRawShaderMaterial ) {

    		prefixVertex = [

    			customDefines,

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    		prefixFragment = [

    			customExtensions,
    			customDefines,

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    	} else {

    		prefixVertex = [

    			'precision ' + parameters.precision + ' float;',
    			'precision ' + parameters.precision + ' int;',

    			'#define SHADER_NAME ' + material.__webglShader.name,

    			customDefines,

    			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

    			'#define GAMMA_FACTOR ' + gammaFactorDefine,

    			'#define MAX_BONES ' + parameters.maxBones,

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    			parameters.vertexColors ? '#define USE_COLOR' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.skinning ? '#define USE_SKINNING' : '',
    			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

    			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
    			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			'uniform mat4 modelMatrix;',
    			'uniform mat4 modelViewMatrix;',
    			'uniform mat4 projectionMatrix;',
    			'uniform mat4 viewMatrix;',
    			'uniform mat3 normalMatrix;',
    			'uniform vec3 cameraPosition;',

    			'attribute vec3 position;',
    			'attribute vec3 normal;',
    			'attribute vec2 uv;',

    			'#ifdef USE_COLOR',

    			'	attribute vec3 color;',

    			'#endif',

    			'#ifdef USE_MORPHTARGETS',

    			'	attribute vec3 morphTarget0;',
    			'	attribute vec3 morphTarget1;',
    			'	attribute vec3 morphTarget2;',
    			'	attribute vec3 morphTarget3;',

    			'	#ifdef USE_MORPHNORMALS',

    			'		attribute vec3 morphNormal0;',
    			'		attribute vec3 morphNormal1;',
    			'		attribute vec3 morphNormal2;',
    			'		attribute vec3 morphNormal3;',

    			'	#else',

    			'		attribute vec3 morphTarget4;',
    			'		attribute vec3 morphTarget5;',
    			'		attribute vec3 morphTarget6;',
    			'		attribute vec3 morphTarget7;',

    			'	#endif',

    			'#endif',

    			'#ifdef USE_SKINNING',

    			'	attribute vec4 skinIndex;',
    			'	attribute vec4 skinWeight;',

    			'#endif',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    		prefixFragment = [

    			customExtensions,

    			'precision ' + parameters.precision + ' float;',
    			'precision ' + parameters.precision + ' int;',

    			'#define SHADER_NAME ' + material.__webglShader.name,

    			customDefines,

    			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

    			'#define GAMMA_FACTOR ' + gammaFactorDefine,

    			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
    			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapTypeDefine : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    			parameters.vertexColors ? '#define USE_COLOR' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

    			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

    			'uniform mat4 viewMatrix;',
    			'uniform vec3 cameraPosition;',

    			( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
    			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
    			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

    			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
    			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
    			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
    			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
    			parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

    			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    	}

    	vertexShader = parseIncludes( vertexShader, parameters );
    	vertexShader = replaceLightNums( vertexShader, parameters );

    	fragmentShader = parseIncludes( fragmentShader, parameters );
    	fragmentShader = replaceLightNums( fragmentShader, parameters );

    	if ( ! material.isShaderMaterial ) {

    		vertexShader = unrollLoops( vertexShader );
    		fragmentShader = unrollLoops( fragmentShader );

    	}

    	var vertexGlsl = prefixVertex + vertexShader;
    	var fragmentGlsl = prefixFragment + fragmentShader;

    	// console.log( '*VERTEX*', vertexGlsl );
    	// console.log( '*FRAGMENT*', fragmentGlsl );

    	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
    	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

    	gl.attachShader( program, glVertexShader );
    	gl.attachShader( program, glFragmentShader );

    	// Force a particular attribute to index 0.

    	if ( material.index0AttributeName !== undefined ) {

    		gl.bindAttribLocation( program, 0, material.index0AttributeName );

    	} else if ( parameters.morphTargets === true ) {

    		// programs with morphTargets displace position out of attribute 0
    		gl.bindAttribLocation( program, 0, 'position' );

    	}

    	gl.linkProgram( program );

    	var programLog = gl.getProgramInfoLog( program );
    	var vertexLog = gl.getShaderInfoLog( glVertexShader );
    	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

    	var runnable = true;
    	var haveDiagnostics = true;

    	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
    	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

    	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

    		runnable = false;

    		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

    	} else if ( programLog !== '' ) {

    		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

    	} else if ( vertexLog === '' || fragmentLog === '' ) {

    		haveDiagnostics = false;

    	}

    	if ( haveDiagnostics ) {

    		this.diagnostics = {

    			runnable: runnable,
    			material: material,

    			programLog: programLog,

    			vertexShader: {

    				log: vertexLog,
    				prefix: prefixVertex

    			},

    			fragmentShader: {

    				log: fragmentLog,
    				prefix: prefixFragment

    			}

    		};

    	}

    	// clean up

    	gl.deleteShader( glVertexShader );
    	gl.deleteShader( glFragmentShader );

    	// set up caching for uniform locations

    	var cachedUniforms;

    	this.getUniforms = function() {

    		if ( cachedUniforms === undefined ) {

    			cachedUniforms =
    					new WebGLUniforms( gl, program, renderer );

    		}

    		return cachedUniforms;

    	};

    	// set up caching for attribute locations

    	var cachedAttributes;

    	this.getAttributes = function() {

    		if ( cachedAttributes === undefined ) {

    			cachedAttributes = fetchAttributeLocations( gl, program );

    		}

    		return cachedAttributes;

    	};

    	// free resource

    	this.destroy = function() {

    		gl.deleteProgram( program );
    		this.program = undefined;

    	};

    	// DEPRECATED

    	Object.defineProperties( this, {

    		uniforms: {
    			get: function() {

    				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
    				return this.getUniforms();

    			}
    		},

    		attributes: {
    			get: function() {

    				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
    				return this.getAttributes();

    			}
    		}

    	} );


    	//

    	this.id = programIdCount ++;
    	this.code = code;
    	this.usedTimes = 1;
    	this.program = program;
    	this.vertexShader = glVertexShader;
    	this.fragmentShader = glFragmentShader;

    	return this;

    }

    function WebGLPrograms( renderer, capabilities ) {

    	var programs = [];

    	var shaderIDs = {
    		MeshDepthMaterial: 'depth',
    		MeshNormalMaterial: 'normal',
    		MeshBasicMaterial: 'basic',
    		MeshLambertMaterial: 'lambert',
    		MeshPhongMaterial: 'phong',
    		MeshStandardMaterial: 'physical',
    		MeshPhysicalMaterial: 'physical',
    		LineBasicMaterial: 'basic',
    		LineDashedMaterial: 'dashed',
    		PointsMaterial: 'points'
    	};

    	var parameterNames = [
    		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
    		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
    		"roughnessMap", "metalnessMap",
    		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
    		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
    		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
    		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
    		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
    		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
    		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"
    	];


    	function allocateBones( object ) {

    		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

    			return 1024;

    		} else {

    			// default for when object is not specified
    			// ( for example when prebuilding shader to be used with multiple objects )
    			//
    			//  - leave some extra space for other uniforms
    			//  - limit here is ANGLE's 254 max uniform vectors
    			//    (up to 54 should be safe)

    			var nVertexUniforms = capabilities.maxVertexUniforms;
    			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

    			var maxBones = nVertexMatrices;

    			if ( object !== undefined && (object && object.isSkinnedMesh) ) {

    				maxBones = Math.min( object.skeleton.bones.length, maxBones );

    				if ( maxBones < object.skeleton.bones.length ) {

    					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

    				}

    			}

    			return maxBones;

    		}

    	}

    	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

    		var encoding;

    		if ( ! map ) {

    			encoding = LinearEncoding;

    		} else if ( (map && map.isTexture) ) {

    			encoding = map.encoding;

    		} else if ( (map && map.isWebGLRenderTarget) ) {

    			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
    			encoding = map.texture.encoding;

    		}

    		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
    		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

    			encoding = GammaEncoding;

    		}

    		return encoding;

    	}

    	this.getParameters = function ( material, lights, fog, nClipPlanes, object ) {

    		var shaderID = shaderIDs[ material.type ];

    		// heuristics to create shader parameters according to lights in the scene
    		// (not to blow over maxLights budget)

    		var maxBones = allocateBones( object );
    		var precision = renderer.getPrecision();

    		if ( material.precision !== null ) {

    			precision = capabilities.getMaxPrecision( material.precision );

    			if ( precision !== material.precision ) {

    				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

    			}

    		}

    		var currentRenderTarget = renderer.getCurrentRenderTarget();

    		var parameters = {

    			shaderID: shaderID,

    			precision: precision,
    			supportsVertexTextures: capabilities.vertexTextures,
    			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
    			map: !! material.map,
    			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
    			envMap: !! material.envMap,
    			envMapMode: material.envMap && material.envMap.mapping,
    			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
    			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
    			lightMap: !! material.lightMap,
    			aoMap: !! material.aoMap,
    			emissiveMap: !! material.emissiveMap,
    			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
    			bumpMap: !! material.bumpMap,
    			normalMap: !! material.normalMap,
    			displacementMap: !! material.displacementMap,
    			roughnessMap: !! material.roughnessMap,
    			metalnessMap: !! material.metalnessMap,
    			specularMap: !! material.specularMap,
    			alphaMap: !! material.alphaMap,

    			combine: material.combine,

    			vertexColors: material.vertexColors,

    			fog: !! fog,
    			useFog: material.fog,
    			fogExp: (fog && fog.isFogExp2),

    			flatShading: material.shading === FlatShading,

    			sizeAttenuation: material.sizeAttenuation,
    			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

    			skinning: material.skinning,
    			maxBones: maxBones,
    			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

    			morphTargets: material.morphTargets,
    			morphNormals: material.morphNormals,
    			maxMorphTargets: renderer.maxMorphTargets,
    			maxMorphNormals: renderer.maxMorphNormals,

    			numDirLights: lights.directional.length,
    			numPointLights: lights.point.length,
    			numSpotLights: lights.spot.length,
    			numHemiLights: lights.hemi.length,

    			numClippingPlanes: nClipPlanes,

    			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
    			shadowMapType: renderer.shadowMap.type,

    			toneMapping: renderer.toneMapping,
    			physicallyCorrectLights: renderer.physicallyCorrectLights,

    			premultipliedAlpha: material.premultipliedAlpha,

    			alphaTest: material.alphaTest,
    			doubleSided: material.side === DoubleSide,
    			flipSided: material.side === BackSide,

    			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

    		};

    		return parameters;

    	};

    	this.getProgramCode = function ( material, parameters ) {

    		var array = [];

    		if ( parameters.shaderID ) {

    			array.push( parameters.shaderID );

    		} else {

    			array.push( material.fragmentShader );
    			array.push( material.vertexShader );

    		}

    		if ( material.defines !== undefined ) {

    			for ( var name in material.defines ) {

    				array.push( name );
    				array.push( material.defines[ name ] );

    			}

    		}

    		for ( var i = 0; i < parameterNames.length; i ++ ) {

    			array.push( parameters[ parameterNames[ i ] ] );

    		}

    		return array.join();

    	};

    	this.acquireProgram = function ( material, parameters, code ) {

    		var program;

    		// Check if code has been already compiled
    		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

    			var programInfo = programs[ p ];

    			if ( programInfo.code === code ) {

    				program = programInfo;
    				++ program.usedTimes;

    				break;

    			}

    		}

    		if ( program === undefined ) {

    			program = new WebGLProgram( renderer, code, material, parameters );
    			programs.push( program );

    		}

    		return program;

    	};

    	this.releaseProgram = function( program ) {

    		if ( -- program.usedTimes === 0 ) {

    			// Remove from unordered set
    			var i = programs.indexOf( program );
    			programs[ i ] = programs[ programs.length - 1 ];
    			programs.pop();

    			// Free WebGL resources
    			program.destroy();

    		}

    	};

    	// Exposed for resource monitoring & error feedback via renderer.info:
    	this.programs = programs;

    }

    function WebGLGeometries( gl, properties, info ) {

    	var geometries = {};

    	function onGeometryDispose( event ) {

    		var geometry = event.target;
    		var buffergeometry = geometries[ geometry.id ];

    		if ( buffergeometry.index !== null ) {

    			deleteAttribute( buffergeometry.index );

    		}

    		deleteAttributes( buffergeometry.attributes );

    		geometry.removeEventListener( 'dispose', onGeometryDispose );

    		delete geometries[ geometry.id ];

    		// TODO

    		var property = properties.get( geometry );

    		if ( property.wireframe ) {

    			deleteAttribute( property.wireframe );

    		}

    		properties.delete( geometry );

    		var bufferproperty = properties.get( buffergeometry );

    		if ( bufferproperty.wireframe ) {

    			deleteAttribute( bufferproperty.wireframe );

    		}

    		properties.delete( buffergeometry );

    		//

    		info.memory.geometries --;

    	}

    	function getAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			return properties.get( attribute.data ).__webglBuffer;

    		}

    		return properties.get( attribute ).__webglBuffer;

    	}

    	function deleteAttribute( attribute ) {

    		var buffer = getAttributeBuffer( attribute );

    		if ( buffer !== undefined ) {

    			gl.deleteBuffer( buffer );
    			removeAttributeBuffer( attribute );

    		}

    	}

    	function deleteAttributes( attributes ) {

    		for ( var name in attributes ) {

    			deleteAttribute( attributes[ name ] );

    		}

    	}

    	function removeAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			properties.delete( attribute.data );

    		} else {

    			properties.delete( attribute );

    		}

    	}

    	return {

    		get: function ( object ) {

    			var geometry = object.geometry;

    			if ( geometries[ geometry.id ] !== undefined ) {

    				return geometries[ geometry.id ];

    			}

    			geometry.addEventListener( 'dispose', onGeometryDispose );

    			var buffergeometry;

    			if ( geometry.isBufferGeometry ) {

    				buffergeometry = geometry;

    			} else if ( geometry.isGeometry ) {

    				if ( geometry._bufferGeometry === undefined ) {

    					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

    				}

    				buffergeometry = geometry._bufferGeometry;

    			}

    			geometries[ geometry.id ] = buffergeometry;

    			info.memory.geometries ++;

    			return buffergeometry;

    		}

    	};

    }

    function WebGLObjects( gl, properties, info ) {

    	var geometries = new WebGLGeometries( gl, properties, info );

    	//

    	function update( object ) {

    		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

    		var geometry = geometries.get( object );

    		if ( object.geometry.isGeometry ) {

    			geometry.updateFromObject( object );

    		}

    		var index = geometry.index;
    		var attributes = geometry.attributes;

    		if ( index !== null ) {

    			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

    		}

    		for ( var name in attributes ) {

    			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

    		}

    		// morph targets

    		var morphAttributes = geometry.morphAttributes;

    		for ( var name in morphAttributes ) {

    			var array = morphAttributes[ name ];

    			for ( var i = 0, l = array.length; i < l; i ++ ) {

    				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

    			}

    		}

    		return geometry;

    	}

    	function updateAttribute( attribute, bufferType ) {

    		var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;

    		var attributeProperties = properties.get( data );

    		if ( attributeProperties.__webglBuffer === undefined ) {

    			createBuffer( attributeProperties, data, bufferType );

    		} else if ( attributeProperties.version !== data.version ) {

    			updateBuffer( attributeProperties, data, bufferType );

    		}

    	}

    	function createBuffer( attributeProperties, data, bufferType ) {

    		attributeProperties.__webglBuffer = gl.createBuffer();
    		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

    		gl.bufferData( bufferType, data.array, usage );

    		attributeProperties.version = data.version;

    	}

    	function updateBuffer( attributeProperties, data, bufferType ) {

    		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    		if ( data.dynamic === false || data.updateRange.count === - 1 ) {

    			// Not using update ranges

    			gl.bufferSubData( bufferType, 0, data.array );

    		} else if ( data.updateRange.count === 0 ) {

    			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

    		} else {

    			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
    							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

    			data.updateRange.count = 0; // reset range

    		}

    		attributeProperties.version = data.version;

    	}

    	function getAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			return properties.get( attribute.data ).__webglBuffer;

    		}

    		return properties.get( attribute ).__webglBuffer;

    	}

    	function getWireframeAttribute( geometry ) {

    		var property = properties.get( geometry );

    		if ( property.wireframe !== undefined ) {

    			return property.wireframe;

    		}

    		var indices = [];

    		var index = geometry.index;
    		var attributes = geometry.attributes;
    		var position = attributes.position;

    		// console.time( 'wireframe' );

    		if ( index !== null ) {

    			var edges = {};
    			var array = index.array;

    			for ( var i = 0, l = array.length; i < l; i += 3 ) {

    				var a = array[ i + 0 ];
    				var b = array[ i + 1 ];
    				var c = array[ i + 2 ];

    				indices.push( a, b, b, c, c, a );

    			}

    		} else {

    			var array = attributes.position.array;

    			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

    				var a = i + 0;
    				var b = i + 1;
    				var c = i + 2;

    				indices.push( a, b, b, c, c, a );

    			}

    		}

    		// console.timeEnd( 'wireframe' );

    		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
    		var attribute = new BufferAttribute( new TypeArray( indices ), 1 );

    		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

    		property.wireframe = attribute;

    		return attribute;

    	}

    	return {

    		getAttributeBuffer: getAttributeBuffer,
    		getWireframeAttribute: getWireframeAttribute,

    		update: update

    	};

    }

    function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

    	var _infoMemory = info.memory;
    	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

    	//

    	function clampToMaxSize( image, maxSize ) {

    		if ( image.width > maxSize || image.height > maxSize ) {

    			// Warning: Scaling through the canvas will only work with images that use
    			// premultiplied alpha.

    			var scale = maxSize / Math.max( image.width, image.height );

    			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    			canvas.width = Math.floor( image.width * scale );
    			canvas.height = Math.floor( image.height * scale );

    			var context = canvas.getContext( '2d' );
    			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

    			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

    			return canvas;

    		}

    		return image;

    	}

    	function isPowerOfTwo( image ) {

    		return exports.Math.isPowerOfTwo( image.width ) && exports.Math.isPowerOfTwo( image.height );

    	}

    	function makePowerOfTwo( image ) {

    		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

    			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    			canvas.width = exports.Math.nearestPowerOfTwo( image.width );
    			canvas.height = exports.Math.nearestPowerOfTwo( image.height );

    			var context = canvas.getContext( '2d' );
    			context.drawImage( image, 0, 0, canvas.width, canvas.height );

    			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

    			return canvas;

    		}

    		return image;

    	}

    	function textureNeedsPowerOfTwo( texture ) {

    		if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;
    		if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;

    		return false;

    	}

    	// Fallback filters for non-power-of-2 textures

    	function filterFallback( f ) {

    		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

    			return _gl.NEAREST;

    		}

    		return _gl.LINEAR;

    	}

    	//

    	function onTextureDispose( event ) {

    		var texture = event.target;

    		texture.removeEventListener( 'dispose', onTextureDispose );

    		deallocateTexture( texture );

    		_infoMemory.textures --;


    	}

    	function onRenderTargetDispose( event ) {

    		var renderTarget = event.target;

    		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    		deallocateRenderTarget( renderTarget );

    		_infoMemory.textures --;

    	}

    	//

    	function deallocateTexture( texture ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.image && textureProperties.__image__webglTextureCube ) {

    			// cube texture

    			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

    		} else {

    			// 2D texture

    			if ( textureProperties.__webglInit === undefined ) return;

    			_gl.deleteTexture( textureProperties.__webglTexture );

    		}

    		// remove all webgl properties
    		properties.delete( texture );

    	}

    	function deallocateRenderTarget( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );
    		var textureProperties = properties.get( renderTarget.texture );

    		if ( ! renderTarget ) return;

    		if ( textureProperties.__webglTexture !== undefined ) {

    			_gl.deleteTexture( textureProperties.__webglTexture );

    		}

    		if ( renderTarget.depthTexture ) {

    			renderTarget.depthTexture.dispose();

    		}

    		if ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {

    			for ( var i = 0; i < 6; i ++ ) {

    				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
    				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

    			}

    		} else {

    			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
    			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

    		}

    		properties.delete( renderTarget.texture );
    		properties.delete( renderTarget );

    	}

    	//



    	function setTexture2D( texture, slot ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    			var image = texture.image;

    			if ( image === undefined ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

    			} else if ( image.complete === false ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

    			} else {

    				uploadTexture( textureProperties, texture, slot );
    				return;

    			}

    		}

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    	}

    	function setTextureCube( texture, slot ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.image.length === 6 ) {

    			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    				if ( ! textureProperties.__image__webglTextureCube ) {

    					texture.addEventListener( 'dispose', onTextureDispose );

    					textureProperties.__image__webglTextureCube = _gl.createTexture();

    					_infoMemory.textures ++;

    				}

    				state.activeTexture( _gl.TEXTURE0 + slot );
    				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

    				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

    				var isCompressed = (texture && texture.isCompressedTexture);
    				var isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);

    				var cubeImage = [];

    				for ( var i = 0; i < 6; i ++ ) {

    					if ( ! isCompressed && ! isDataTexture ) {

    						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

    					} else {

    						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

    					}

    				}

    				var image = cubeImage[ 0 ],
    				isPowerOfTwoImage = isPowerOfTwo( image ),
    				glFormat = paramThreeToGL( texture.format ),
    				glType = paramThreeToGL( texture.type );

    				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

    				for ( var i = 0; i < 6; i ++ ) {

    					if ( ! isCompressed ) {

    						if ( isDataTexture ) {

    							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

    						} else {

    							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

    						}

    					} else {

    						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

    						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

    							mipmap = mipmaps[ j ];

    							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

    								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

    									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    								} else {

    									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

    								}

    							} else {

    								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    							}

    						}

    					}

    				}

    				if ( texture.generateMipmaps && isPowerOfTwoImage ) {

    					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

    				}

    				textureProperties.__version = texture.version;

    				if ( texture.onUpdate ) texture.onUpdate( texture );

    			} else {

    				state.activeTexture( _gl.TEXTURE0 + slot );
    				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

    			}

    		}

    	}

    	function setTextureCubeDynamic( texture, slot ) {

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    	}

    	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

    		var extension;

    		if ( isPowerOfTwoImage ) {

    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

    			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

    		} else {

    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

    			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

    			}

    			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

    			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

    			}

    		}

    		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    		if ( extension ) {

    			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
    			if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

    			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

    				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
    				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

    			}

    		}

    	}

    	function uploadTexture( textureProperties, texture, slot ) {

    		if ( textureProperties.__webglInit === undefined ) {

    			textureProperties.__webglInit = true;

    			texture.addEventListener( 'dispose', onTextureDispose );

    			textureProperties.__webglTexture = _gl.createTexture();

    			_infoMemory.textures ++;

    		}

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
    		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
    		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

    		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

    		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

    			image = makePowerOfTwo( image );

    		}

    		var isPowerOfTwoImage = isPowerOfTwo( image ),
    		glFormat = paramThreeToGL( texture.format ),
    		glType = paramThreeToGL( texture.type );

    		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

    		var mipmap, mipmaps = texture.mipmaps;

    		if ( (texture && texture.isDepthTexture) ) {

    			// populate depth texture with dummy data

    			var internalFormat = _gl.DEPTH_COMPONENT;

    			if ( texture.type === FloatType ) {

    				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
    				internalFormat = _gl.DEPTH_COMPONENT32F;

    			} else if ( _isWebGL2 ) {

    				// WebGL 2.0 requires signed internalformat for glTexImage2D
    				internalFormat = _gl.DEPTH_COMPONENT16;

    			}

    			// Depth stencil textures need the DEPTH_STENCIL internal format
    			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    			if ( texture.format === DepthStencilFormat ) {

    				internalFormat = _gl.DEPTH_STENCIL;

    			}

    			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

    		} else if ( (texture && texture.isDataTexture) ) {

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

    				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];
    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    				texture.generateMipmaps = false;

    			} else {

    				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

    			}

    		} else if ( (texture && texture.isCompressedTexture) ) {

    			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    				mipmap = mipmaps[ i ];

    				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

    					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

    						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    					} else {

    						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

    					}

    				} else {

    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    			}

    		} else {

    			// regular Texture (image, video, canvas)

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

    				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];
    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

    				}

    				texture.generateMipmaps = false;

    			} else {

    				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

    			}

    		}

    		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

    		textureProperties.__version = texture.version;

    		if ( texture.onUpdate ) texture.onUpdate( texture );

    	}

    	// Render targets

    	// Setup storage for target texture and bind it to correct framebuffer
    	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

    		var glFormat = paramThreeToGL( renderTarget.texture.format );
    		var glType = paramThreeToGL( renderTarget.texture.type );
    		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    	}

    	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    	function setupRenderBufferStorage( renderbuffer, renderTarget ) {

    		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

    		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
    			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
    			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    		} else {

    			// FIXME: We don't support !depth !stencil
    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

    		}

    		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

    	}

    	// Setup resources for a Depth Texture for a FBO (needs an extension)
    	function setupDepthTexture( framebuffer, renderTarget ) {

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
    		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

    		if ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {

    			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

    		}

    		// upload an empty depth texture with framebuffer size
    		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
    				renderTarget.depthTexture.image.width !== renderTarget.width ||
    				renderTarget.depthTexture.image.height !== renderTarget.height ) {
    			renderTarget.depthTexture.image.width = renderTarget.width;
    			renderTarget.depthTexture.image.height = renderTarget.height;
    			renderTarget.depthTexture.needsUpdate = true;
    		}

    		setTexture2D( renderTarget.depthTexture, 0 );

    		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

    		if ( renderTarget.depthTexture.format === DepthFormat ) {

    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

    		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

    		} else {

    			throw new Error('Unknown depthTexture format')

    		}

    	}

    	// Setup GL resources for a non-texture depth buffer
    	function setupDepthRenderbuffer( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );

    		if ( renderTarget.depthTexture ) {

    			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

    			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

    		} else {

    			if ( isCube ) {

    				renderTargetProperties.__webglDepthbuffer = [];

    				for ( var i = 0; i < 6; i ++ ) {

    					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
    					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
    					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

    				}

    			} else {

    				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
    				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
    				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

    			}

    		}

    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    	}

    	// Set up GL resources for the render target
    	function setupRenderTarget( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );
    		var textureProperties = properties.get( renderTarget.texture );

    		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

    		textureProperties.__webglTexture = _gl.createTexture();

    		_infoMemory.textures ++;

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
    		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

    		// Setup framebuffer

    		if ( isCube ) {

    			renderTargetProperties.__webglFramebuffer = [];

    			for ( var i = 0; i < 6; i ++ ) {

    				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

    			}

    		} else {

    			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

    		}

    		// Setup color buffer

    		if ( isCube ) {

    			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
    			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

    			for ( var i = 0; i < 6; i ++ ) {

    				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

    			}

    			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
    			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

    		} else {

    			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
    			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
    			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

    			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
    			state.bindTexture( _gl.TEXTURE_2D, null );

    		}

    		// Setup depth and stencil buffers

    		if ( renderTarget.depthBuffer ) {

    			setupDepthRenderbuffer( renderTarget );

    		}

    	}

    	function updateRenderTargetMipmap( renderTarget ) {

    		var texture = renderTarget.texture;

    		if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
    				texture.minFilter !== NearestFilter &&
    				texture.minFilter !== LinearFilter ) {

    			var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
    			var webglTexture = properties.get( texture ).__webglTexture;

    			state.bindTexture( target, webglTexture );
    			_gl.generateMipmap( target );
    			state.bindTexture( target, null );

    		}

    	}

    	this.setTexture2D = setTexture2D;
    	this.setTextureCube = setTextureCube;
    	this.setTextureCubeDynamic = setTextureCubeDynamic;
    	this.setupRenderTarget = setupRenderTarget;
    	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

    }

    /**
     * @author fordacious / fordacious.github.io
     */

    function WebGLProperties() {

    	var properties = {};

    	return {

    		get: function ( object ) {

    			var uuid = object.uuid;
    			var map = properties[ uuid ];

    			if ( map === undefined ) {

    				map = {};
    				properties[ uuid ] = map;

    			}

    			return map;

    		},

    		delete: function ( object ) {

    			delete properties[ object.uuid ];

    		},

    		clear: function () {

    			properties = {};

    		}

    	};

    }

    function WebGLState( gl, extensions, paramThreeToGL ) {

    	function ColorBuffer() {

    		var locked = false;

    		var color = new Vector4();
    		var currentColorMask = null;
    		var currentColorClear = new Vector4();

    		return {

    			setMask: function ( colorMask ) {

    				if ( currentColorMask !== colorMask && ! locked ) {

    					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
    					currentColorMask = colorMask;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( r, g, b, a ) {

    				color.set( r, g, b, a );

    				if ( currentColorClear.equals( color ) === false ) {

    					gl.clearColor( r, g, b, a );
    					currentColorClear.copy( color );

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentColorMask = null;
    				currentColorClear.set( 0, 0, 0, 1 );

    			}

    		};

    	}

    	function DepthBuffer() {

    		var locked = false;

    		var currentDepthMask = null;
    		var currentDepthFunc = null;
    		var currentDepthClear = null;

    		return {

    			setTest: function ( depthTest ) {

    				if ( depthTest ) {

    					enable( gl.DEPTH_TEST );

    				} else {

    					disable( gl.DEPTH_TEST );

    				}

    			},

    			setMask: function ( depthMask ) {

    				if ( currentDepthMask !== depthMask && ! locked ) {

    					gl.depthMask( depthMask );
    					currentDepthMask = depthMask;

    				}

    			},

    			setFunc: function ( depthFunc ) {

    				if ( currentDepthFunc !== depthFunc ) {

    					if ( depthFunc ) {

    						switch ( depthFunc ) {

    							case NeverDepth:

    								gl.depthFunc( gl.NEVER );
    								break;

    							case AlwaysDepth:

    								gl.depthFunc( gl.ALWAYS );
    								break;

    							case LessDepth:

    								gl.depthFunc( gl.LESS );
    								break;

    							case LessEqualDepth:

    								gl.depthFunc( gl.LEQUAL );
    								break;

    							case EqualDepth:

    								gl.depthFunc( gl.EQUAL );
    								break;

    							case GreaterEqualDepth:

    								gl.depthFunc( gl.GEQUAL );
    								break;

    							case GreaterDepth:

    								gl.depthFunc( gl.GREATER );
    								break;

    							case NotEqualDepth:

    								gl.depthFunc( gl.NOTEQUAL );
    								break;

    							default:

    								gl.depthFunc( gl.LEQUAL );

    						}

    					} else {

    						gl.depthFunc( gl.LEQUAL );

    					}

    					currentDepthFunc = depthFunc;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( depth ) {

    				if ( currentDepthClear !== depth ) {

    					gl.clearDepth( depth );
    					currentDepthClear = depth;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentDepthMask = null;
    				currentDepthFunc = null;
    				currentDepthClear = null;

    			}

    		};

    	}

    	function StencilBuffer() {

    		var locked = false;

    		var currentStencilMask = null;
    		var currentStencilFunc = null;
    		var currentStencilRef = null;
    		var currentStencilFuncMask = null;
    		var currentStencilFail  = null;
    		var currentStencilZFail = null;
    		var currentStencilZPass = null;
    		var currentStencilClear = null;

    		return {

    			setTest: function ( stencilTest ) {

    				if ( stencilTest ) {

    					enable( gl.STENCIL_TEST );

    				} else {

    					disable( gl.STENCIL_TEST );

    				}

    			},

    			setMask: function ( stencilMask ) {

    				if ( currentStencilMask !== stencilMask && ! locked ) {

    					gl.stencilMask( stencilMask );
    					currentStencilMask = stencilMask;

    				}

    			},

    			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

    				if ( currentStencilFunc !== stencilFunc ||
    				     currentStencilRef 	!== stencilRef 	||
    				     currentStencilFuncMask !== stencilMask ) {

    					gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );

    					currentStencilFunc = stencilFunc;
    					currentStencilRef  = stencilRef;
    					currentStencilFuncMask = stencilMask;

    				}

    			},

    			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

    				if ( currentStencilFail	 !== stencilFail 	||
    				     currentStencilZFail !== stencilZFail ||
    				     currentStencilZPass !== stencilZPass ) {

    					gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );

    					currentStencilFail  = stencilFail;
    					currentStencilZFail = stencilZFail;
    					currentStencilZPass = stencilZPass;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( stencil ) {

    				if ( currentStencilClear !== stencil ) {

    					gl.clearStencil( stencil );
    					currentStencilClear = stencil;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentStencilMask = null;
    				currentStencilFunc = null;
    				currentStencilRef = null;
    				currentStencilFuncMask = null;
    				currentStencilFail = null;
    				currentStencilZFail = null;
    				currentStencilZPass = null;
    				currentStencilClear = null;

    			}

    		};

    	}

    	//

    	var colorBuffer = new ColorBuffer();
    	var depthBuffer = new DepthBuffer();
    	var stencilBuffer = new StencilBuffer();

    	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    	var newAttributes = new Uint8Array( maxVertexAttributes );
    	var enabledAttributes = new Uint8Array( maxVertexAttributes );
    	var attributeDivisors = new Uint8Array( maxVertexAttributes );

    	var capabilities = {};

    	var compressedTextureFormats = null;

    	var currentBlending = null;
    	var currentBlendEquation = null;
    	var currentBlendSrc = null;
    	var currentBlendDst = null;
    	var currentBlendEquationAlpha = null;
    	var currentBlendSrcAlpha = null;
    	var currentBlendDstAlpha = null;
    	var currentPremultipledAlpha = false;

    	var currentFlipSided = null;
    	var currentCullFace = null;

    	var currentLineWidth = null;

    	var currentPolygonOffsetFactor = null;
    	var currentPolygonOffsetUnits = null;

    	var currentScissorTest = null;

    	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

    	var currentTextureSlot = null;
    	var currentBoundTextures = {};

    	var currentScissor = new Vector4();
    	var currentViewport = new Vector4();

    	function createTexture( type, target, count ) {

    		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
    		var texture = gl.createTexture();

    		gl.bindTexture( type, texture );
    		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
    		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

    		for ( var i = 0; i < count; i ++ ) {

    			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

    		}

    		return texture;

    	}

    	var emptyTextures = {};
    	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
    	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

    	//

    	function init() {

    		clearColor( 0, 0, 0, 1 );
    		clearDepth( 1 );
    		clearStencil( 0 );

    		enable( gl.DEPTH_TEST );
    		setDepthFunc( LessEqualDepth );

    		setFlipSided( false );
    		setCullFace( CullFaceBack );
    		enable( gl.CULL_FACE );

    		enable( gl.BLEND );
    		setBlending( NormalBlending );

    	}

    	function initAttributes() {

    		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

    			newAttributes[ i ] = 0;

    		}

    	}

    	function enableAttribute( attribute ) {

    		newAttributes[ attribute ] = 1;

    		if ( enabledAttributes[ attribute ] === 0 ) {

    			gl.enableVertexAttribArray( attribute );
    			enabledAttributes[ attribute ] = 1;

    		}

    		if ( attributeDivisors[ attribute ] !== 0 ) {

    			var extension = extensions.get( 'ANGLE_instanced_arrays' );

    			extension.vertexAttribDivisorANGLE( attribute, 0 );
    			attributeDivisors[ attribute ] = 0;

    		}

    	}

    	function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {

    		newAttributes[ attribute ] = 1;

    		if ( enabledAttributes[ attribute ] === 0 ) {

    			gl.enableVertexAttribArray( attribute );
    			enabledAttributes[ attribute ] = 1;

    		}

    		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

    			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
    			attributeDivisors[ attribute ] = meshPerAttribute;

    		}

    	}

    	function disableUnusedAttributes() {

    		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

    			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

    				gl.disableVertexAttribArray( i );
    				enabledAttributes[ i ] = 0;

    			}

    		}

    	}

    	function enable( id ) {

    		if ( capabilities[ id ] !== true ) {

    			gl.enable( id );
    			capabilities[ id ] = true;

    		}

    	}

    	function disable( id ) {

    		if ( capabilities[ id ] !== false ) {

    			gl.disable( id );
    			capabilities[ id ] = false;

    		}

    	}

    	function getCompressedTextureFormats() {

    		if ( compressedTextureFormats === null ) {

    			compressedTextureFormats = [];

    			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
    			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
    			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

    				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

    				for ( var i = 0; i < formats.length; i ++ ) {

    					compressedTextureFormats.push( formats[ i ] );

    				}

    			}

    		}

    		return compressedTextureFormats;

    	}

    	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

    		if ( blending !== NoBlending ) {

    			enable( gl.BLEND );

    		} else {

    			disable( gl.BLEND );
    			currentBlending = blending; // no blending, that is
    			return;

    		}

    		if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

    			if ( blending === AdditiveBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

    				}

    			} else if ( blending === SubtractiveBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

    				}

    			} else if ( blending === MultiplyBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

    				}

    			} else {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

    				} else {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

    				}

    			}

    			currentBlending = blending;
    			currentPremultipledAlpha = premultipliedAlpha;

    		}

    		if ( blending === CustomBlending ) {

    			blendEquationAlpha = blendEquationAlpha || blendEquation;
    			blendSrcAlpha = blendSrcAlpha || blendSrc;
    			blendDstAlpha = blendDstAlpha || blendDst;

    			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

    				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

    				currentBlendEquation = blendEquation;
    				currentBlendEquationAlpha = blendEquationAlpha;

    			}

    			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

    				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

    				currentBlendSrc = blendSrc;
    				currentBlendDst = blendDst;
    				currentBlendSrcAlpha = blendSrcAlpha;
    				currentBlendDstAlpha = blendDstAlpha;

    			}

    		} else {

    			currentBlendEquation = null;
    			currentBlendSrc = null;
    			currentBlendDst = null;
    			currentBlendEquationAlpha = null;
    			currentBlendSrcAlpha = null;
    			currentBlendDstAlpha = null;

    		}

    	}

    	// TODO Deprecate

    	function setColorWrite( colorWrite ) {

    		colorBuffer.setMask( colorWrite );

    	}

    	function setDepthTest( depthTest ) {

    		depthBuffer.setTest( depthTest );

    	}

    	function setDepthWrite( depthWrite ) {

    		depthBuffer.setMask( depthWrite );

    	}

    	function setDepthFunc( depthFunc ) {

    		depthBuffer.setFunc( depthFunc );

    	}

    	function setStencilTest( stencilTest ) {

    		stencilBuffer.setTest( stencilTest );

    	}

    	function setStencilWrite( stencilWrite ) {

    		stencilBuffer.setMask( stencilWrite );

    	}

    	function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

    		stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );

    	}

    	function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

    		stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );

    	}

    	//

    	function setFlipSided( flipSided ) {

    		if ( currentFlipSided !== flipSided ) {

    			if ( flipSided ) {

    				gl.frontFace( gl.CW );

    			} else {

    				gl.frontFace( gl.CCW );

    			}

    			currentFlipSided = flipSided;

    		}

    	}

    	function setCullFace( cullFace ) {

    		if ( cullFace !== CullFaceNone ) {

    			enable( gl.CULL_FACE );

    			if ( cullFace !== currentCullFace ) {

    				if ( cullFace === CullFaceBack ) {

    					gl.cullFace( gl.BACK );

    				} else if ( cullFace === CullFaceFront ) {

    					gl.cullFace( gl.FRONT );

    				} else {

    					gl.cullFace( gl.FRONT_AND_BACK );

    				}

    			}

    		} else {

    			disable( gl.CULL_FACE );

    		}

    		currentCullFace = cullFace;

    	}

    	function setLineWidth( width ) {

    		if ( width !== currentLineWidth ) {

    			gl.lineWidth( width );

    			currentLineWidth = width;

    		}

    	}

    	function setPolygonOffset( polygonOffset, factor, units ) {

    		if ( polygonOffset ) {

    			enable( gl.POLYGON_OFFSET_FILL );

    			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

    				gl.polygonOffset( factor, units );

    				currentPolygonOffsetFactor = factor;
    				currentPolygonOffsetUnits = units;

    			}

    		} else {

    			disable( gl.POLYGON_OFFSET_FILL );

    		}

    	}

    	function getScissorTest() {

    		return currentScissorTest;

    	}

    	function setScissorTest( scissorTest ) {

    		currentScissorTest = scissorTest;

    		if ( scissorTest ) {

    			enable( gl.SCISSOR_TEST );

    		} else {

    			disable( gl.SCISSOR_TEST );

    		}

    	}

    	// texture

    	function activeTexture( webglSlot ) {

    		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

    		if ( currentTextureSlot !== webglSlot ) {

    			gl.activeTexture( webglSlot );
    			currentTextureSlot = webglSlot;

    		}

    	}

    	function bindTexture( webglType, webglTexture ) {

    		if ( currentTextureSlot === null ) {

    			activeTexture();

    		}

    		var boundTexture = currentBoundTextures[ currentTextureSlot ];

    		if ( boundTexture === undefined ) {

    			boundTexture = { type: undefined, texture: undefined };
    			currentBoundTextures[ currentTextureSlot ] = boundTexture;

    		}

    		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

    			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

    			boundTexture.type = webglType;
    			boundTexture.texture = webglTexture;

    		}

    	}

    	function compressedTexImage2D() {

    		try {

    			gl.compressedTexImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( error );

    		}

    	}

    	function texImage2D() {

    		try {

    			gl.texImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( error );

    		}

    	}

    	// TODO Deprecate

    	function clearColor( r, g, b, a ) {

    		colorBuffer.setClear( r, g, b, a );

    	}

    	function clearDepth( depth ) {

    		depthBuffer.setClear( depth );

    	}

    	function clearStencil( stencil ) {

    		stencilBuffer.setClear( stencil );

    	}

    	//

    	function scissor( scissor ) {

    		if ( currentScissor.equals( scissor ) === false ) {

    			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
    			currentScissor.copy( scissor );

    		}

    	}

    	function viewport( viewport ) {

    		if ( currentViewport.equals( viewport ) === false ) {

    			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
    			currentViewport.copy( viewport );

    		}

    	}

    	//

    	function reset() {

    		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

    			if ( enabledAttributes[ i ] === 1 ) {

    				gl.disableVertexAttribArray( i );
    				enabledAttributes[ i ] = 0;

    			}

    		}

    		capabilities = {};

    		compressedTextureFormats = null;

    		currentTextureSlot = null;
    		currentBoundTextures = {};

    		currentBlending = null;

    		currentFlipSided = null;
    		currentCullFace = null;

    		colorBuffer.reset();
    		depthBuffer.reset();
    		stencilBuffer.reset();

    	}

    	return {

    		buffers: {
    			color: colorBuffer,
    			depth: depthBuffer,
    			stencil: stencilBuffer
    		},

    		init: init,
    		initAttributes: initAttributes,
    		enableAttribute: enableAttribute,
    		enableAttributeAndDivisor: enableAttributeAndDivisor,
    		disableUnusedAttributes: disableUnusedAttributes,
    		enable: enable,
    		disable: disable,
    		getCompressedTextureFormats: getCompressedTextureFormats,

    		setBlending: setBlending,

    		setColorWrite: setColorWrite,
    		setDepthTest: setDepthTest,
    		setDepthWrite: setDepthWrite,
    		setDepthFunc: setDepthFunc,
    		setStencilTest: setStencilTest,
    		setStencilWrite: setStencilWrite,
    		setStencilFunc: setStencilFunc,
    		setStencilOp: setStencilOp,

    		setFlipSided: setFlipSided,
    		setCullFace: setCullFace,

    		setLineWidth: setLineWidth,
    		setPolygonOffset: setPolygonOffset,

    		getScissorTest: getScissorTest,
    		setScissorTest: setScissorTest,

    		activeTexture: activeTexture,
    		bindTexture: bindTexture,
    		compressedTexImage2D: compressedTexImage2D,
    		texImage2D: texImage2D,

    		clearColor: clearColor,
    		clearDepth: clearDepth,
    		clearStencil: clearStencil,

    		scissor: scissor,
    		viewport: viewport,

    		reset: reset

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLCapabilities( gl, extensions, parameters ) {

    	var maxAnisotropy;

    	function getMaxAnisotropy() {

    		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

    		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    		if ( extension !== null ) {

    			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

    		} else {

    			maxAnisotropy = 0;

    		}

    		return maxAnisotropy;

    	}

    	function getMaxPrecision( precision ) {

    		if ( precision === 'highp' ) {

    			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
    			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

    				return 'highp';

    			}

    			precision = 'mediump';

    		}

    		if ( precision === 'mediump' ) {

    			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
    			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

    				return 'mediump';

    			}

    		}

    		return 'lowp';

    	}

    	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    	var maxPrecision = getMaxPrecision( precision );

    	if ( maxPrecision !== precision ) {

    		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
    		precision = maxPrecision;

    	}

    	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

    	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    	var vertexTextures = maxVertexTextures > 0;
    	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
    	var floatVertexTextures = vertexTextures && floatFragmentTextures;

    	return {

    		getMaxAnisotropy: getMaxAnisotropy,
    		getMaxPrecision: getMaxPrecision,

    		precision: precision,
    		logarithmicDepthBuffer: logarithmicDepthBuffer,

    		maxTextures: maxTextures,
    		maxVertexTextures: maxVertexTextures,
    		maxTextureSize: maxTextureSize,
    		maxCubemapSize: maxCubemapSize,

    		maxAttributes: maxAttributes,
    		maxVertexUniforms: maxVertexUniforms,
    		maxVaryings: maxVaryings,
    		maxFragmentUniforms: maxFragmentUniforms,

    		vertexTextures: vertexTextures,
    		floatFragmentTextures: floatFragmentTextures,
    		floatVertexTextures: floatVertexTextures

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLExtensions( gl ) {

    	var extensions = {};

    	return {

    		get: function ( name ) {

    			if ( extensions[ name ] !== undefined ) {

    				return extensions[ name ];

    			}

    			var extension;

    			switch ( name ) {

    				case 'WEBGL_depth_texture':
    					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
    					break;

    				case 'EXT_texture_filter_anisotropic':
    					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
    					break;

    				case 'WEBGL_compressed_texture_s3tc':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
    					break;

    				case 'WEBGL_compressed_texture_pvrtc':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
    					break;

    				case 'WEBGL_compressed_texture_etc1':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
    					break;

    				default:
    					extension = gl.getExtension( name );

    			}

    			if ( extension === null ) {

    				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    			}

    			extensions[ name ] = extension;

    			return extension;

    		}

    	};

    }

    function WebGLClipping() {

    	var scope = this,

    		globalState = null,
    		numGlobalPlanes = 0,
    		localClippingEnabled = false,
    		renderingShadows = false,

    		plane = new Plane(),
    		viewNormalMatrix = new Matrix3(),

    		uniform = { value: null, needsUpdate: false };

    	this.uniform = uniform;
    	this.numPlanes = 0;

    	this.init = function( planes, enableLocalClipping, camera ) {

    		var enabled =
    			planes.length !== 0 ||
    			enableLocalClipping ||
    			// enable state of previous frame - the clipping code has to
    			// run another frame in order to reset the state:
    			numGlobalPlanes !== 0 ||
    			localClippingEnabled;

    		localClippingEnabled = enableLocalClipping;

    		globalState = projectPlanes( planes, camera, 0 );
    		numGlobalPlanes = planes.length;

    		return enabled;

    	};

    	this.beginShadows = function() {

    		renderingShadows = true;
    		projectPlanes( null );

    	};

    	this.endShadows = function() {

    		renderingShadows = false;
    		resetGlobalState();

    	};

    	this.setState = function( planes, clipShadows, camera, cache, fromCache ) {

    		if ( ! localClippingEnabled ||
    				planes === null || planes.length === 0 ||
    				renderingShadows && ! clipShadows ) {
    			// there's no local clipping

    			if ( renderingShadows ) {
    				// there's no global clipping

    				projectPlanes( null );

    			} else {

    				resetGlobalState();
    			}

    		} else {

    			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
    				lGlobal = nGlobal * 4,

    				dstArray = cache.clippingState || null;

    			uniform.value = dstArray; // ensure unique state

    			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

    			for ( var i = 0; i !== lGlobal; ++ i ) {

    				dstArray[ i ] = globalState[ i ];

    			}

    			cache.clippingState = dstArray;
    			this.numPlanes += nGlobal;

    		}


    	};

    	function resetGlobalState() {

    		if ( uniform.value !== globalState ) {

    			uniform.value = globalState;
    			uniform.needsUpdate = numGlobalPlanes > 0;

    		}

    		scope.numPlanes = numGlobalPlanes;

    	}

    	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

    		var nPlanes = planes !== null ? planes.length : 0,
    			dstArray = null;

    		if ( nPlanes !== 0 ) {

    			dstArray = uniform.value;

    			if ( skipTransform !== true || dstArray === null ) {

    				var flatSize = dstOffset + nPlanes * 4,
    					viewMatrix = camera.matrixWorldInverse;

    				viewNormalMatrix.getNormalMatrix( viewMatrix );

    				if ( dstArray === null || dstArray.length < flatSize ) {

    					dstArray = new Float32Array( flatSize );

    				}

    				for ( var i = 0, i4 = dstOffset;
    									i !== nPlanes; ++ i, i4 += 4 ) {

    					plane.copy( planes[ i ] ).
    							applyMatrix4( viewMatrix, viewNormalMatrix );

    					plane.normal.toArray( dstArray, i4 );
    					dstArray[ i4 + 3 ] = plane.constant;

    				}

    			}

    			uniform.value = dstArray;
    			uniform.needsUpdate = true;

    		}

    		scope.numPlanes = nPlanes;
    		return dstArray;

    	}

    }

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     * @author tschw
     */

    function WebGLRenderer( parameters ) {

    	console.log( 'THREE.WebGLRenderer', REVISION );

    	parameters = parameters || {};

    	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
    	_context = parameters.context !== undefined ? parameters.context : null,

    	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
    	_depth = parameters.depth !== undefined ? parameters.depth : true,
    	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
    	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
    	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
    	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

    	var lights = [];

    	var opaqueObjects = [];
    	var opaqueObjectsLastIndex = - 1;
    	var transparentObjects = [];
    	var transparentObjectsLastIndex = - 1;

    	var morphInfluences = new Float32Array( 8 );

    	var sprites = [];
    	var lensFlares = [];

    	// public properties

    	this.domElement = _canvas;
    	this.context = null;

    	// clearing

    	this.autoClear = true;
    	this.autoClearColor = true;
    	this.autoClearDepth = true;
    	this.autoClearStencil = true;

    	// scene graph

    	this.sortObjects = true;

    	// user-defined clipping

    	this.clippingPlanes = [];
    	this.localClippingEnabled = false;

    	// physically based shading

    	this.gammaFactor = 2.0;	// for backwards compatibility
    	this.gammaInput = false;
    	this.gammaOutput = false;

    	// physical lights

    	this.physicallyCorrectLights = false;

    	// tone mapping

    	this.toneMapping = LinearToneMapping;
    	this.toneMappingExposure = 1.0;
    	this.toneMappingWhitePoint = 1.0;

    	// morphs

    	this.maxMorphTargets = 8;
    	this.maxMorphNormals = 4;

    	// internal properties

    	var _this = this,

    	// internal state cache

    	_currentProgram = null,
    	_currentRenderTarget = null,
    	_currentFramebuffer = null,
    	_currentMaterialId = - 1,
    	_currentGeometryProgram = '',
    	_currentCamera = null,

    	_currentScissor = new Vector4(),
    	_currentScissorTest = null,

    	_currentViewport = new Vector4(),

    	//

    	_usedTextureUnits = 0,

    	//

    	_clearColor = new Color( 0x000000 ),
    	_clearAlpha = 0,

    	_width = _canvas.width,
    	_height = _canvas.height,

    	_pixelRatio = 1,

    	_scissor = new Vector4( 0, 0, _width, _height ),
    	_scissorTest = false,

    	_viewport = new Vector4( 0, 0, _width, _height ),

    	// frustum

    	_frustum = new Frustum(),

    	// clipping

    	_clipping = new WebGLClipping(),
    	_clippingEnabled = false,
    	_localClippingEnabled = false,

    	_sphere = new Sphere(),

    	// camera matrices cache

    	_projScreenMatrix = new Matrix4(),

    	_vector3 = new Vector3(),

    	// light arrays cache

    	_lights = {

    		hash: '',

    		ambient: [ 0, 0, 0 ],
    		directional: [],
    		directionalShadowMap: [],
    		directionalShadowMatrix: [],
    		spot: [],
    		spotShadowMap: [],
    		spotShadowMatrix: [],
    		point: [],
    		pointShadowMap: [],
    		pointShadowMatrix: [],
    		hemi: [],

    		shadows: []

    	},

    	// info

    	_infoRender = {

    		calls: 0,
    		vertices: 0,
    		faces: 0,
    		points: 0

    	};

    	this.info = {

    		render: _infoRender,
    		memory: {

    			geometries: 0,
    			textures: 0

    		},
    		programs: null

    	};


    	// initialize

    	var _gl;

    	try {

    		var attributes = {
    			alpha: _alpha,
    			depth: _depth,
    			stencil: _stencil,
    			antialias: _antialias,
    			premultipliedAlpha: _premultipliedAlpha,
    			preserveDrawingBuffer: _preserveDrawingBuffer
    		};

    		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

    		if ( _gl === null ) {

    			if ( _canvas.getContext( 'webgl' ) !== null ) {

    				throw 'Error creating WebGL context with your selected attributes.';

    			} else {

    				throw 'Error creating WebGL context.';

    			}

    		}

    		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

    		if ( _gl.getShaderPrecisionFormat === undefined ) {

    			_gl.getShaderPrecisionFormat = function () {

    				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

    			};

    		}

    		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

    	} catch ( error ) {

    		console.error( 'THREE.WebGLRenderer: ' + error );

    	}

    	var extensions = new WebGLExtensions( _gl );

    	extensions.get( 'WEBGL_depth_texture' );
    	extensions.get( 'OES_texture_float' );
    	extensions.get( 'OES_texture_float_linear' );
    	extensions.get( 'OES_texture_half_float' );
    	extensions.get( 'OES_texture_half_float_linear' );
    	extensions.get( 'OES_standard_derivatives' );
    	extensions.get( 'ANGLE_instanced_arrays' );

    	if ( extensions.get( 'OES_element_index_uint' ) ) {

    		BufferGeometry.MaxIndex = 4294967296;

    	}

    	var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

    	var state = new WebGLState( _gl, extensions, paramThreeToGL );
    	var properties = new WebGLProperties();
    	var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
    	var objects = new WebGLObjects( _gl, properties, this.info );
    	var programCache = new WebGLPrograms( this, capabilities );
    	var lightCache = new WebGLLights();

    	this.info.programs = programCache.programs;

    	var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
    	var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

    	//

    	var backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
    	var backgroundCamera2 = new PerspectiveCamera();
    	var backgroundPlaneMesh = new Mesh(
    		new PlaneBufferGeometry( 2, 2 ),
    		new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
    	);
    	var backgroundBoxShader = ShaderLib[ 'cube' ];
    	var backgroundBoxMesh = new Mesh(
    		new BoxBufferGeometry( 5, 5, 5 ),
    		new ShaderMaterial( {
    			uniforms: backgroundBoxShader.uniforms,
    			vertexShader: backgroundBoxShader.vertexShader,
    			fragmentShader: backgroundBoxShader.fragmentShader,
    			side: BackSide,
    			depthTest: false,
    			depthWrite: false,
    			fog: false
    		} )
    	);

    	//

    	function getTargetPixelRatio() {

    		return _currentRenderTarget === null ? _pixelRatio : 1;

    	}

    	function glClearColor( r, g, b, a ) {

    		if ( _premultipliedAlpha === true ) {

    			r *= a; g *= a; b *= a;

    		}

    		state.clearColor( r, g, b, a );

    	}

    	function setDefaultGLState() {

    		state.init();

    		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
    		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	}

    	function resetGLState() {

    		_currentProgram = null;
    		_currentCamera = null;

    		_currentGeometryProgram = '';
    		_currentMaterialId = - 1;

    		state.reset();

    	}

    	setDefaultGLState();

    	this.context = _gl;
    	this.capabilities = capabilities;
    	this.extensions = extensions;
    	this.properties = properties;
    	this.state = state;

    	// shadow map

    	var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

    	this.shadowMap = shadowMap;


    	// Plugins

    	var spritePlugin = new SpritePlugin( this, sprites );
    	var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

    	// API

    	this.getContext = function () {

    		return _gl;

    	};

    	this.getContextAttributes = function () {

    		return _gl.getContextAttributes();

    	};

    	this.forceContextLoss = function () {

    		extensions.get( 'WEBGL_lose_context' ).loseContext();

    	};

    	this.getMaxAnisotropy = function () {

    		return capabilities.getMaxAnisotropy();

    	};

    	this.getPrecision = function () {

    		return capabilities.precision;

    	};

    	this.getPixelRatio = function () {

    		return _pixelRatio;

    	};

    	this.setPixelRatio = function ( value ) {

    		if ( value === undefined ) return;

    		_pixelRatio = value;

    		this.setSize( _viewport.z, _viewport.w, false );

    	};

    	this.getSize = function () {

    		return {
    			width: _width,
    			height: _height
    		};

    	};

    	this.setSize = function ( width, height, updateStyle ) {

    		_width = width;
    		_height = height;

    		_canvas.width = width * _pixelRatio;
    		_canvas.height = height * _pixelRatio;

    		if ( updateStyle !== false ) {

    			_canvas.style.width = width + 'px';
    			_canvas.style.height = height + 'px';

    		}

    		this.setViewport( 0, 0, width, height );

    	};

    	this.setViewport = function ( x, y, width, height ) {

    		state.viewport( _viewport.set( x, y, width, height ) );

    	};

    	this.setScissor = function ( x, y, width, height ) {

    		state.scissor( _scissor.set( x, y, width, height ) );

    	};

    	this.setScissorTest = function ( boolean ) {

    		state.setScissorTest( _scissorTest = boolean );

    	};

    	// Clearing

    	this.getClearColor = function () {

    		return _clearColor;

    	};

    	this.setClearColor = function ( color, alpha ) {

    		_clearColor.set( color );

    		_clearAlpha = alpha !== undefined ? alpha : 1;

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	};

    	this.getClearAlpha = function () {

    		return _clearAlpha;

    	};

    	this.setClearAlpha = function ( alpha ) {

    		_clearAlpha = alpha;

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	};

    	this.clear = function ( color, depth, stencil ) {

    		var bits = 0;

    		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
    		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
    		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

    		_gl.clear( bits );

    	};

    	this.clearColor = function () {

    		this.clear( true, false, false );

    	};

    	this.clearDepth = function () {

    		this.clear( false, true, false );

    	};

    	this.clearStencil = function () {

    		this.clear( false, false, true );

    	};

    	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

    		this.setRenderTarget( renderTarget );
    		this.clear( color, depth, stencil );

    	};

    	// Reset

    	this.resetGLState = resetGLState;

    	this.dispose = function() {

    		transparentObjects = [];
    		transparentObjectsLastIndex = -1;
    		opaqueObjects = [];
    		opaqueObjectsLastIndex = -1;

    		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

    	};

    	// Events

    	function onContextLost( event ) {

    		event.preventDefault();

    		resetGLState();
    		setDefaultGLState();

    		properties.clear();

    	}

    	function onMaterialDispose( event ) {

    		var material = event.target;

    		material.removeEventListener( 'dispose', onMaterialDispose );

    		deallocateMaterial( material );

    	}

    	// Buffer deallocation

    	function deallocateMaterial( material ) {

    		releaseMaterialProgramReference( material );

    		properties.delete( material );

    	}


    	function releaseMaterialProgramReference( material ) {

    		var programInfo = properties.get( material ).program;

    		material.program = undefined;

    		if ( programInfo !== undefined ) {

    			programCache.releaseProgram( programInfo );

    		}

    	}

    	// Buffer rendering

    	this.renderBufferImmediate = function ( object, program, material ) {

    		state.initAttributes();

    		var buffers = properties.get( object );

    		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
    		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
    		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
    		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

    		var attributes = program.getAttributes();

    		if ( object.hasPositions ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.position );
    			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasNormals ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

    			if ( ! material.isMeshPhongMaterial &&
    			     ! material.isMeshStandardMaterial &&
    			       material.shading === FlatShading ) {

    				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

    					var array = object.normalArray;

    					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
    					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
    					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

    					array[ i + 0 ] = nx;
    					array[ i + 1 ] = ny;
    					array[ i + 2 ] = nz;

    					array[ i + 3 ] = nx;
    					array[ i + 4 ] = ny;
    					array[ i + 5 ] = nz;

    					array[ i + 6 ] = nx;
    					array[ i + 7 ] = ny;
    					array[ i + 8 ] = nz;

    				}

    			}

    			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.normal );

    			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasUvs && material.map ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.uv );

    			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasColors && material.vertexColors !== NoColors ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.color );

    			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		state.disableUnusedAttributes();

    		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

    		object.count = 0;

    	};

    	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

    		setMaterial( material );

    		var program = setProgram( camera, fog, material, object );

    		var updateBuffers = false;
    		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

    		if ( geometryProgram !== _currentGeometryProgram ) {

    			_currentGeometryProgram = geometryProgram;
    			updateBuffers = true;

    		}

    		// morph targets

    		var morphTargetInfluences = object.morphTargetInfluences;

    		if ( morphTargetInfluences !== undefined ) {

    			var activeInfluences = [];

    			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

    				var influence = morphTargetInfluences[ i ];
    				activeInfluences.push( [ influence, i ] );

    			}

    			activeInfluences.sort( absNumericalSort );

    			if ( activeInfluences.length > 8 ) {

    				activeInfluences.length = 8;

    			}

    			var morphAttributes = geometry.morphAttributes;

    			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

    				var influence = activeInfluences[ i ];
    				morphInfluences[ i ] = influence[ 0 ];

    				if ( influence[ 0 ] !== 0 ) {

    					var index = influence[ 1 ];

    					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
    					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

    				} else {

    					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
    					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

    				}

    			}

    			for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

    				morphInfluences[ i ] = 0.0;

    			}

    			program.getUniforms().setValue(
    					_gl, 'morphTargetInfluences', morphInfluences );

    			updateBuffers = true;

    		}

    		//

    		var index = geometry.index;
    		var position = geometry.attributes.position;
    		var rangeFactor = 1;

    		if ( material.wireframe === true ) {

    			index = objects.getWireframeAttribute( geometry );
    			rangeFactor = 2;

    		}

    		var renderer;

    		if ( index !== null ) {

    			renderer = indexedBufferRenderer;
    			renderer.setIndex( index );

    		} else {

    			renderer = bufferRenderer;

    		}

    		if ( updateBuffers ) {

    			setupVertexAttributes( material, program, geometry );

    			if ( index !== null ) {

    				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

    			}

    		}

    		//

    		var dataCount = 0;

    		if ( index !== null ) {

    			dataCount = index.count;

    		} else if ( position !== undefined ) {

    			dataCount = position.count;

    		}

    		var rangeStart = geometry.drawRange.start * rangeFactor;
    		var rangeCount = geometry.drawRange.count * rangeFactor;

    		var groupStart = group !== null ? group.start * rangeFactor : 0;
    		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

    		var drawStart = Math.max( rangeStart, groupStart );
    		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

    		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

    		if ( drawCount === 0 ) return;

    		//

    		if ( object.isMesh ) {

    			if ( material.wireframe === true ) {

    				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
    				renderer.setMode( _gl.LINES );

    			} else {

    				switch ( object.drawMode ) {

    					case TrianglesDrawMode:
    						renderer.setMode( _gl.TRIANGLES );
    						break;

    					case TriangleStripDrawMode:
    						renderer.setMode( _gl.TRIANGLE_STRIP );
    						break;

    					case TriangleFanDrawMode:
    						renderer.setMode( _gl.TRIANGLE_FAN );
    						break;

    				}

    			}


    		} else if ( object.isLine ) {

    			var lineWidth = material.linewidth;

    			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

    			state.setLineWidth( lineWidth * getTargetPixelRatio() );

    			if ( object.isLineSegments ) {

    				renderer.setMode( _gl.LINES );

    			} else {

    				renderer.setMode( _gl.LINE_STRIP );

    			}

    		} else if ( object.isPoints ) {

    			renderer.setMode( _gl.POINTS );

    		}

    		if ( geometry && geometry.isInstancedBufferGeometry ) {

    			if ( geometry.maxInstancedCount > 0 ) {

    				renderer.renderInstances( geometry, drawStart, drawCount );

    			}

    		} else {

    			renderer.render( drawStart, drawCount );

    		}

    	};

    	function setupVertexAttributes( material, program, geometry, startIndex ) {

    		var extension;

    		if ( geometry && geometry.isInstancedBufferGeometry ) {

    			extension = extensions.get( 'ANGLE_instanced_arrays' );

    			if ( extension === null ) {

    				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    				return;

    			}

    		}

    		if ( startIndex === undefined ) startIndex = 0;

    		state.initAttributes();

    		var geometryAttributes = geometry.attributes;

    		var programAttributes = program.getAttributes();

    		var materialDefaultAttributeValues = material.defaultAttributeValues;

    		for ( var name in programAttributes ) {

    			var programAttribute = programAttributes[ name ];

    			if ( programAttribute >= 0 ) {

    				var geometryAttribute = geometryAttributes[ name ];

    				if ( geometryAttribute !== undefined ) {

    					var type = _gl.FLOAT;
    					var array = geometryAttribute.array;
    					var normalized = geometryAttribute.normalized;

    					if ( array instanceof Float32Array ) {

    						type = _gl.FLOAT;

    					} else if ( array instanceof Float64Array ) {

    						console.warn( "Unsupported data buffer format: Float64Array" );

    					} else if ( array instanceof Uint16Array ) {

    						type = _gl.UNSIGNED_SHORT;

    					} else if ( array instanceof Int16Array ) {

    						type = _gl.SHORT;

    					} else if ( array instanceof Uint32Array ) {

    						type = _gl.UNSIGNED_INT;

    					} else if ( array instanceof Int32Array ) {

    						type = _gl.INT;

    					} else if ( array instanceof Int8Array ) {

    						type = _gl.BYTE;

    					} else if ( array instanceof Uint8Array ) {

    						type = _gl.UNSIGNED_BYTE;

    					}

    					var size = geometryAttribute.itemSize;
    					var buffer = objects.getAttributeBuffer( geometryAttribute );

    					if ( geometryAttribute && geometryAttribute.isInterleavedBufferAttribute ) {

    						var data = geometryAttribute.data;
    						var stride = data.stride;
    						var offset = geometryAttribute.offset;

    						if ( data && data.isInstancedInterleavedBuffer ) {

    							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

    							if ( geometry.maxInstancedCount === undefined ) {

    								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

    							}

    						} else {

    							state.enableAttribute( programAttribute );

    						}

    						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
    						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

    					} else {

    						if ( geometryAttribute && geometryAttribute.isInstancedBufferAttribute ) {

    							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

    							if ( geometry.maxInstancedCount === undefined ) {

    								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

    							}

    						} else {

    							state.enableAttribute( programAttribute );

    						}

    						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
    						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );

    					}

    				} else if ( materialDefaultAttributeValues !== undefined ) {

    					var value = materialDefaultAttributeValues[ name ];

    					if ( value !== undefined ) {

    						switch ( value.length ) {

    							case 2:
    								_gl.vertexAttrib2fv( programAttribute, value );
    								break;

    							case 3:
    								_gl.vertexAttrib3fv( programAttribute, value );
    								break;

    							case 4:
    								_gl.vertexAttrib4fv( programAttribute, value );
    								break;

    							default:
    								_gl.vertexAttrib1fv( programAttribute, value );

    						}

    					}

    				}

    			}

    		}

    		state.disableUnusedAttributes();

    	}

    	// Sorting

    	function absNumericalSort( a, b ) {

    		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

    	}

    	function painterSortStable( a, b ) {

    		if ( a.object.renderOrder !== b.object.renderOrder ) {

    			return a.object.renderOrder - b.object.renderOrder;

    		} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {

    			return a.material.program.id - b.material.program.id;

    		} else if ( a.material.id !== b.material.id ) {

    			return a.material.id - b.material.id;

    		} else if ( a.z !== b.z ) {

    			return a.z - b.z;

    		} else {

    			return a.id - b.id;

    		}

    	}

    	function reversePainterSortStable( a, b ) {

    		if ( a.object.renderOrder !== b.object.renderOrder ) {

    			return a.object.renderOrder - b.object.renderOrder;

    		} if ( a.z !== b.z ) {

    			return b.z - a.z;

    		} else {

    			return a.id - b.id;

    		}

    	}

    	// Rendering

    	this.render = function ( scene, camera, renderTarget, forceClear ) {

    		if ( camera !== undefined && camera.isCamera !== true ) {

    			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
    			return;

    		}

    		var fog = scene.fog;

    		// reset caching for this frame

    		_currentGeometryProgram = '';
    		_currentMaterialId = - 1;
    		_currentCamera = null;

    		// update scene graph

    		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    		// update camera matrices and frustum

    		if ( camera.parent === null ) camera.updateMatrixWorld();

    		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

    		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    		_frustum.setFromMatrix( _projScreenMatrix );

    		lights.length = 0;

    		opaqueObjectsLastIndex = - 1;
    		transparentObjectsLastIndex = - 1;

    		sprites.length = 0;
    		lensFlares.length = 0;

    		_localClippingEnabled = this.localClippingEnabled;
    		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

    		projectObject( scene, camera );

    		opaqueObjects.length = opaqueObjectsLastIndex + 1;
    		transparentObjects.length = transparentObjectsLastIndex + 1;

    		if ( _this.sortObjects === true ) {

    			opaqueObjects.sort( painterSortStable );
    			transparentObjects.sort( reversePainterSortStable );

    		}

    		//

    		if ( _clippingEnabled ) _clipping.beginShadows();

    		setupShadows( lights );

    		shadowMap.render( scene, camera );

    		setupLights( lights, camera );

    		if ( _clippingEnabled ) _clipping.endShadows();

    		//

    		_infoRender.calls = 0;
    		_infoRender.vertices = 0;
    		_infoRender.faces = 0;
    		_infoRender.points = 0;

    		if ( renderTarget === undefined ) {

    			renderTarget = null;

    		}

    		this.setRenderTarget( renderTarget );

    		//

    		var background = scene.background;

    		if ( background === null ) {

    			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    		} else if ( background && background.isColor ) {

    			glClearColor( background.r, background.g, background.b, 1 );
    			forceClear = true;

    		}

    		if ( this.autoClear || forceClear ) {

    			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

    		}

    		if ( background && background.isCubeTexture ) {

    			backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );

    			backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
    			backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );

    			backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
    			backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

    			objects.update( backgroundBoxMesh );

    			_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

    		} else if ( background && background.isTexture ) {

    			backgroundPlaneMesh.material.map = background;

    			objects.update( backgroundPlaneMesh );

    			_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

    		}

    		//

    		if ( scene.overrideMaterial ) {

    			var overrideMaterial = scene.overrideMaterial;

    			renderObjects( opaqueObjects, camera, fog, overrideMaterial );
    			renderObjects( transparentObjects, camera, fog, overrideMaterial );

    		} else {

    			// opaque pass (front-to-back order)

    			state.setBlending( NoBlending );
    			renderObjects( opaqueObjects, camera, fog );

    			// transparent pass (back-to-front order)

    			renderObjects( transparentObjects, camera, fog );

    		}

    		// custom render plugins (post pass)

    		spritePlugin.render( scene, camera );
    		lensFlarePlugin.render( scene, camera, _currentViewport );

    		// Generate mipmap if we're using any kind of mipmap filtering

    		if ( renderTarget ) {

    			textures.updateRenderTargetMipmap( renderTarget );

    		}

    		// Ensure depth buffer writing is enabled so it can be cleared on next render

    		state.setDepthTest( true );
    		state.setDepthWrite( true );
    		state.setColorWrite( true );

    		// _gl.finish();

    	};

    	function pushRenderItem( object, geometry, material, z, group ) {

    		var array, index;

    		// allocate the next position in the appropriate array

    		if ( material.transparent ) {

    			array = transparentObjects;
    			index = ++ transparentObjectsLastIndex;

    		} else {

    			array = opaqueObjects;
    			index = ++ opaqueObjectsLastIndex;

    		}

    		// recycle existing render item or grow the array

    		var renderItem = array[ index ];

    		if ( renderItem !== undefined ) {

    			renderItem.id = object.id;
    			renderItem.object = object;
    			renderItem.geometry = geometry;
    			renderItem.material = material;
    			renderItem.z = _vector3.z;
    			renderItem.group = group;

    		} else {

    			renderItem = {
    				id: object.id,
    				object: object,
    				geometry: geometry,
    				material: material,
    				z: _vector3.z,
    				group: group
    			};

    			// assert( index === array.length );
    			array.push( renderItem );

    		}

    	}

    	// TODO Duplicated code (Frustum)

    	function isObjectViewable( object ) {

    		var geometry = object.geometry;

    		if ( geometry.boundingSphere === null )
    			geometry.computeBoundingSphere();

    		_sphere.copy( geometry.boundingSphere ).
    			applyMatrix4( object.matrixWorld );

    		return isSphereViewable( _sphere );

    	}

    	function isSpriteViewable( sprite ) {

    		_sphere.center.set( 0, 0, 0 );
    		_sphere.radius = 0.7071067811865476;
    		_sphere.applyMatrix4( sprite.matrixWorld );

    		return isSphereViewable( _sphere );

    	}

    	function isSphereViewable( sphere ) {

    		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

    		var numPlanes = _clipping.numPlanes;

    		if ( numPlanes === 0 ) return true;

    		var planes = _this.clippingPlanes,

    			center = sphere.center,
    			negRad = - sphere.radius,
    			i = 0;

    		do {

    			// out when deeper than radius in the negative halfspace
    			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

    		} while ( ++ i !== numPlanes );

    		return true;

    	}

    	function projectObject( object, camera ) {

    		if ( object.visible === false ) return;

    		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

    		if ( visible ) {

    			if ( object.isLight ) {

    				lights.push( object );

    			} else if ( object.isSprite ) {

    				if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

    					sprites.push( object );

    				}

    			} else if ( object.isLensFlare ) {

    				lensFlares.push( object );

    			} else if ( object.isImmediateRenderObject ) {

    				if ( _this.sortObjects === true ) {

    					_vector3.setFromMatrixPosition( object.matrixWorld );
    					_vector3.applyProjection( _projScreenMatrix );

    				}

    				pushRenderItem( object, null, object.material, _vector3.z, null );

    			} else if ( object.isMesh || object.isLine || object.isPoints ) {

    				if ( object.isSkinnedMesh ) {

    					object.skeleton.update();

    				}

    				if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

    					var material = object.material;

    					if ( material.visible === true ) {

    						if ( _this.sortObjects === true ) {

    							_vector3.setFromMatrixPosition( object.matrixWorld );
    							_vector3.applyProjection( _projScreenMatrix );

    						}

    						var geometry = objects.update( object );

    						if ( material.isMultiMaterial ) {

    							var groups = geometry.groups;
    							var materials = material.materials;

    							for ( var i = 0, l = groups.length; i < l; i ++ ) {

    								var group = groups[ i ];
    								var groupMaterial = materials[ group.materialIndex ];

    								if ( groupMaterial.visible === true ) {

    									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

    								}

    							}

    						} else {

    							pushRenderItem( object, geometry, material, _vector3.z, null );

    						}

    					}

    				}

    			}

    		}

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			projectObject( children[ i ], camera );

    		}

    	}

    	function renderObjects( renderList, camera, fog, overrideMaterial ) {

    		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

    			var renderItem = renderList[ i ];

    			var object = renderItem.object;
    			var geometry = renderItem.geometry;
    			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
    			var group = renderItem.group;

    			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
    			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

    			if ( object.isImmediateRenderObject ) {

    				setMaterial( material );

    				var program = setProgram( camera, fog, material, object );

    				_currentGeometryProgram = '';

    				object.render( function ( object ) {

    					_this.renderBufferImmediate( object, program, material );

    				} );

    			} else {

    				if ( object.onBeforeRender !== null ) object.onBeforeRender();

    				_this.renderBufferDirect( camera, fog, geometry, material, object, group );

    			}

    		}

    	}

    	function initMaterial( material, fog, object ) {

    		var materialProperties = properties.get( material );

    		var parameters = programCache.getParameters(
    				material, _lights, fog, _clipping.numPlanes, object );

    		var code = programCache.getProgramCode( material, parameters );

    		var program = materialProperties.program;
    		var programChange = true;

    		if ( program === undefined ) {

    			// new material
    			material.addEventListener( 'dispose', onMaterialDispose );

    		} else if ( program.code !== code ) {

    			// changed glsl or parameters
    			releaseMaterialProgramReference( material );

    		} else if ( parameters.shaderID !== undefined ) {

    			// same glsl and uniform list
    			return;

    		} else {

    			// only rebuild uniform list
    			programChange = false;

    		}

    		if ( programChange ) {

    			if ( parameters.shaderID ) {

    				var shader = ShaderLib[ parameters.shaderID ];

    				materialProperties.__webglShader = {
    					name: material.type,
    					uniforms: exports.UniformsUtils.clone( shader.uniforms ),
    					vertexShader: shader.vertexShader,
    					fragmentShader: shader.fragmentShader
    				};

    			} else {

    				materialProperties.__webglShader = {
    					name: material.type,
    					uniforms: material.uniforms,
    					vertexShader: material.vertexShader,
    					fragmentShader: material.fragmentShader
    				};

    			}

    			material.__webglShader = materialProperties.__webglShader;

    			program = programCache.acquireProgram( material, parameters, code );

    			materialProperties.program = program;
    			material.program = program;

    		}

    		var attributes = program.getAttributes();

    		if ( material.morphTargets ) {

    			material.numSupportedMorphTargets = 0;

    			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

    				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

    					material.numSupportedMorphTargets ++;

    				}

    			}

    		}

    		if ( material.morphNormals ) {

    			material.numSupportedMorphNormals = 0;

    			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

    				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

    					material.numSupportedMorphNormals ++;

    				}

    			}

    		}

    		var uniforms = materialProperties.__webglShader.uniforms;

    		if ( ! material.isShaderMaterial &&
    		     ! material.isRawShaderMaterial ||
    		       material.clipping === true ) {

    			materialProperties.numClippingPlanes = _clipping.numPlanes;
    			uniforms.clippingPlanes = _clipping.uniform;

    		}

    		materialProperties.fog = fog;

    		// store the light setup it was created for

    		materialProperties.lightsHash = _lights.hash;

    		if ( material.lights ) {

    			// wire up the material to this renderer's lighting state

    			uniforms.ambientLightColor.value = _lights.ambient;
    			uniforms.directionalLights.value = _lights.directional;
    			uniforms.spotLights.value = _lights.spot;
    			uniforms.pointLights.value = _lights.point;
    			uniforms.hemisphereLights.value = _lights.hemi;

    			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
    			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
    			uniforms.spotShadowMap.value = _lights.spotShadowMap;
    			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
    			uniforms.pointShadowMap.value = _lights.pointShadowMap;
    			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;

    		}

    		var progUniforms = materialProperties.program.getUniforms(),
    			uniformsList =
    					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

    		materialProperties.uniformsList = uniformsList;
    		materialProperties.dynamicUniforms =
    				WebGLUniforms.splitDynamic( uniformsList, uniforms );

    	}

    	function setMaterial( material ) {

    		material.side === DoubleSide
    			? state.disable( _gl.CULL_FACE )
    			: state.enable( _gl.CULL_FACE );

    		state.setFlipSided( material.side === BackSide );

    		material.transparent === true
    			? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
    			: state.setBlending( NoBlending );

    		state.setDepthFunc( material.depthFunc );
    		state.setDepthTest( material.depthTest );
    		state.setDepthWrite( material.depthWrite );
    		state.setColorWrite( material.colorWrite );
    		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    	}

    	function setProgram( camera, fog, material, object ) {

    		_usedTextureUnits = 0;

    		var materialProperties = properties.get( material );

    		if ( _clippingEnabled ) {

    			if ( _localClippingEnabled || camera !== _currentCamera ) {

    				var useCache =
    						camera === _currentCamera &&
    						material.id === _currentMaterialId;

    				// we might want to call this function with some ClippingGroup
    				// object instead of the material, once it becomes feasible
    				// (#8465, #8379)
    				_clipping.setState(
    						material.clippingPlanes, material.clipShadows,
    						camera, materialProperties, useCache );

    			}

    		}

    		if ( material.needsUpdate === false ) {

    			if ( materialProperties.program === undefined ) {

    				material.needsUpdate = true;

    			} else if ( material.fog && materialProperties.fog !== fog ) {

    				material.needsUpdate = true;

    			} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

    				material.needsUpdate = true;

    			} else if ( materialProperties.numClippingPlanes !== undefined &&
    				materialProperties.numClippingPlanes !== _clipping.numPlanes ) {

    				material.needsUpdate = true;

    			}

    		}

    		if ( material.needsUpdate ) {

    			initMaterial( material, fog, object );
    			material.needsUpdate = false;

    		}

    		var refreshProgram = false;
    		var refreshMaterial = false;
    		var refreshLights = false;

    		var program = materialProperties.program,
    			p_uniforms = program.getUniforms(),
    			m_uniforms = materialProperties.__webglShader.uniforms;

    		if ( program.id !== _currentProgram ) {

    			_gl.useProgram( program.program );
    			_currentProgram = program.id;

    			refreshProgram = true;
    			refreshMaterial = true;
    			refreshLights = true;

    		}

    		if ( material.id !== _currentMaterialId ) {

    			_currentMaterialId = material.id;

    			refreshMaterial = true;

    		}

    		if ( refreshProgram || camera !== _currentCamera ) {

    			p_uniforms.set( _gl, camera, 'projectionMatrix' );

    			if ( capabilities.logarithmicDepthBuffer ) {

    				p_uniforms.setValue( _gl, 'logDepthBufFC',
    						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

    			}


    			if ( camera !== _currentCamera ) {

    				_currentCamera = camera;

    				// lighting uniforms depend on the camera so enforce an update
    				// now, in case this material supports lights - or later, when
    				// the next material that does gets activated:

    				refreshMaterial = true;		// set to true on material change
    				refreshLights = true;		// remains set until update done

    			}

    			// load material specific uniforms
    			// (shader material also gets them for the sake of genericity)

    			if ( material.isShaderMaterial ||
    			     material.isMeshPhongMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.envMap ) {

    				var uCamPos = p_uniforms.map.cameraPosition;

    				if ( uCamPos !== undefined ) {

    					uCamPos.setValue( _gl,
    							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

    				}

    			}

    			if ( material.isMeshPhongMaterial ||
    			     material.isMeshLambertMaterial ||
    			     material.isMeshBasicMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.isShaderMaterial ||
    			     material.skinning ) {

    				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

    			}

    			p_uniforms.set( _gl, _this, 'toneMappingExposure' );
    			p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

    		}

    		// skinning uniforms must be set even if material didn't change
    		// auto-setting of texture unit for bone texture must go before other textures
    		// not sure why, but otherwise weird things happen

    		if ( material.skinning ) {

    			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
    			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

    			var skeleton = object.skeleton;

    			if ( skeleton ) {

    				if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

    					p_uniforms.set( _gl, skeleton, 'boneTexture' );
    					p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
    					p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

    				} else {

    					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

    				}

    			}

    		}

    		if ( refreshMaterial ) {

    			if ( material.lights ) {

    				// the current material requires lighting info

    				// note: all lighting uniforms are always set correctly
    				// they simply reference the renderer's state for their
    				// values
    				//
    				// use the current material's .needsUpdate flags to set
    				// the GL state when required

    				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

    			}

    			// refresh uniforms common to several materials

    			if ( fog && material.fog ) {

    				refreshUniformsFog( m_uniforms, fog );

    			}

    			if ( material.isMeshBasicMaterial ||
    			     material.isMeshLambertMaterial ||
    			     material.isMeshPhongMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.isMeshDepthMaterial ) {

    				refreshUniformsCommon( m_uniforms, material );

    			}

    			// refresh single material specific uniforms

    			if ( material.isLineBasicMaterial ) {

    				refreshUniformsLine( m_uniforms, material );

    			} else if ( material.isLineDashedMaterial ) {

    				refreshUniformsLine( m_uniforms, material );
    				refreshUniformsDash( m_uniforms, material );

    			} else if ( material.isPointsMaterial ) {

    				refreshUniformsPoints( m_uniforms, material );

    			} else if ( material.isMeshLambertMaterial ) {

    				refreshUniformsLambert( m_uniforms, material );

    			} else if ( material.isMeshPhongMaterial ) {

    				refreshUniformsPhong( m_uniforms, material );

    			} else if ( material.isMeshPhysicalMaterial ) {

    				refreshUniformsPhysical( m_uniforms, material );

    			} else if ( material.isMeshStandardMaterial ) {

    				refreshUniformsStandard( m_uniforms, material );

    			} else if ( material.isMeshDepthMaterial ) {

    				if ( material.displacementMap ) {

    					m_uniforms.displacementMap.value = material.displacementMap;
    					m_uniforms.displacementScale.value = material.displacementScale;
    					m_uniforms.displacementBias.value = material.displacementBias;

    				}

    			} else if ( material.isMeshNormalMaterial ) {

    				m_uniforms.opacity.value = material.opacity;

    			}

    			WebGLUniforms.upload(
    					_gl, materialProperties.uniformsList, m_uniforms, _this );

    		}


    		// common matrices

    		p_uniforms.set( _gl, object, 'modelViewMatrix' );
    		p_uniforms.set( _gl, object, 'normalMatrix' );
    		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );


    		// dynamic uniforms

    		var dynUniforms = materialProperties.dynamicUniforms;

    		if ( dynUniforms !== null ) {

    			WebGLUniforms.evalDynamic( dynUniforms, m_uniforms, object, material, camera );
    			WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );

    		}

    		return program;

    	}

    	// Uniforms (refresh uniforms objects)

    	function refreshUniformsCommon( uniforms, material ) {

    		uniforms.opacity.value = material.opacity;

    		uniforms.diffuse.value = material.color;

    		if ( material.emissive ) {

    			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

    		}

    		uniforms.map.value = material.map;
    		uniforms.specularMap.value = material.specularMap;
    		uniforms.alphaMap.value = material.alphaMap;

    		if ( material.aoMap ) {

    			uniforms.aoMap.value = material.aoMap;
    			uniforms.aoMapIntensity.value = material.aoMapIntensity;

    		}

    		// uv repeat and offset setting priorities
    		// 1. color map
    		// 2. specular map
    		// 3. normal map
    		// 4. bump map
    		// 5. alpha map
    		// 6. emissive map

    		var uvScaleMap;

    		if ( material.map ) {

    			uvScaleMap = material.map;

    		} else if ( material.specularMap ) {

    			uvScaleMap = material.specularMap;

    		} else if ( material.displacementMap ) {

    			uvScaleMap = material.displacementMap;

    		} else if ( material.normalMap ) {

    			uvScaleMap = material.normalMap;

    		} else if ( material.bumpMap ) {

    			uvScaleMap = material.bumpMap;

    		} else if ( material.roughnessMap ) {

    			uvScaleMap = material.roughnessMap;

    		} else if ( material.metalnessMap ) {

    			uvScaleMap = material.metalnessMap;

    		} else if ( material.alphaMap ) {

    			uvScaleMap = material.alphaMap;

    		} else if ( material.emissiveMap ) {

    			uvScaleMap = material.emissiveMap;

    		}

    		if ( uvScaleMap !== undefined ) {

    			// backwards compatibility
    			if ( uvScaleMap.isWebGLRenderTarget ) {

    				uvScaleMap = uvScaleMap.texture;

    			}

    			var offset = uvScaleMap.offset;
    			var repeat = uvScaleMap.repeat;

    			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    		}

    		uniforms.envMap.value = material.envMap;

    		// don't flip CubeTexture envMaps, flip everything else:
    		//  WebGLRenderTargetCube will be flipped for backwards compatibility
    		//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
    		// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
    		uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

    		uniforms.reflectivity.value = material.reflectivity;
    		uniforms.refractionRatio.value = material.refractionRatio;

    	}

    	function refreshUniformsLine( uniforms, material ) {

    		uniforms.diffuse.value = material.color;
    		uniforms.opacity.value = material.opacity;

    	}

    	function refreshUniformsDash( uniforms, material ) {

    		uniforms.dashSize.value = material.dashSize;
    		uniforms.totalSize.value = material.dashSize + material.gapSize;
    		uniforms.scale.value = material.scale;

    	}

    	function refreshUniformsPoints( uniforms, material ) {

    		uniforms.diffuse.value = material.color;
    		uniforms.opacity.value = material.opacity;
    		uniforms.size.value = material.size * _pixelRatio;
    		uniforms.scale.value = _canvas.clientHeight * 0.5;

    		uniforms.map.value = material.map;

    		if ( material.map !== null ) {

    			var offset = material.map.offset;
    			var repeat = material.map.repeat;

    			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    		}

    	}

    	function refreshUniformsFog( uniforms, fog ) {

    		uniforms.fogColor.value = fog.color;

    		if ( fog.isFog ) {

    			uniforms.fogNear.value = fog.near;
    			uniforms.fogFar.value = fog.far;

    		} else if ( fog.isFogExp2 ) {

    			uniforms.fogDensity.value = fog.density;

    		}

    	}

    	function refreshUniformsLambert( uniforms, material ) {

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    	}

    	function refreshUniformsPhong( uniforms, material ) {

    		uniforms.specular.value = material.specular;
    		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    		if ( material.bumpMap ) {

    			uniforms.bumpMap.value = material.bumpMap;
    			uniforms.bumpScale.value = material.bumpScale;

    		}

    		if ( material.normalMap ) {

    			uniforms.normalMap.value = material.normalMap;
    			uniforms.normalScale.value.copy( material.normalScale );

    		}

    		if ( material.displacementMap ) {

    			uniforms.displacementMap.value = material.displacementMap;
    			uniforms.displacementScale.value = material.displacementScale;
    			uniforms.displacementBias.value = material.displacementBias;

    		}

    	}

    	function refreshUniformsStandard( uniforms, material ) {

    		uniforms.roughness.value = material.roughness;
    		uniforms.metalness.value = material.metalness;

    		if ( material.roughnessMap ) {

    			uniforms.roughnessMap.value = material.roughnessMap;

    		}

    		if ( material.metalnessMap ) {

    			uniforms.metalnessMap.value = material.metalnessMap;

    		}

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    		if ( material.bumpMap ) {

    			uniforms.bumpMap.value = material.bumpMap;
    			uniforms.bumpScale.value = material.bumpScale;

    		}

    		if ( material.normalMap ) {

    			uniforms.normalMap.value = material.normalMap;
    			uniforms.normalScale.value.copy( material.normalScale );

    		}

    		if ( material.displacementMap ) {

    			uniforms.displacementMap.value = material.displacementMap;
    			uniforms.displacementScale.value = material.displacementScale;
    			uniforms.displacementBias.value = material.displacementBias;

    		}

    		if ( material.envMap ) {

    			//uniforms.envMap.value = material.envMap; // part of uniforms common
    			uniforms.envMapIntensity.value = material.envMapIntensity;

    		}

    	}

    	function refreshUniformsPhysical( uniforms, material ) {

    		uniforms.clearCoat.value = material.clearCoat;
    		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

    		refreshUniformsStandard( uniforms, material );

    	}

    	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

    	function markUniformsLightsNeedsUpdate( uniforms, value ) {

    		uniforms.ambientLightColor.needsUpdate = value;

    		uniforms.directionalLights.needsUpdate = value;
    		uniforms.pointLights.needsUpdate = value;
    		uniforms.spotLights.needsUpdate = value;
    		uniforms.hemisphereLights.needsUpdate = value;

    	}

    	// Lighting

    	function setupShadows( lights ) {

    		var lightShadowsLength = 0;

    		for ( var i = 0, l = lights.length; i < l; i ++ ) {

    			var light = lights[ i ];

    			if ( light.castShadow ) {

    				_lights.shadows[ lightShadowsLength ++ ] = light;

    			}

    		}

    		_lights.shadows.length = lightShadowsLength;

    	}

    	function setupLights( lights, camera ) {

    		var l, ll, light,
    		r = 0, g = 0, b = 0,
    		color,
    		intensity,
    		distance,
    		shadowMap,

    		viewMatrix = camera.matrixWorldInverse,

    		directionalLength = 0,
    		pointLength = 0,
    		spotLength = 0,
    		hemiLength = 0;

    		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

    			light = lights[ l ];

    			color = light.color;
    			intensity = light.intensity;
    			distance = light.distance;

    			shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

    			if ( light.isAmbientLight ) {

    				r += color.r * intensity;
    				g += color.g * intensity;
    				b += color.b * intensity;

    			} else if ( light.isDirectionalLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				_vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( _vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.directionalShadowMap[ directionalLength ] = shadowMap;
    				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
    				_lights.directional[ directionalLength ++ ] = uniforms;

    			} else if ( light.isSpotLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				uniforms.color.copy( color ).multiplyScalar( intensity );
    				uniforms.distance = distance;

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				_vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( _vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				uniforms.coneCos = Math.cos( light.angle );
    				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
    				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.spotShadowMap[ spotLength ] = shadowMap;
    				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
    				_lights.spot[ spotLength ++ ] = uniforms;

    			} else if ( light.isPointLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
    				uniforms.distance = light.distance;
    				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.pointShadowMap[ pointLength ] = shadowMap;

    				if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

    					_lights.pointShadowMatrix[ pointLength ] = new Matrix4();

    				}

    				// for point lights we set the shadow matrix to be a translation-only matrix
    				// equal to inverse of the light's position
    				_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
    				_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

    				_lights.point[ pointLength ++ ] = uniforms;

    			} else if ( light.isHemisphereLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				uniforms.direction.transformDirection( viewMatrix );
    				uniforms.direction.normalize();

    				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
    				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

    				_lights.hemi[ hemiLength ++ ] = uniforms;

    			}

    		}

    		_lights.ambient[ 0 ] = r;
    		_lights.ambient[ 1 ] = g;
    		_lights.ambient[ 2 ] = b;

    		_lights.directional.length = directionalLength;
    		_lights.spot.length = spotLength;
    		_lights.point.length = pointLength;
    		_lights.hemi.length = hemiLength;

    		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;

    	}

    	// GL state setting

    	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

    		state.setCullFace( cullFace );
    		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

    	};

    	// Textures

    	function allocTextureUnit() {

    		var textureUnit = _usedTextureUnits;

    		if ( textureUnit >= capabilities.maxTextures ) {

    			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

    		}

    		_usedTextureUnits += 1;

    		return textureUnit;

    	}

    	this.allocTextureUnit = allocTextureUnit;

    	// this.setTexture2D = setTexture2D;
    	this.setTexture2D = ( function() {

    		var warned = false;

    		// backwards compatibility: peel texture.texture
    		return function setTexture2D( texture, slot ) {

    			if ( texture && texture.isWebGLRenderTarget ) {

    				if ( ! warned ) {

    					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
    					warned = true;

    				}

    				texture = texture.texture;

    			}

    			textures.setTexture2D( texture, slot );

    		};

    	}() );

    	this.setTexture = ( function() {

    		var warned = false;

    		return function setTexture( texture, slot ) {

    			if ( ! warned ) {

    				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
    				warned = true;

    			}

    			textures.setTexture2D( texture, slot );

    		};

    	}() );

    	this.setTextureCube = ( function() {

    		var warned = false;

    		return function setTextureCube( texture, slot ) {

    			// backwards compatibility: peel texture.texture
    			if ( texture && texture.isWebGLRenderTargetCube ) {

    				if ( ! warned ) {

    					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
    					warned = true;

    				}

    				texture = texture.texture;

    			}

    			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
    			// TODO: unify these code paths
    			if ( ( texture && texture.isCubeTexture ) ||
    				 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

    				// CompressedTexture can have Array in image :/

    				// this function alone should take care of cube textures
    				textures.setTextureCube( texture, slot );

    			} else {

    				// assumed: texture property of THREE.WebGLRenderTargetCube

    				textures.setTextureCubeDynamic( texture, slot );

    			}

    		};

    	}() );

    	this.getCurrentRenderTarget = function() {

    		return _currentRenderTarget;

    	};

    	this.setRenderTarget = function ( renderTarget ) {

    		_currentRenderTarget = renderTarget;

    		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

    			textures.setupRenderTarget( renderTarget );

    		}

    		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
    		var framebuffer;

    		if ( renderTarget ) {

    			var renderTargetProperties = properties.get( renderTarget );

    			if ( isCube ) {

    				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

    			} else {

    				framebuffer = renderTargetProperties.__webglFramebuffer;

    			}

    			_currentScissor.copy( renderTarget.scissor );
    			_currentScissorTest = renderTarget.scissorTest;

    			_currentViewport.copy( renderTarget.viewport );

    		} else {

    			framebuffer = null;

    			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
    			_currentScissorTest = _scissorTest;

    			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

    		}

    		if ( _currentFramebuffer !== framebuffer ) {

    			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    			_currentFramebuffer = framebuffer;

    		}

    		state.scissor( _currentScissor );
    		state.setScissorTest( _currentScissorTest );

    		state.viewport( _currentViewport );

    		if ( isCube ) {

    			var textureProperties = properties.get( renderTarget.texture );
    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

    		}

    	};

    	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

    		if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

    			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
    			return;

    		}

    		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

    		if ( framebuffer ) {

    			var restore = false;

    			if ( framebuffer !== _currentFramebuffer ) {

    				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

    				restore = true;

    			}

    			try {

    				var texture = renderTarget.texture;
    				var textureFormat = texture.format;
    				var textureType = texture.type;

    				if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
    					return;

    				}

    				if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
    				     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
    				     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
    					return;

    				}

    				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

    					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

    					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

    						_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

    					}

    				} else {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

    				}

    			} finally {

    				if ( restore ) {

    					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

    				}

    			}

    		}

    	};

    	// Map three.js constants to WebGL constants

    	function paramThreeToGL( p ) {

    		var extension;

    		if ( p === RepeatWrapping ) return _gl.REPEAT;
    		if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
    		if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

    		if ( p === NearestFilter ) return _gl.NEAREST;
    		if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
    		if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

    		if ( p === LinearFilter ) return _gl.LINEAR;
    		if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
    		if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

    		if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
    		if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
    		if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
    		if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

    		if ( p === ByteType ) return _gl.BYTE;
    		if ( p === ShortType ) return _gl.SHORT;
    		if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
    		if ( p === IntType ) return _gl.INT;
    		if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
    		if ( p === FloatType ) return _gl.FLOAT;

    		extension = extensions.get( 'OES_texture_half_float' );

    		if ( extension !== null ) {

    			if ( p === HalfFloatType ) return extension.HALF_FLOAT_OES;

    		}

    		if ( p === AlphaFormat ) return _gl.ALPHA;
    		if ( p === RGBFormat ) return _gl.RGB;
    		if ( p === RGBAFormat ) return _gl.RGBA;
    		if ( p === LuminanceFormat ) return _gl.LUMINANCE;
    		if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
    		if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
    		if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

    		if ( p === AddEquation ) return _gl.FUNC_ADD;
    		if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
    		if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

    		if ( p === ZeroFactor ) return _gl.ZERO;
    		if ( p === OneFactor ) return _gl.ONE;
    		if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
    		if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
    		if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
    		if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
    		if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
    		if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

    		if ( p === DstColorFactor ) return _gl.DST_COLOR;
    		if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
    		if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

    		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    		if ( extension !== null ) {

    			if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
    			if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
    			if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
    			if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    		}

    		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    		if ( extension !== null ) {

    			if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
    			if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
    			if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
    			if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    		}

    		extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

    		if ( extension !== null ) {

    			if ( p === RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

    		}

    		extension = extensions.get( 'EXT_blend_minmax' );

    		if ( extension !== null ) {

    			if ( p === MinEquation ) return extension.MIN_EXT;
    			if ( p === MaxEquation ) return extension.MAX_EXT;

    		}

    		extension = extensions.get( 'WEBGL_depth_texture' );

    		if ( extension !== null ){

    			if ( p === UnsignedInt248Type ) return extension.UNSIGNED_INT_24_8_WEBGL;

    		}

    		return 0;

    	}

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function FogExp2 ( color, density ) {

    	this.name = '';

    	this.color = new Color( color );
    	this.density = ( density !== undefined ) ? density : 0.00025;

    }

    FogExp2.prototype.isFogExp2 = true;

    FogExp2.prototype.clone = function () {

    	return new FogExp2( this.color.getHex(), this.density );

    };

    FogExp2.prototype.toJSON = function ( meta ) {

    	return {
    		type: 'FogExp2',
    		color: this.color.getHex(),
    		density: this.density
    	};

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Fog ( color, near, far ) {

    	this.name = '';

    	this.color = new Color( color );

    	this.near = ( near !== undefined ) ? near : 1;
    	this.far = ( far !== undefined ) ? far : 1000;

    }

    Fog.prototype.isFog = true;

    Fog.prototype.clone = function () {

    	return new Fog( this.color.getHex(), this.near, this.far );

    };

    Fog.prototype.toJSON = function ( meta ) {

    	return {
    		type: 'Fog',
    		color: this.color.getHex(),
    		near: this.near,
    		far: this.far
    	};

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Scene () {

    	Object3D.call( this );

    	this.type = 'Scene';

    	this.background = null;
    	this.fog = null;
    	this.overrideMaterial = null;

    	this.autoUpdate = true; // checked by the renderer

    }

    Scene.prototype = Object.create( Object3D.prototype );

    Scene.prototype.constructor = Scene;

    Scene.prototype.copy = function ( source, recursive ) {

    	Object3D.prototype.copy.call( this, source, recursive );

    	if ( source.background !== null ) this.background = source.background.clone();
    	if ( source.fog !== null ) this.fog = source.fog.clone();
    	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    	this.autoUpdate = source.autoUpdate;
    	this.matrixAutoUpdate = source.matrixAutoUpdate;

    	return this;

    };

    Scene.prototype.toJSON = function ( meta ) {

    	var data = Object3D.prototype.toJSON.call( this, meta );

    	if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
    	if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

    	return data;

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlare( texture, size, distance, blending, color ) {

    	Object3D.call( this );

    	this.lensFlares = [];

    	this.positionScreen = new Vector3();
    	this.customUpdateCallback = undefined;

    	if ( texture !== undefined ) {

    		this.add( texture, size, distance, blending, color );

    	}

    }

    LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: LensFlare,

    	isLensFlare: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.positionScreen.copy( source.positionScreen );
    		this.customUpdateCallback = source.customUpdateCallback;

    		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

    			this.lensFlares.push( source.lensFlares[ i ] );

    		}

    		return this;

    	},

    	add: function ( texture, size, distance, blending, color, opacity ) {

    		if ( size === undefined ) size = - 1;
    		if ( distance === undefined ) distance = 0;
    		if ( opacity === undefined ) opacity = 1;
    		if ( color === undefined ) color = new Color( 0xffffff );
    		if ( blending === undefined ) blending = NormalBlending;

    		distance = Math.min( distance, Math.max( 0, distance ) );

    		this.lensFlares.push( {
    			texture: texture,	// THREE.Texture
    			size: size, 		// size in pixels (-1 = use texture.width)
    			distance: distance, 	// distance (0-1) from light source (0=at light source)
    			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
    			scale: 1, 		// scale
    			rotation: 0, 		// rotation
    			opacity: opacity,	// opacity
    			color: color,		// color
    			blending: blending	// blending
    		} );

    	},

    	/*
    	 * Update lens flares update positions on all flares based on the screen position
    	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
    	 */

    	updateLensFlares: function () {

    		var f, fl = this.lensFlares.length;
    		var flare;
    		var vecX = - this.positionScreen.x * 2;
    		var vecY = - this.positionScreen.y * 2;

    		for ( f = 0; f < fl; f ++ ) {

    			flare = this.lensFlares[ f ];

    			flare.x = this.positionScreen.x + vecX * flare.distance;
    			flare.y = this.positionScreen.y + vecY * flare.distance;

    			flare.wantedRotation = flare.x * Math.PI * 0.25;
    			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

    		}

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *	uvOffset: new THREE.Vector2(),
     *	uvScale: new THREE.Vector2()
     * }
     */

    function SpriteMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'SpriteMaterial';

    	this.color = new Color( 0xffffff );
    	this.map = null;

    	this.rotation = 0;

    	this.fog = false;
    	this.lights = false;

    	this.setValues( parameters );

    }

    SpriteMaterial.prototype = Object.create( Material.prototype );
    SpriteMaterial.prototype.constructor = SpriteMaterial;

    SpriteMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );
    	this.map = source.map;

    	this.rotation = source.rotation;

    	return this;

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function Sprite( material ) {

    	Object3D.call( this );

    	this.type = 'Sprite';

    	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

    }

    Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Sprite,

    	isSprite: true,

    	raycast: ( function () {

    		var matrixPosition = new Vector3();

    		return function raycast( raycaster, intersects ) {

    			matrixPosition.setFromMatrixPosition( this.matrixWorld );

    			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
    			var guessSizeSq = this.scale.x * this.scale.y / 4;

    			if ( distanceSq > guessSizeSq ) {

    				return;

    			}

    			intersects.push( {

    				distance: Math.sqrt( distanceSq ),
    				point: this.position,
    				face: null,
    				object: this

    			} );

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.material ).copy( this );

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function LOD() {

    	Object3D.call( this );

    	this.type = 'LOD';

    	Object.defineProperties( this, {
    		levels: {
    			enumerable: true,
    			value: []
    		}
    	} );

    }


    LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: LOD,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source, false );

    		var levels = source.levels;

    		for ( var i = 0, l = levels.length; i < l; i ++ ) {

    			var level = levels[ i ];

    			this.addLevel( level.object.clone(), level.distance );

    		}

    		return this;

    	},

    	addLevel: function ( object, distance ) {

    		if ( distance === undefined ) distance = 0;

    		distance = Math.abs( distance );

    		var levels = this.levels;

    		for ( var l = 0; l < levels.length; l ++ ) {

    			if ( distance < levels[ l ].distance ) {

    				break;

    			}

    		}

    		levels.splice( l, 0, { distance: distance, object: object } );

    		this.add( object );

    	},

    	getObjectForDistance: function ( distance ) {

    		var levels = this.levels;

    		for ( var i = 1, l = levels.length; i < l; i ++ ) {

    			if ( distance < levels[ i ].distance ) {

    				break;

    			}

    		}

    		return levels[ i - 1 ].object;

    	},

    	raycast: ( function () {

    		var matrixPosition = new Vector3();

    		return function raycast( raycaster, intersects ) {

    			matrixPosition.setFromMatrixPosition( this.matrixWorld );

    			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

    			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

    		};

    	}() ),

    	update: function () {

    		var v1 = new Vector3();
    		var v2 = new Vector3();

    		return function update( camera ) {

    			var levels = this.levels;

    			if ( levels.length > 1 ) {

    				v1.setFromMatrixPosition( camera.matrixWorld );
    				v2.setFromMatrixPosition( this.matrixWorld );

    				var distance = v1.distanceTo( v2 );

    				levels[ 0 ].object.visible = true;

    				for ( var i = 1, l = levels.length; i < l; i ++ ) {

    					if ( distance >= levels[ i ].distance ) {

    						levels[ i - 1 ].object.visible = false;
    						levels[ i ].object.visible = true;

    					} else {

    						break;

    					}

    				}

    				for ( ; i < l; i ++ ) {

    					levels[ i ].object.visible = false;

    				}

    			}

    		};

    	}(),

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.levels = [];

    		var levels = this.levels;

    		for ( var i = 0, l = levels.length; i < l; i ++ ) {

    			var level = levels[ i ];

    			data.object.levels.push( {
    				object: level.object.uuid,
    				distance: level.distance
    			} );

    		}

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.image = { data: data, width: width, height: height };

    	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    	this.flipY = false;
    	this.generateMipmaps  = false;

    }

    DataTexture.prototype = Object.create( Texture.prototype );
    DataTexture.prototype.constructor = DataTexture;

    DataTexture.prototype.isDataTexture = true;

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author michael guerrero / http://realitymeltdown.com
     * @author ikerr / http://verold.com
     */

    function Skeleton( bones, boneInverses, useVertexTexture ) {

    	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

    	this.identityMatrix = new Matrix4();

    	// copy the bone array

    	bones = bones || [];

    	this.bones = bones.slice( 0 );

    	// create a bone texture or an array of floats

    	if ( this.useVertexTexture ) {

    		// layout (1 matrix = 4 pixels)
    		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
    		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
    		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
    		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


    		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
    		size = exports.Math.nextPowerOfTwo( Math.ceil( size ) );
    		size = Math.max( size, 4 );

    		this.boneTextureWidth = size;
    		this.boneTextureHeight = size;

    		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
    		this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );

    	} else {

    		this.boneMatrices = new Float32Array( 16 * this.bones.length );

    	}

    	// use the supplied bone inverses or calculate the inverses

    	if ( boneInverses === undefined ) {

    		this.calculateInverses();

    	} else {

    		if ( this.bones.length === boneInverses.length ) {

    			this.boneInverses = boneInverses.slice( 0 );

    		} else {

    			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

    			this.boneInverses = [];

    			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    				this.boneInverses.push( new Matrix4() );

    			}

    		}

    	}

    }

    Object.assign( Skeleton.prototype, {

    	calculateInverses: function () {

    		this.boneInverses = [];

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			var inverse = new Matrix4();

    			if ( this.bones[ b ] ) {

    				inverse.getInverse( this.bones[ b ].matrixWorld );

    			}

    			this.boneInverses.push( inverse );

    		}

    	},

    	pose: function () {

    		var bone;

    		// recover the bind-time world matrices

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			bone = this.bones[ b ];

    			if ( bone ) {

    				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

    			}

    		}

    		// compute the local matrices, positions, rotations and scales

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			bone = this.bones[ b ];

    			if ( bone ) {

    				if ( (bone.parent && bone.parent.isBone) ) {

    					bone.matrix.getInverse( bone.parent.matrixWorld );
    					bone.matrix.multiply( bone.matrixWorld );

    				} else {

    					bone.matrix.copy( bone.matrixWorld );

    				}

    				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

    			}

    		}

    	},

    	update: ( function () {

    		var offsetMatrix = new Matrix4();

    		return function update() {

    			// flatten bone matrices to array

    			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    				// compute the offset between the current and the original transform

    				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

    				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
    				offsetMatrix.toArray( this.boneMatrices, b * 16 );

    			}

    			if ( this.useVertexTexture ) {

    				this.boneTexture.needsUpdate = true;

    			}

    		};

    	} )(),

    	clone: function () {

    		return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function Bone( skin ) {

    	Object3D.call( this );

    	this.type = 'Bone';

    	this.skin = skin;

    }

    Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Bone,

    	isBone: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.skin = source.skin;

    		return this;

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function SkinnedMesh( geometry, material, useVertexTexture ) {

    	Mesh.call( this, geometry, material );

    	this.type = 'SkinnedMesh';

    	this.bindMode = "attached";
    	this.bindMatrix = new Matrix4();
    	this.bindMatrixInverse = new Matrix4();

    	// init bones

    	// TODO: remove bone creation as there is no reason (other than
    	// convenience) for THREE.SkinnedMesh to do this.

    	var bones = [];

    	if ( this.geometry && this.geometry.bones !== undefined ) {

    		var bone, gbone;

    		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

    			gbone = this.geometry.bones[ b ];

    			bone = new Bone( this );
    			bones.push( bone );

    			bone.name = gbone.name;
    			bone.position.fromArray( gbone.pos );
    			bone.quaternion.fromArray( gbone.rotq );
    			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

    		}

    		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

    			gbone = this.geometry.bones[ b ];

    			if ( gbone.parent !== - 1 && gbone.parent !== null &&
    					bones[ gbone.parent ] !== undefined ) {

    				bones[ gbone.parent ].add( bones[ b ] );

    			} else {

    				this.add( bones[ b ] );

    			}

    		}

    	}

    	this.normalizeSkinWeights();

    	this.updateMatrixWorld( true );
    	this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

    }


    SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

    	constructor: SkinnedMesh,

    	isSkinnedMesh: true,

    	bind: function( skeleton, bindMatrix ) {

    		this.skeleton = skeleton;

    		if ( bindMatrix === undefined ) {

    			this.updateMatrixWorld( true );

    			this.skeleton.calculateInverses();

    			bindMatrix = this.matrixWorld;

    		}

    		this.bindMatrix.copy( bindMatrix );
    		this.bindMatrixInverse.getInverse( bindMatrix );

    	},

    	pose: function () {

    		this.skeleton.pose();

    	},

    	normalizeSkinWeights: function () {

    		if ( (this.geometry && this.geometry.isGeometry) ) {

    			for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

    				var sw = this.geometry.skinWeights[ i ];

    				var scale = 1.0 / sw.lengthManhattan();

    				if ( scale !== Infinity ) {

    					sw.multiplyScalar( scale );

    				} else {

    					sw.set( 1, 0, 0, 0 ); // do something reasonable

    				}

    			}

    		} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {

    			var vec = new Vector4();

    			var skinWeight = this.geometry.attributes.skinWeight;

    			for ( var i = 0; i < skinWeight.count; i ++ ) {

    				vec.x = skinWeight.getX( i );
    				vec.y = skinWeight.getY( i );
    				vec.z = skinWeight.getZ( i );
    				vec.w = skinWeight.getW( i );

    				var scale = 1.0 / vec.lengthManhattan();

    				if ( scale !== Infinity ) {

    					vec.multiplyScalar( scale );

    				} else {

    					vec.set( 1, 0, 0, 0 ); // do something reasonable

    				}

    				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

    			}

    		}

    	},

    	updateMatrixWorld: function( force ) {

    		Mesh.prototype.updateMatrixWorld.call( this, true );

    		if ( this.bindMode === "attached" ) {

    			this.bindMatrixInverse.getInverse( this.matrixWorld );

    		} else if ( this.bindMode === "detached" ) {

    			this.bindMatrixInverse.getInverse( this.bindMatrix );

    		} else {

    			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

    		}

    	},

    	clone: function() {

    		return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *  linecap: "round",
     *  linejoin: "round"
     * }
     */

    function LineBasicMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'LineBasicMaterial';

    	this.color = new Color( 0xffffff );

    	this.linewidth = 1;
    	this.linecap = 'round';
    	this.linejoin = 'round';

    	this.lights = false;

    	this.setValues( parameters );

    }

    LineBasicMaterial.prototype = Object.create( Material.prototype );
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;

    LineBasicMaterial.prototype.isLineBasicMaterial = true;

    LineBasicMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.linewidth = source.linewidth;
    	this.linecap = source.linecap;
    	this.linejoin = source.linejoin;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Line( geometry, material, mode ) {

    	if ( mode === 1 ) {

    		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
    		return new LineSegments( geometry, material );

    	}

    	Object3D.call( this );

    	this.type = 'Line';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

    }

    Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Line,

    	isLine: true,

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		return function raycast( raycaster, intersects ) {

    			var precision = raycaster.linePrecision;
    			var precisionSq = precision * precision;

    			var geometry = this.geometry;
    			var matrixWorld = this.matrixWorld;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			var vStart = new Vector3();
    			var vEnd = new Vector3();
    			var interSegment = new Vector3();
    			var interRay = new Vector3();
    			var step = (this && this.isLineSegments) ? 2 : 1;

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

    						var a = indices[ i ];
    						var b = indices[ i + 1 ];

    						vStart.fromArray( positions, a * 3 );
    						vEnd.fromArray( positions, b * 3 );

    						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    						if ( distSq > precisionSq ) continue;

    						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    						var distance = raycaster.ray.origin.distanceTo( interRay );

    						if ( distance < raycaster.near || distance > raycaster.far ) continue;

    						intersects.push( {

    							distance: distance,
    							// What do we want? intersection point on the ray or on the segment??
    							// point: raycaster.ray.at( distance ),
    							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    							index: i,
    							face: null,
    							faceIndex: null,
    							object: this

    						} );

    					}

    				} else {

    					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

    						vStart.fromArray( positions, 3 * i );
    						vEnd.fromArray( positions, 3 * i + 3 );

    						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    						if ( distSq > precisionSq ) continue;

    						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    						var distance = raycaster.ray.origin.distanceTo( interRay );

    						if ( distance < raycaster.near || distance > raycaster.far ) continue;

    						intersects.push( {

    							distance: distance,
    							// What do we want? intersection point on the ray or on the segment??
    							// point: raycaster.ray.at( distance ),
    							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    							index: i,
    							face: null,
    							faceIndex: null,
    							object: this

    						} );

    					}

    				}

    			} else if ( (geometry && geometry.isGeometry) ) {

    				var vertices = geometry.vertices;
    				var nbVertices = vertices.length;

    				for ( var i = 0; i < nbVertices - 1; i += step ) {

    					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

    					if ( distSq > precisionSq ) continue;

    					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    					var distance = raycaster.ray.origin.distanceTo( interRay );

    					if ( distance < raycaster.near || distance > raycaster.far ) continue;

    					intersects.push( {

    						distance: distance,
    						// What do we want? intersection point on the ray or on the segment??
    						// point: raycaster.ray.at( distance ),
    						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    						index: i,
    						face: null,
    						faceIndex: null,
    						object: this

    					} );

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LineSegments( geometry, material ) {

    	Line.call( this, geometry, material );

    	this.type = 'LineSegments';

    }

    LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

    	constructor: LineSegments,

    	isLineSegments: true

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  size: <float>,
     *  sizeAttenuation: <bool>
     * }
     */

    function PointsMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'PointsMaterial';

    	this.color = new Color( 0xffffff );

    	this.map = null;

    	this.size = 1;
    	this.sizeAttenuation = true;

    	this.lights = false;

    	this.setValues( parameters );

    }

    PointsMaterial.prototype = Object.create( Material.prototype );
    PointsMaterial.prototype.constructor = PointsMaterial;

    PointsMaterial.prototype.isPointsMaterial = true;

    PointsMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.size = source.size;
    	this.sizeAttenuation = source.sizeAttenuation;

    	return this;

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Points( geometry, material ) {

    	Object3D.call( this );

    	this.type = 'Points';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

    }

    Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Points,

    	isPoints: true,

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		return function raycast( raycaster, intersects ) {

    			var object = this;
    			var geometry = this.geometry;
    			var matrixWorld = this.matrixWorld;
    			var threshold = raycaster.params.Points.threshold;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    			var localThresholdSq = localThreshold * localThreshold;
    			var position = new Vector3();

    			function testPoint( point, index ) {

    				var rayPointDistanceSq = ray.distanceSqToPoint( point );

    				if ( rayPointDistanceSq < localThresholdSq ) {

    					var intersectPoint = ray.closestPointToPoint( point );
    					intersectPoint.applyMatrix4( matrixWorld );

    					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

    					if ( distance < raycaster.near || distance > raycaster.far ) return;

    					intersects.push( {

    						distance: distance,
    						distanceToRay: Math.sqrt( rayPointDistanceSq ),
    						point: intersectPoint.clone(),
    						index: index,
    						face: null,
    						object: object

    					} );

    				}

    			}

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, il = indices.length; i < il; i ++ ) {

    						var a = indices[ i ];

    						position.fromArray( positions, a * 3 );

    						testPoint( position, a );

    					}

    				} else {

    					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

    						position.fromArray( positions, i * 3 );

    						testPoint( position, i );

    					}

    				}

    			} else {

    				var vertices = geometry.vertices;

    				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

    					testPoint( vertices[ i ], i );

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Group() {

    	Object3D.call( this );

    	this.type = 'Group';

    }

    Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Group

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.generateMipmaps = false;

    	var scope = this;

    	function update() {

    		requestAnimationFrame( update );

    		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

    			scope.needsUpdate = true;

    		}

    	}

    	update();

    }

    VideoTexture.prototype = Object.create( Texture.prototype );
    VideoTexture.prototype.constructor = VideoTexture;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.image = { width: width, height: height };
    	this.mipmaps = mipmaps;

    	// no flipping for cube textures
    	// (also flipping doesn't work for compressed textures )

    	this.flipY = false;

    	// can't generate mipmaps for compressed textures
    	// mips must be embedded in DDS files

    	this.generateMipmaps = false;

    }

    CompressedTexture.prototype = Object.create( Texture.prototype );
    CompressedTexture.prototype.constructor = CompressedTexture;

    CompressedTexture.prototype.isCompressedTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.needsUpdate = true;

    }

    CanvasTexture.prototype = Object.create( Texture.prototype );
    CanvasTexture.prototype.constructor = CanvasTexture;

    /**
     * @author Matt DesLauriers / @mattdesl
     * @author atix / arthursilber.de
     */

    function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

    	format = format !== undefined ? format : DepthFormat;

    	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

    		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

    	}

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.image = { width: width, height: height };

    	this.type = type !== undefined ? type : UnsignedShortType;

    	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    	this.flipY = false;
    	this.generateMipmaps	= false;

    }

    DepthTexture.prototype = Object.create( Texture.prototype );
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WireframeGeometry( geometry ) {

    	BufferGeometry.call( this );

    	var edge = [ 0, 0 ], hash = {};

    	function sortFunction( a, b ) {

    		return a - b;

    	}

    	var keys = [ 'a', 'b', 'c' ];

    	if ( (geometry && geometry.isGeometry) ) {

    		var vertices = geometry.vertices;
    		var faces = geometry.faces;
    		var numEdges = 0;

    		// allocate maximal size
    		var edges = new Uint32Array( 6 * faces.length );

    		for ( var i = 0, l = faces.length; i < l; i ++ ) {

    			var face = faces[ i ];

    			for ( var j = 0; j < 3; j ++ ) {

    				edge[ 0 ] = face[ keys[ j ] ];
    				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
    				edge.sort( sortFunction );

    				var key = edge.toString();

    				if ( hash[ key ] === undefined ) {

    					edges[ 2 * numEdges ] = edge[ 0 ];
    					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
    					hash[ key ] = true;
    					numEdges ++;

    				}

    			}

    		}

    		var coords = new Float32Array( numEdges * 2 * 3 );

    		for ( var i = 0, l = numEdges; i < l; i ++ ) {

    			for ( var j = 0; j < 2; j ++ ) {

    				var vertex = vertices[ edges [ 2 * i + j ] ];

    				var index = 6 * i + 3 * j;
    				coords[ index + 0 ] = vertex.x;
    				coords[ index + 1 ] = vertex.y;
    				coords[ index + 2 ] = vertex.z;

    			}

    		}

    		this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    	} else if ( (geometry && geometry.isBufferGeometry) ) {

    		if ( geometry.index !== null ) {

    			// Indexed BufferGeometry

    			var indices = geometry.index.array;
    			var vertices = geometry.attributes.position;
    			var groups = geometry.groups;
    			var numEdges = 0;

    			if ( groups.length === 0 ) {

    				geometry.addGroup( 0, indices.length );

    			}

    			// allocate maximal size
    			var edges = new Uint32Array( 2 * indices.length );

    			for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

    				var group = groups[ o ];

    				var start = group.start;
    				var count = group.count;

    				for ( var i = start, il = start + count; i < il; i += 3 ) {

    					for ( var j = 0; j < 3; j ++ ) {

    						edge[ 0 ] = indices[ i + j ];
    						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
    						edge.sort( sortFunction );

    						var key = edge.toString();

    						if ( hash[ key ] === undefined ) {

    							edges[ 2 * numEdges ] = edge[ 0 ];
    							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
    							hash[ key ] = true;
    							numEdges ++;

    						}

    					}

    				}

    			}

    			var coords = new Float32Array( numEdges * 2 * 3 );

    			for ( var i = 0, l = numEdges; i < l; i ++ ) {

    				for ( var j = 0; j < 2; j ++ ) {

    					var index = 6 * i + 3 * j;
    					var index2 = edges[ 2 * i + j ];

    					coords[ index + 0 ] = vertices.getX( index2 );
    					coords[ index + 1 ] = vertices.getY( index2 );
    					coords[ index + 2 ] = vertices.getZ( index2 );

    				}

    			}

    			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    		} else {

    			// non-indexed BufferGeometry

    			var vertices = geometry.attributes.position.array;
    			var numEdges = vertices.length / 3;
    			var numTris = numEdges / 3;

    			var coords = new Float32Array( numEdges * 2 * 3 );

    			for ( var i = 0, l = numTris; i < l; i ++ ) {

    				for ( var j = 0; j < 3; j ++ ) {

    					var index = 18 * i + 6 * j;

    					var index1 = 9 * i + 3 * j;
    					coords[ index + 0 ] = vertices[ index1 ];
    					coords[ index + 1 ] = vertices[ index1 + 1 ];
    					coords[ index + 2 ] = vertices[ index1 + 2 ];

    					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
    					coords[ index + 3 ] = vertices[ index2 ];
    					coords[ index + 4 ] = vertices[ index2 + 1 ];
    					coords[ index + 5 ] = vertices[ index2 + 2 ];

    				}

    			}

    			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    		}

    	}

    }

    WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
    WireframeGeometry.prototype.constructor = WireframeGeometry;

    /**
     * @author zz85 / https://github.com/zz85
     * Parametric Surfaces Geometry
     * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
     *
     * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
     *
     */

    function ParametricGeometry( func, slices, stacks ) {

    	Geometry.call( this );

    	this.type = 'ParametricGeometry';

    	this.parameters = {
    		func: func,
    		slices: slices,
    		stacks: stacks
    	};

    	var verts = this.vertices;
    	var faces = this.faces;
    	var uvs = this.faceVertexUvs[ 0 ];

    	var i, j, p;
    	var u, v;

    	var sliceCount = slices + 1;

    	for ( i = 0; i <= stacks; i ++ ) {

    		v = i / stacks;

    		for ( j = 0; j <= slices; j ++ ) {

    			u = j / slices;

    			p = func( u, v );
    			verts.push( p );

    		}

    	}

    	var a, b, c, d;
    	var uva, uvb, uvc, uvd;

    	for ( i = 0; i < stacks; i ++ ) {

    		for ( j = 0; j < slices; j ++ ) {

    			a = i * sliceCount + j;
    			b = i * sliceCount + j + 1;
    			c = ( i + 1 ) * sliceCount + j + 1;
    			d = ( i + 1 ) * sliceCount + j;

    			uva = new Vector2( j / slices, i / stacks );
    			uvb = new Vector2( ( j + 1 ) / slices, i / stacks );
    			uvc = new Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
    			uvd = new Vector2( j / slices, ( i + 1 ) / stacks );

    			faces.push( new Face3( a, b, d ) );
    			uvs.push( [ uva, uvb, uvd ] );

    			faces.push( new Face3( b, c, d ) );
    			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

    		}

    	}

    	// console.log(this);

    	// magic bullet
    	// var diff = this.mergeVertices();
    	// console.log('removed ', diff, ' vertices by merging');

    	this.computeFaceNormals();
    	this.computeVertexNormals();

    }

    ParametricGeometry.prototype = Object.create( Geometry.prototype );
    ParametricGeometry.prototype.constructor = ParametricGeometry;

    /**
     * @author clockworkgeek / https://github.com/clockworkgeek
     * @author timothypratley / https://github.com/timothypratley
     * @author WestLangley / http://github.com/WestLangley
    */

    function PolyhedronGeometry( vertices, indices, radius, detail ) {

    	Geometry.call( this );

    	this.type = 'PolyhedronGeometry';

    	this.parameters = {
    		vertices: vertices,
    		indices: indices,
    		radius: radius,
    		detail: detail
    	};

    	radius = radius || 1;
    	detail = detail || 0;

    	var that = this;

    	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

    		prepare( new Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

    	}

    	var p = this.vertices;

    	var faces = [];

    	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

    		var v1 = p[ indices[ i ] ];
    		var v2 = p[ indices[ i + 1 ] ];
    		var v3 = p[ indices[ i + 2 ] ];

    		faces[ j ] = new Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

    	}

    	var centroid = new Vector3();

    	for ( var i = 0, l = faces.length; i < l; i ++ ) {

    		subdivide( faces[ i ], detail );

    	}


    	// Handle case when face straddles the seam

    	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

    		var uvs = this.faceVertexUvs[ 0 ][ i ];

    		var x0 = uvs[ 0 ].x;
    		var x1 = uvs[ 1 ].x;
    		var x2 = uvs[ 2 ].x;

    		var max = Math.max( x0, x1, x2 );
    		var min = Math.min( x0, x1, x2 );

    		if ( max > 0.9 && min < 0.1 ) {

    			// 0.9 is somewhat arbitrary

    			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
    			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
    			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

    		}

    	}


    	// Apply radius

    	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

    		this.vertices[ i ].multiplyScalar( radius );

    	}


    	// Merge vertices

    	this.mergeVertices();

    	this.computeFaceNormals();

    	this.boundingSphere = new Sphere( new Vector3(), radius );


    	// Project vector onto sphere's surface

    	function prepare( vector ) {

    		var vertex = vector.normalize().clone();
    		vertex.index = that.vertices.push( vertex ) - 1;

    		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

    		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
    		var v = inclination( vector ) / Math.PI + 0.5;
    		vertex.uv = new Vector2( u, 1 - v );

    		return vertex;

    	}


    	// Approximate a curved face with recursively sub-divided triangles.

    	function make( v1, v2, v3 ) {

    		var face = new Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
    		that.faces.push( face );

    		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

    		var azi = azimuth( centroid );

    		that.faceVertexUvs[ 0 ].push( [
    			correctUV( v1.uv, v1, azi ),
    			correctUV( v2.uv, v2, azi ),
    			correctUV( v3.uv, v3, azi )
    		] );

    	}


    	// Analytically subdivide a face to the required detail level.

    	function subdivide( face, detail ) {

    		var cols = Math.pow( 2, detail );
    		var a = prepare( that.vertices[ face.a ] );
    		var b = prepare( that.vertices[ face.b ] );
    		var c = prepare( that.vertices[ face.c ] );
    		var v = [];

    		// Construct all of the vertices for this subdivision.

    		for ( var i = 0 ; i <= cols; i ++ ) {

    			v[ i ] = [];

    			var aj = prepare( a.clone().lerp( c, i / cols ) );
    			var bj = prepare( b.clone().lerp( c, i / cols ) );
    			var rows = cols - i;

    			for ( var j = 0; j <= rows; j ++ ) {

    				if ( j === 0 && i === cols ) {

    					v[ i ][ j ] = aj;

    				} else {

    					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

    				}

    			}

    		}

    		// Construct all of the faces.

    		for ( var i = 0; i < cols ; i ++ ) {

    			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

    				var k = Math.floor( j / 2 );

    				if ( j % 2 === 0 ) {

    					make(
    						v[ i ][ k + 1 ],
    						v[ i + 1 ][ k ],
    						v[ i ][ k ]
    					);

    				} else {

    					make(
    						v[ i ][ k + 1 ],
    						v[ i + 1 ][ k + 1 ],
    						v[ i + 1 ][ k ]
    					);

    				}

    			}

    		}

    	}


    	// Angle around the Y axis, counter-clockwise when looking from above.

    	function azimuth( vector ) {

    		return Math.atan2( vector.z, - vector.x );

    	}


    	// Angle above the XZ plane.

    	function inclination( vector ) {

    		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    	}


    	// Texture fixing helper. Spheres have some odd behaviours.

    	function correctUV( uv, vector, azimuth ) {

    		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new Vector2( uv.x - 1, uv.y );
    		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
    		return uv.clone();

    	}

    }

    PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function TetrahedronGeometry( radius, detail ) {

    	var vertices = [
    		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
    	];

    	var indices = [
    		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'TetrahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    TetrahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function OctahedronGeometry( radius, detail ) {

    	var vertices = [
    		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
    	];

    	var indices = [
    		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'OctahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    OctahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function IcosahedronGeometry( radius, detail ) {

    	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    	var vertices = [
    		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
    		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
    		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
    	];

    	var indices = [
    		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
    		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
    		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
    		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'IcosahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    IcosahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

    /**
     * @author Abe Pazos / https://hamoid.com
     */

    function DodecahedronGeometry( radius, detail ) {

    	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    	var r = 1 / t;

    	var vertices = [

    		// (±1, ±1, ±1)
    		- 1, - 1, - 1,    - 1, - 1,  1,
    		- 1,  1, - 1,    - 1,  1,  1,
    		 1, - 1, - 1,     1, - 1,  1,
    		 1,  1, - 1,     1,  1,  1,

    		// (0, ±1/φ, ±φ)
    		 0, - r, - t,     0, - r,  t,
    		 0,  r, - t,     0,  r,  t,

    		// (±1/φ, ±φ, 0)
    		- r, - t,  0,    - r,  t,  0,
    		 r, - t,  0,     r,  t,  0,

    		// (±φ, 0, ±1/φ)
    		- t,  0, - r,     t,  0, - r,
    		- t,  0,  r,     t,  0,  r
    	];

    	var indices = [
    		 3, 11,  7,      3,  7, 15,      3, 15, 13,
    		 7, 19, 17,      7, 17,  6,      7,  6, 15,
    		17,  4,  8,     17,  8, 10,     17, 10,  6,
    		 8,  0, 16,      8, 16,  2,      8,  2, 10,
    		 0, 12,  1,      0,  1, 18,      0, 18, 16,
    		 6, 10,  2,      6,  2, 13,      6, 13, 15,
    		 2, 16, 18,      2, 18,  3,      2,  3, 13,
    		18,  1,  9,     18,  9, 11,     18, 11,  3,
    		 4, 14, 12,      4, 12,  0,      4,  0,  8,
    		11,  9,  5,     11,  5, 19,     11, 19,  7,
    		19,  5, 14,     19, 14,  4,     19,  4, 17,
    		 1, 12, 14,      1, 14,  5,      1,  5,  9
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'DodecahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    DodecahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

    /**
     * @author WestLangley / https://github.com/WestLangley
     * @author zz85 / https://github.com/zz85
     * @author miningold / https://github.com/miningold
     * @author jonobr1 / https://github.com/jonobr1
     *
     * Modified from the TorusKnotGeometry by @oosmoxiecode
     *
     * Creates a tube which extrudes along a 3d spline
     *
     * Uses parallel transport frames as described in
     * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
     */

    function TubeGeometry( path, segments, radius, radialSegments, closed, taper ) {

    	Geometry.call( this );

    	this.type = 'TubeGeometry';

    	this.parameters = {
    		path: path,
    		segments: segments,
    		radius: radius,
    		radialSegments: radialSegments,
    		closed: closed,
    		taper: taper
    	};

    	segments = segments || 64;
    	radius = radius || 1;
    	radialSegments = radialSegments || 8;
    	closed = closed || false;
    	taper = taper || TubeGeometry.NoTaper;

    	var grid = [];

    	var scope = this,

    		tangent,
    		normal,
    		binormal,

    		numpoints = segments + 1,

    		u, v, r,

    		cx, cy,
    		pos, pos2 = new Vector3(),
    		i, j,
    		ip, jp,
    		a, b, c, d,
    		uva, uvb, uvc, uvd;

    	var frames = new TubeGeometry.FrenetFrames( path, segments, closed ),
    		tangents = frames.tangents,
    		normals = frames.normals,
    		binormals = frames.binormals;

    	// proxy internals
    	this.tangents = tangents;
    	this.normals = normals;
    	this.binormals = binormals;

    	function vert( x, y, z ) {

    		return scope.vertices.push( new Vector3( x, y, z ) ) - 1;

    	}

    	// construct the grid

    	for ( i = 0; i < numpoints; i ++ ) {

    		grid[ i ] = [];

    		u = i / ( numpoints - 1 );

    		pos = path.getPointAt( u );

    		tangent = tangents[ i ];
    		normal = normals[ i ];
    		binormal = binormals[ i ];

    		r = radius * taper( u );

    		for ( j = 0; j < radialSegments; j ++ ) {

    			v = j / radialSegments * 2 * Math.PI;

    			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
    			cy = r * Math.sin( v );

    			pos2.copy( pos );
    			pos2.x += cx * normal.x + cy * binormal.x;
    			pos2.y += cx * normal.y + cy * binormal.y;
    			pos2.z += cx * normal.z + cy * binormal.z;

    			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

    		}

    	}


    	// construct the mesh

    	for ( i = 0; i < segments; i ++ ) {

    		for ( j = 0; j < radialSegments; j ++ ) {

    			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
    			jp = ( j + 1 ) % radialSegments;

    			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
    			b = grid[ ip ][ j ];
    			c = grid[ ip ][ jp ];
    			d = grid[ i ][ jp ];

    			uva = new Vector2( i / segments, j / radialSegments );
    			uvb = new Vector2( ( i + 1 ) / segments, j / radialSegments );
    			uvc = new Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
    			uvd = new Vector2( i / segments, ( j + 1 ) / radialSegments );

    			this.faces.push( new Face3( a, b, d ) );
    			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

    			this.faces.push( new Face3( b, c, d ) );
    			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    		}

    	}

    	this.computeFaceNormals();
    	this.computeVertexNormals();

    }

    TubeGeometry.prototype = Object.create( Geometry.prototype );
    TubeGeometry.prototype.constructor = TubeGeometry;

    TubeGeometry.NoTaper = function ( u ) {

    	return 1;

    };

    TubeGeometry.SinusoidalTaper = function ( u ) {

    	return Math.sin( Math.PI * u );

    };

    // For computing of Frenet frames, exposing the tangents, normals and binormals the spline
    TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

    	var	normal = new Vector3(),

    		tangents = [],
    		normals = [],
    		binormals = [],

    		vec = new Vector3(),
    		mat = new Matrix4(),

    		numpoints = segments + 1,
    		theta,
    		smallest,

    		tx, ty, tz,
    		i, u;


    	// expose internals
    	this.tangents = tangents;
    	this.normals = normals;
    	this.binormals = binormals;

    	// compute the tangent vectors for each segment on the path

    	for ( i = 0; i < numpoints; i ++ ) {

    		u = i / ( numpoints - 1 );

    		tangents[ i ] = path.getTangentAt( u );
    		tangents[ i ].normalize();

    	}

    	initialNormal3();

    	/*
    	function initialNormal1(lastBinormal) {
    		// fixed start binormal. Has dangers of 0 vectors
    		normals[ 0 ] = new THREE.Vector3();
    		binormals[ 0 ] = new THREE.Vector3();
    		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
    		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
    	}

    	function initialNormal2() {

    		// This uses the Frenet-Serret formula for deriving binormal
    		var t2 = path.getTangentAt( epsilon );

    		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
    		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

    		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

    	}
    	*/

    	function initialNormal3() {

    		// select an initial normal vector perpendicular to the first tangent vector,
    		// and in the direction of the smallest tangent xyz component

    		normals[ 0 ] = new Vector3();
    		binormals[ 0 ] = new Vector3();
    		smallest = Number.MAX_VALUE;
    		tx = Math.abs( tangents[ 0 ].x );
    		ty = Math.abs( tangents[ 0 ].y );
    		tz = Math.abs( tangents[ 0 ].z );

    		if ( tx <= smallest ) {

    			smallest = tx;
    			normal.set( 1, 0, 0 );

    		}

    		if ( ty <= smallest ) {

    			smallest = ty;
    			normal.set( 0, 1, 0 );

    		}

    		if ( tz <= smallest ) {

    			normal.set( 0, 0, 1 );

    		}

    		vec.crossVectors( tangents[ 0 ], normal ).normalize();

    		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

    	}


    	// compute the slowly-varying normal and binormal vectors for each segment on the path

    	for ( i = 1; i < numpoints; i ++ ) {

    		normals[ i ] = normals[ i - 1 ].clone();

    		binormals[ i ] = binormals[ i - 1 ].clone();

    		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

    		if ( vec.length() > Number.EPSILON ) {

    			vec.normalize();

    			theta = Math.acos( exports.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

    			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    		}

    		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    	}


    	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    	if ( closed ) {

    		theta = Math.acos( exports.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
    		theta /= ( numpoints - 1 );

    		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

    			theta = - theta;

    		}

    		for ( i = 1; i < numpoints; i ++ ) {

    			// twist a little...
    			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
    			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    		}

    	}

    };

    /**
     * @author Mugen87 / https://github.com/Mugen87
     *
     * see: http://www.blackpawn.com/texts/pqtorus/
     */
    function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

    	BufferGeometry.call( this );

    	this.type = 'TorusKnotBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		tubularSegments: tubularSegments,
    		radialSegments: radialSegments,
    		p: p,
    		q: q
    	};

    	radius = radius || 100;
    	tube = tube || 40;
    	tubularSegments = Math.floor( tubularSegments ) || 64;
    	radialSegments = Math.floor( radialSegments ) || 8;
    	p = p || 2;
    	q = q || 3;

    	// used to calculate buffer length
    	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
    	var indexCount = radialSegments * tubularSegments * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables
    	var i, j, index = 0, indexOffset = 0;

    	var vertex = new Vector3();
    	var normal = new Vector3();
    	var uv = new Vector2();

    	var P1 = new Vector3();
    	var P2 = new Vector3();

    	var B = new Vector3();
    	var T = new Vector3();
    	var N = new Vector3();

    	// generate vertices, normals and uvs

    	for ( i = 0; i <= tubularSegments; ++ i ) {

    		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

    		var u = i / tubularSegments * p * Math.PI * 2;

    		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
    		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

    		calculatePositionOnCurve( u, p, q, radius, P1 );
    		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

    		// calculate orthonormal basis

    		T.subVectors( P2, P1 );
    		N.addVectors( P2, P1 );
    		B.crossVectors( T, N );
    		N.crossVectors( B, T );

    		// normalize B, N. T can be ignored, we don't use it

    		B.normalize();
    		N.normalize();

    		for ( j = 0; j <= radialSegments; ++ j ) {

    			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
    			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

    			var v = j / radialSegments * Math.PI * 2;
    			var cx = - tube * Math.cos( v );
    			var cy = tube * Math.sin( v );

    			// now calculate the final vertex position.
    			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

    			vertex.x = P1.x + ( cx * N.x + cy * B.x );
    			vertex.y = P1.y + ( cx * N.y + cy * B.y );
    			vertex.z = P1.z + ( cx * N.z + cy * B.z );

    			// vertex
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
    			normal.subVectors( vertex, P1 ).normalize();
    			normals.setXYZ( index, normal.x, normal.y, normal.z );

    			// uv
    			uv.x = i / tubularSegments;
    			uv.y = j / radialSegments;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    	}

    	// generate indices

    	for ( j = 1; j <= tubularSegments; j ++ ) {

    		for ( i = 1; i <= radialSegments; i ++ ) {

    			// indices
    			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
    			var b = ( radialSegments + 1 ) * j + ( i - 1 );
    			var c = ( radialSegments + 1 ) * j + i;
    			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	// this function calculates the current position on the torus curve

    	function calculatePositionOnCurve( u, p, q, radius, position ) {

    		var cu = Math.cos( u );
    		var su = Math.sin( u );
    		var quOverP = q / p * u;
    		var cs = Math.cos( quOverP );

    		position.x = radius * ( 2 + cs ) * 0.5 * cu;
    		position.y = radius * ( 2 + cs ) * su * 0.5;
    		position.z = radius * Math.sin( quOverP ) * 0.5;

    	}

    }

    TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

    /**
     * @author oosmoxiecode
     */

    function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

    	Geometry.call( this );

    	this.type = 'TorusKnotGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		tubularSegments: tubularSegments,
    		radialSegments: radialSegments,
    		p: p,
    		q: q
    	};

    	if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

    	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
    	this.mergeVertices();

    }

    TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    	BufferGeometry.call( this );

    	this.type = 'TorusBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		radialSegments: radialSegments,
    		tubularSegments: tubularSegments,
    		arc: arc
    	};

    	radius = radius || 100;
    	tube = tube || 40;
    	radialSegments = Math.floor( radialSegments ) || 8;
    	tubularSegments = Math.floor( tubularSegments ) || 6;
    	arc = arc || Math.PI * 2;

    	// used to calculate buffer length
    	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
    	var indexCount = radialSegments * tubularSegments * 2 * 3;

    	// buffers
    	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
    	var vertices = new Float32Array( vertexCount * 3 );
    	var normals = new Float32Array( vertexCount * 3 );
    	var uvs = new Float32Array( vertexCount * 2 );

    	// offset variables
    	var vertexBufferOffset = 0;
    	var uvBufferOffset = 0;
    	var indexBufferOffset = 0;

    	// helper variables
    	var center = new Vector3();
    	var vertex = new Vector3();
    	var normal = new Vector3();

    	var j, i;

    	// generate vertices, normals and uvs

    	for ( j = 0; j <= radialSegments; j ++ ) {

    		for ( i = 0; i <= tubularSegments; i ++ ) {

    			var u = i / tubularSegments * arc;
    			var v = j / radialSegments * Math.PI * 2;

    			// vertex
    			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
    			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
    			vertex.z = tube * Math.sin( v );

    			vertices[ vertexBufferOffset ] = vertex.x;
    			vertices[ vertexBufferOffset + 1 ] = vertex.y;
    			vertices[ vertexBufferOffset + 2 ] = vertex.z;

    			// this vector is used to calculate the normal
    			center.x = radius * Math.cos( u );
    			center.y = radius * Math.sin( u );

    			// normal
    			normal.subVectors( vertex, center ).normalize();

    			normals[ vertexBufferOffset ] = normal.x;
    			normals[ vertexBufferOffset + 1 ] = normal.y;
    			normals[ vertexBufferOffset + 2 ] = normal.z;

    			// uv
    			uvs[ uvBufferOffset ] = i / tubularSegments;
    			uvs[ uvBufferOffset + 1 ] = j / radialSegments;

    			// update offsets
    			vertexBufferOffset += 3;
    			uvBufferOffset += 2;

    		}

    	}

    	// generate indices

    	for ( j = 1; j <= radialSegments; j ++ ) {

    		for ( i = 1; i <= tubularSegments; i ++ ) {

    			// indices
    			var a = ( tubularSegments + 1 ) * j + i - 1;
    			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
    			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
    			var d = ( tubularSegments + 1 ) * j + i;

    			// face one
    			indices[ indexBufferOffset ] = a;
    			indices[ indexBufferOffset + 1 ] = b;
    			indices[ indexBufferOffset + 2 ] = d;

    			// face two
    			indices[ indexBufferOffset + 3 ] = b;
    			indices[ indexBufferOffset + 4 ] = c;
    			indices[ indexBufferOffset + 5 ] = d;

    			// update offset
    			indexBufferOffset += 6;

    		}

    	}

    	// build geometry
    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    }

    TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

    /**
     * @author oosmoxiecode
     * @author mrdoob / http://mrdoob.com/
     * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
     */

    function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    	Geometry.call( this );

    	this.type = 'TorusGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		radialSegments: radialSegments,
    		tubularSegments: tubularSegments,
    		arc: arc
    	};

    	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

    }

    TorusGeometry.prototype = Object.create( Geometry.prototype );
    TorusGeometry.prototype.constructor = TorusGeometry;

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    exports.ShapeUtils = {

    	// calculate area of the contour polygon

    	area: function ( contour ) {

    		var n = contour.length;
    		var a = 0.0;

    		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

    			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    		}

    		return a * 0.5;

    	},

    	triangulate: ( function () {

    		/**
    		 * This code is a quick port of code written in C++ which was submitted to
    		 * flipcode.com by John W. Ratcliff  // July 22, 2000
    		 * See original code and more information here:
    		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
    		 *
    		 * ported to actionscript by Zevan Rosser
    		 * www.actionsnippet.com
    		 *
    		 * ported to javascript by Joshua Koo
    		 * http://www.lab4games.net/zz85/blog
    		 *
    		 */

    		function snip( contour, u, v, w, n, verts ) {

    			var p;
    			var ax, ay, bx, by;
    			var cx, cy, px, py;

    			ax = contour[ verts[ u ] ].x;
    			ay = contour[ verts[ u ] ].y;

    			bx = contour[ verts[ v ] ].x;
    			by = contour[ verts[ v ] ].y;

    			cx = contour[ verts[ w ] ].x;
    			cy = contour[ verts[ w ] ].y;

    			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

    			var aX, aY, bX, bY, cX, cY;
    			var apx, apy, bpx, bpy, cpx, cpy;
    			var cCROSSap, bCROSScp, aCROSSbp;

    			aX = cx - bx;  aY = cy - by;
    			bX = ax - cx;  bY = ay - cy;
    			cX = bx - ax;  cY = by - ay;

    			for ( p = 0; p < n; p ++ ) {

    				px = contour[ verts[ p ] ].x;
    				py = contour[ verts[ p ] ].y;

    				if ( ( ( px === ax ) && ( py === ay ) ) ||
    					 ( ( px === bx ) && ( py === by ) ) ||
    					 ( ( px === cx ) && ( py === cy ) ) )	continue;

    				apx = px - ax;  apy = py - ay;
    				bpx = px - bx;  bpy = py - by;
    				cpx = px - cx;  cpy = py - cy;

    				// see if p is inside triangle abc

    				aCROSSbp = aX * bpy - aY * bpx;
    				cCROSSap = cX * apy - cY * apx;
    				bCROSScp = bX * cpy - bY * cpx;

    				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

    			}

    			return true;

    		}

    		// takes in an contour array and returns

    		return function triangulate( contour, indices ) {

    			var n = contour.length;

    			if ( n < 3 ) return null;

    			var result = [],
    				verts = [],
    				vertIndices = [];

    			/* we want a counter-clockwise polygon in verts */

    			var u, v, w;

    			if ( exports.ShapeUtils.area( contour ) > 0.0 ) {

    				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

    			} else {

    				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

    			}

    			var nv = n;

    			/*  remove nv - 2 vertices, creating 1 triangle every time */

    			var count = 2 * nv;   /* error detection */

    			for ( v = nv - 1; nv > 2; ) {

    				/* if we loop, it is probably a non-simple polygon */

    				if ( ( count -- ) <= 0 ) {

    					//** Triangulate: ERROR - probable bad polygon!

    					//throw ( "Warning, unable to triangulate polygon!" );
    					//return null;
    					// Sometimes warning is fine, especially polygons are triangulated in reverse.
    					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

    					if ( indices ) return vertIndices;
    					return result;

    				}

    				/* three consecutive vertices in current polygon, <u,v,w> */

    				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
    				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
    				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

    				if ( snip( contour, u, v, w, nv, verts ) ) {

    					var a, b, c, s, t;

    					/* true names of the vertices */

    					a = verts[ u ];
    					b = verts[ v ];
    					c = verts[ w ];

    					/* output Triangle */

    					result.push( [ contour[ a ],
    						contour[ b ],
    						contour[ c ] ] );


    					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

    					/* remove v from the remaining polygon */

    					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

    						verts[ s ] = verts[ t ];

    					}

    					nv --;

    					/* reset error detection counter */

    					count = 2 * nv;

    				}

    			}

    			if ( indices ) return vertIndices;
    			return result;

    		}

    	} )(),

    	triangulateShape: function ( contour, holes ) {

    		function removeDupEndPts(points) {

    			var l = points.length;

    			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

    				points.pop();

    			}

    		}

    		removeDupEndPts( contour );
    		holes.forEach( removeDupEndPts );

    		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

    			// inOtherPt needs to be collinear to the inSegment
    			if ( inSegPt1.x !== inSegPt2.x ) {

    				if ( inSegPt1.x < inSegPt2.x ) {

    					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

    				} else {

    					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

    				}

    			} else {

    				if ( inSegPt1.y < inSegPt2.y ) {

    					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

    				} else {

    					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

    				}

    			}

    		}

    		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

    			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
    			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

    			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
    			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

    			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
    			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

    			if ( Math.abs( limit ) > Number.EPSILON ) {

    				// not parallel

    				var perpSeg2;
    				if ( limit > 0 ) {

    					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
    					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
    					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

    				} else {

    					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
    					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
    					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

    				}

    				// i.e. to reduce rounding errors
    				// intersection at endpoint of segment#1?
    				if ( perpSeg2 === 0 ) {

    					if ( ( inExcludeAdjacentSegs ) &&
    						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
    					return [ inSeg1Pt1 ];

    				}
    				if ( perpSeg2 === limit ) {

    					if ( ( inExcludeAdjacentSegs ) &&
    						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
    					return [ inSeg1Pt2 ];

    				}
    				// intersection at endpoint of segment#2?
    				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
    				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

    				// return real intersection point
    				var factorSeg1 = perpSeg2 / limit;
    				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
    							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

    			} else {

    				// parallel or collinear
    				if ( ( perpSeg1 !== 0 ) ||
    					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

    				// they are collinear or degenerate
    				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
    				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
    				// both segments are points
    				if ( seg1Pt && seg2Pt ) {

    					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
    						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
    					return [ inSeg1Pt1 ];                 						// they are the same point

    				}
    				// segment#1  is a single point
    				if ( seg1Pt ) {

    					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
    					return [ inSeg1Pt1 ];

    				}
    				// segment#2  is a single point
    				if ( seg2Pt ) {

    					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
    					return [ inSeg2Pt1 ];

    				}

    				// they are collinear segments, which might overlap
    				var seg1min, seg1max, seg1minVal, seg1maxVal;
    				var seg2min, seg2max, seg2minVal, seg2maxVal;
    				if ( seg1dx !== 0 ) {

    					// the segments are NOT on a vertical line
    					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

    						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
    						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

    					} else {

    						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
    						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

    					}
    					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

    						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
    						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

    					} else {

    						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
    						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

    					}

    				} else {

    					// the segments are on a vertical line
    					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

    						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
    						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

    					} else {

    						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
    						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

    					}
    					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

    						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
    						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

    					} else {

    						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
    						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

    					}

    				}
    				if ( seg1minVal <= seg2minVal ) {

    					if ( seg1maxVal <  seg2minVal )	return [];
    					if ( seg1maxVal === seg2minVal )	{

    						if ( inExcludeAdjacentSegs )		return [];
    						return [ seg2min ];

    					}
    					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
    					return	[ seg2min, seg2max ];

    				} else {

    					if ( seg1minVal >  seg2maxVal )	return [];
    					if ( seg1minVal === seg2maxVal )	{

    						if ( inExcludeAdjacentSegs )		return [];
    						return [ seg1min ];

    					}
    					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
    					return	[ seg1min, seg2max ];

    				}

    			}

    		}

    		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

    			// The order of legs is important

    			// translation of all points, so that Vertex is at (0,0)
    			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
    			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
    			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

    			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
    			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
    			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

    			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

    				// angle != 180 deg.

    				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
    				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

    				if ( from2toAngle > 0 ) {

    					// main angle < 180 deg.
    					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

    				} else {

    					// main angle > 180 deg.
    					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

    				}

    			} else {

    				// angle == 180 deg.
    				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
    				return	( from2otherAngle > 0 );

    			}

    		}


    		function removeHoles( contour, holes ) {

    			var shape = contour.concat(); // work on this shape
    			var hole;

    			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

    				// Check if hole point lies within angle around shape point
    				var lastShapeIdx = shape.length - 1;

    				var prevShapeIdx = inShapeIdx - 1;
    				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

    				var nextShapeIdx = inShapeIdx + 1;
    				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

    				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
    				if ( ! insideAngle ) {

    					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
    					return	false;

    				}

    				// Check if shape point lies within angle around hole point
    				var lastHoleIdx = hole.length - 1;

    				var prevHoleIdx = inHoleIdx - 1;
    				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

    				var nextHoleIdx = inHoleIdx + 1;
    				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

    				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
    				if ( ! insideAngle ) {

    					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
    					return	false;

    				}

    				return	true;

    			}

    			function intersectsShapeEdge( inShapePt, inHolePt ) {

    				// checks for intersections with shape edges
    				var sIdx, nextIdx, intersection;
    				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

    					nextIdx = sIdx + 1; nextIdx %= shape.length;
    					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
    					if ( intersection.length > 0 )		return	true;

    				}

    				return	false;

    			}

    			var indepHoles = [];

    			function intersectsHoleEdge( inShapePt, inHolePt ) {

    				// checks for intersections with hole edges
    				var ihIdx, chkHole,
    					hIdx, nextIdx, intersection;
    				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

    					chkHole = holes[ indepHoles[ ihIdx ]];
    					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

    						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
    						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
    						if ( intersection.length > 0 )		return	true;

    					}

    				}
    				return	false;

    			}

    			var holeIndex, shapeIndex,
    				shapePt, holePt,
    				holeIdx, cutKey, failedCuts = [],
    				tmpShape1, tmpShape2,
    				tmpHole1, tmpHole2;

    			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

    				indepHoles.push( h );

    			}

    			var minShapeIndex = 0;
    			var counter = indepHoles.length * 2;
    			while ( indepHoles.length > 0 ) {

    				counter --;
    				if ( counter < 0 ) {

    					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
    					break;

    				}

    				// search for shape-vertex and hole-vertex,
    				// which can be connected without intersections
    				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

    					shapePt = shape[ shapeIndex ];
    					holeIndex	= - 1;

    					// search for hole which can be reached without intersections
    					for ( var h = 0; h < indepHoles.length; h ++ ) {

    						holeIdx = indepHoles[ h ];

    						// prevent multiple checks
    						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
    						if ( failedCuts[ cutKey ] !== undefined )			continue;

    						hole = holes[ holeIdx ];
    						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

    							holePt = hole[ h2 ];
    							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
    							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
    							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

    							holeIndex = h2;
    							indepHoles.splice( h, 1 );

    							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
    							tmpShape2 = shape.slice( shapeIndex );
    							tmpHole1 = hole.slice( holeIndex );
    							tmpHole2 = hole.slice( 0, holeIndex + 1 );

    							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

    							minShapeIndex = shapeIndex;

    							// Debug only, to show the selected cuts
    							// glob_CutLines.push( [ shapePt, holePt ] );

    							break;

    						}
    						if ( holeIndex >= 0 )	break;		// hole-vertex found

    						failedCuts[ cutKey ] = true;			// remember failure

    					}
    					if ( holeIndex >= 0 )	break;		// hole-vertex found

    				}

    			}

    			return shape; 			/* shape with no holes */

    		}


    		var i, il, f, face,
    			key, index,
    			allPointsMap = {};

    		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

    		var allpoints = contour.concat();

    		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

    			Array.prototype.push.apply( allpoints, holes[ h ] );

    		}

    		//console.log( "allpoints",allpoints, allpoints.length );

    		// prepare all points map

    		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

    			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

    			if ( allPointsMap[ key ] !== undefined ) {

    				console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

    			}

    			allPointsMap[ key ] = i;

    		}

    		// remove holes by cutting paths to holes and adding them to the shape
    		var shapeWithoutHoles = removeHoles( contour, holes );

    		var triangles = exports.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
    		//console.log( "triangles",triangles, triangles.length );

    		// check all face vertices against all points map

    		for ( i = 0, il = triangles.length; i < il; i ++ ) {

    			face = triangles[ i ];

    			for ( f = 0; f < 3; f ++ ) {

    				key = face[ f ].x + ":" + face[ f ].y;

    				index = allPointsMap[ key ];

    				if ( index !== undefined ) {

    					face[ f ] = index;

    				}

    			}

    		}

    		return triangles.concat();

    	},

    	isClockWise: function ( pts ) {

    		return exports.ShapeUtils.area( pts ) < 0;

    	},

    	// Bezier Curves formulas obtained from
    	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    	// Quad Bezier Functions

    	b2: ( function () {

    		function b2p0( t, p ) {

    			var k = 1 - t;
    			return k * k * p;

    		}

    		function b2p1( t, p ) {

    			return 2 * ( 1 - t ) * t * p;

    		}

    		function b2p2( t, p ) {

    			return t * t * p;

    		}

    		return function b2( t, p0, p1, p2 ) {

    			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

    		};

    	} )(),

    	// Cubic Bezier Functions

    	b3: ( function () {

    		function b3p0( t, p ) {

    			var k = 1 - t;
    			return k * k * k * p;

    		}

    		function b3p1( t, p ) {

    			var k = 1 - t;
    			return 3 * k * k * t * p;

    		}

    		function b3p2( t, p ) {

    			var k = 1 - t;
    			return 3 * k * t * t * p;

    		}

    		function b3p3( t, p ) {

    			return t * t * t * p;

    		}

    		return function b3( t, p0, p1, p2, p3 ) {

    			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

    		};

    	} )()

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Creates extruded geometry from a path shape.
     *
     * parameters = {
     *
     *  curveSegments: <int>, // number of points on the curves
     *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
     *  amount: <int>, // Depth to extrude the shape
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into the original shape bevel goes
     *  bevelSize: <float>, // how far from shape outline is bevel
     *  bevelSegments: <int>, // number of bevel layers
     *
     *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
     *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
     *
     *  uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/

    function ExtrudeGeometry( shapes, options ) {

    	if ( typeof( shapes ) === "undefined" ) {

    		shapes = [];
    		return;

    	}

    	Geometry.call( this );

    	this.type = 'ExtrudeGeometry';

    	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    	this.addShapeList( shapes, options );

    	this.computeFaceNormals();

    	// can't really use automatic vertex normals
    	// as then front and back sides get smoothed too
    	// should do separate smoothing just for sides

    	//this.computeVertexNormals();

    	//console.log( "took", ( Date.now() - startTime ) );

    }

    ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

    ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

    	var sl = shapes.length;

    	for ( var s = 0; s < sl; s ++ ) {

    		var shape = shapes[ s ];
    		this.addShape( shape, options );

    	}

    };

    ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

    	var amount = options.amount !== undefined ? options.amount : 100;

    	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    	var steps = options.steps !== undefined ? options.steps : 1;

    	var extrudePath = options.extrudePath;
    	var extrudePts, extrudeByPath = false;

    	// Use default WorldUVGenerator if no UV generators are specified.
    	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

    	var splineTube, binormal, normal, position2;
    	if ( extrudePath ) {

    		extrudePts = extrudePath.getSpacedPoints( steps );

    		extrudeByPath = true;
    		bevelEnabled = false; // bevels not supported for path extrusion

    		// SETUP TNB variables

    		// Reuse TNB from TubeGeomtry for now.
    		// TODO1 - have a .isClosed in spline?

    		splineTube = options.frames !== undefined ? options.frames : new TubeGeometry.FrenetFrames( extrudePath, steps, false );

    		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    		binormal = new Vector3();
    		normal = new Vector3();
    		position2 = new Vector3();

    	}

    	// Safeguards if bevels are not enabled

    	if ( ! bevelEnabled ) {

    		bevelSegments = 0;
    		bevelThickness = 0;
    		bevelSize = 0;

    	}

    	// Variables initialization

    	var ahole, h, hl; // looping of holes
    	var scope = this;

    	var shapesOffset = this.vertices.length;

    	var shapePoints = shape.extractPoints( curveSegments );

    	var vertices = shapePoints.shape;
    	var holes = shapePoints.holes;

    	var reverse = ! exports.ShapeUtils.isClockWise( vertices );

    	if ( reverse ) {

    		vertices = vertices.reverse();

    		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];

    			if ( exports.ShapeUtils.isClockWise( ahole ) ) {

    				holes[ h ] = ahole.reverse();

    			}

    		}

    		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

    	}


    	var faces = exports.ShapeUtils.triangulateShape( vertices, holes );

    	/* Vertices */

    	var contour = vertices; // vertices has all points but contour has only points of circumference

    	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    		ahole = holes[ h ];

    		vertices = vertices.concat( ahole );

    	}


    	function scalePt2( pt, vec, size ) {

    		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

    		return vec.clone().multiplyScalar( size ).add( pt );

    	}

    	var b, bs, t, z,
    		vert, vlen = vertices.length,
    		face, flen = faces.length;


    	// Find directions for point movement


    	function getBevelVec( inPt, inPrev, inNext ) {

    		// computes for inPt the corresponding point inPt' on a new contour
    		//   shifted by 1 unit (length of normalized vector) to the left
    		// if we walk along contour clockwise, this new contour is outside the old one
    		//
    		// inPt' is the intersection of the two lines parallel to the two
    		//  adjacent edges of inPt at a distance of 1 unit on the left side.

    		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

    		// good reading for geometry algorithms (here: line-line intersection)
    		// http://geomalgorithms.com/a05-_intersect-1.html

    		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

    		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

    		// check for collinear edges
    		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

    			// not collinear

    			// length of vectors for normalizing

    			var v_prev_len = Math.sqrt( v_prev_lensq );
    			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

    			// shift adjacent points by unit vectors to the left

    			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
    			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

    			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
    			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

    			// scaling factor for v_prev to intersection point

    			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
    						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
    					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    			// vector from inPt to intersection point

    			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
    			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

    			// Don't normalize!, otherwise sharp corners become ugly
    			//  but prevent crazy spikes
    			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
    			if ( v_trans_lensq <= 2 ) {

    				return	new Vector2( v_trans_x, v_trans_y );

    			} else {

    				shrink_by = Math.sqrt( v_trans_lensq / 2 );

    			}

    		} else {

    			// handle special case of collinear edges

    			var direction_eq = false;		// assumes: opposite
    			if ( v_prev_x > Number.EPSILON ) {

    				if ( v_next_x > Number.EPSILON ) {

    					direction_eq = true;

    				}

    			} else {

    				if ( v_prev_x < - Number.EPSILON ) {

    					if ( v_next_x < - Number.EPSILON ) {

    						direction_eq = true;

    					}

    				} else {

    					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

    						direction_eq = true;

    					}

    				}

    			}

    			if ( direction_eq ) {

    				// console.log("Warning: lines are a straight sequence");
    				v_trans_x = - v_prev_y;
    				v_trans_y =  v_prev_x;
    				shrink_by = Math.sqrt( v_prev_lensq );

    			} else {

    				// console.log("Warning: lines are a straight spike");
    				v_trans_x = v_prev_x;
    				v_trans_y = v_prev_y;
    				shrink_by = Math.sqrt( v_prev_lensq / 2 );

    			}

    		}

    		return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    	}


    	var contourMovements = [];

    	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    		if ( j === il ) j = 0;
    		if ( k === il ) k = 0;

    		//  (j)---(i)---(k)
    		// console.log('i,j,k', i, j , k)

    		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    	}

    	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

    	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    		ahole = holes[ h ];

    		oneHoleMovements = [];

    		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    			if ( j === il ) j = 0;
    			if ( k === il ) k = 0;

    			//  (j)---(i)---(k)
    			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    		}

    		holesMovements.push( oneHoleMovements );
    		verticesMovements = verticesMovements.concat( oneHoleMovements );

    	}


    	// Loop bevelSegments, 1 for the front, 1 for the back

    	for ( b = 0; b < bevelSegments; b ++ ) {

    		//for ( b = bevelSegments; b > 0; b -- ) {

    		t = b / bevelSegments;
    		z = bevelThickness * Math.cos( t * Math.PI / 2 );
    		bs = bevelSize * Math.sin( t * Math.PI / 2 );

    		// contract shape

    		for ( i = 0, il = contour.length; i < il; i ++ ) {

    			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

    			v( vert.x, vert.y,  - z );

    		}

    		// expand holes

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			oneHoleMovements = holesMovements[ h ];

    			for ( i = 0, il = ahole.length; i < il; i ++ ) {

    				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    				v( vert.x, vert.y,  - z );

    			}

    		}

    	}

    	bs = bevelSize;

    	// Back facing vertices

    	for ( i = 0; i < vlen; i ++ ) {

    		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    		if ( ! extrudeByPath ) {

    			v( vert.x, vert.y, 0 );

    		} else {

    			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

    			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
    			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

    			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

    			v( position2.x, position2.y, position2.z );

    		}

    	}

    	// Add stepped vertices...
    	// Including front facing vertices

    	var s;

    	for ( s = 1; s <= steps; s ++ ) {

    		for ( i = 0; i < vlen; i ++ ) {

    			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    			if ( ! extrudeByPath ) {

    				v( vert.x, vert.y, amount / steps * s );

    			} else {

    				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

    				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
    				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

    				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

    				v( position2.x, position2.y, position2.z );

    			}

    		}

    	}


    	// Add bevel segments planes

    	//for ( b = 1; b <= bevelSegments; b ++ ) {
    	for ( b = bevelSegments - 1; b >= 0; b -- ) {

    		t = b / bevelSegments;
    		z = bevelThickness * Math.cos ( t * Math.PI / 2 );
    		bs = bevelSize * Math.sin( t * Math.PI / 2 );

    		// contract shape

    		for ( i = 0, il = contour.length; i < il; i ++ ) {

    			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
    			v( vert.x, vert.y,  amount + z );

    		}

    		// expand holes

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			oneHoleMovements = holesMovements[ h ];

    			for ( i = 0, il = ahole.length; i < il; i ++ ) {

    				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    				if ( ! extrudeByPath ) {

    					v( vert.x, vert.y,  amount + z );

    				} else {

    					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

    				}

    			}

    		}

    	}

    	/* Faces */

    	// Top and bottom faces

    	buildLidFaces();

    	// Sides faces

    	buildSideFaces();


    	/////  Internal functions

    	function buildLidFaces() {

    		if ( bevelEnabled ) {

    			var layer = 0; // steps + 1
    			var offset = vlen * layer;

    			// Bottom faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

    			}

    			layer = steps + bevelSegments * 2;
    			offset = vlen * layer;

    			// Top faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

    			}

    		} else {

    			// Bottom faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

    			}

    			// Top faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

    			}

    		}

    	}

    	// Create faces for the z-sides of the shape

    	function buildSideFaces() {

    		var layeroffset = 0;
    		sidewalls( contour, layeroffset );
    		layeroffset += contour.length;

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			sidewalls( ahole, layeroffset );

    			//, true
    			layeroffset += ahole.length;

    		}

    	}

    	function sidewalls( contour, layeroffset ) {

    		var j, k;
    		i = contour.length;

    		while ( -- i >= 0 ) {

    			j = i;
    			k = i - 1;
    			if ( k < 0 ) k = contour.length - 1;

    			//console.log('b', i,j, i-1, k,vertices.length);

    			var s = 0, sl = steps  + bevelSegments * 2;

    			for ( s = 0; s < sl; s ++ ) {

    				var slen1 = vlen * s;
    				var slen2 = vlen * ( s + 1 );

    				var a = layeroffset + j + slen1,
    					b = layeroffset + k + slen1,
    					c = layeroffset + k + slen2,
    					d = layeroffset + j + slen2;

    				f4( a, b, c, d, contour, s, sl, j, k );

    			}

    		}

    	}


    	function v( x, y, z ) {

    		scope.vertices.push( new Vector3( x, y, z ) );

    	}

    	function f3( a, b, c ) {

    		a += shapesOffset;
    		b += shapesOffset;
    		c += shapesOffset;

    		scope.faces.push( new Face3( a, b, c, null, null, 0 ) );

    		var uvs = uvgen.generateTopUV( scope, a, b, c );

    		scope.faceVertexUvs[ 0 ].push( uvs );

    	}

    	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

    		a += shapesOffset;
    		b += shapesOffset;
    		c += shapesOffset;
    		d += shapesOffset;

    		scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
    		scope.faces.push( new Face3( b, c, d, null, null, 1 ) );

    		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

    		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
    		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

    	}

    };

    ExtrudeGeometry.WorldUVGenerator = {

    	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

    		var vertices = geometry.vertices;

    		var a = vertices[ indexA ];
    		var b = vertices[ indexB ];
    		var c = vertices[ indexC ];

    		return [
    			new Vector2( a.x, a.y ),
    			new Vector2( b.x, b.y ),
    			new Vector2( c.x, c.y )
    		];

    	},

    	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

    		var vertices = geometry.vertices;

    		var a = vertices[ indexA ];
    		var b = vertices[ indexB ];
    		var c = vertices[ indexC ];
    		var d = vertices[ indexD ];

    		if ( Math.abs( a.y - b.y ) < 0.01 ) {

    			return [
    				new Vector2( a.x, 1 - a.z ),
    				new Vector2( b.x, 1 - b.z ),
    				new Vector2( c.x, 1 - c.z ),
    				new Vector2( d.x, 1 - d.z )
    			];

    		} else {

    			return [
    				new Vector2( a.y, 1 - a.z ),
    				new Vector2( b.y, 1 - b.z ),
    				new Vector2( c.y, 1 - c.z ),
    				new Vector2( d.y, 1 - d.z )
    			];

    		}

    	}
    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author alteredq / http://alteredqualia.com/
     *
     * Text = 3D Text
     *
     * parameters = {
     *  font: <THREE.Font>, // font
     *
     *  size: <float>, // size of the text
     *  height: <float>, // thickness to extrude text
     *  curveSegments: <int>, // number of points on the curves
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into text bevel goes
     *  bevelSize: <float> // how far from text outline is bevel
     * }
     */

    function TextGeometry( text, parameters ) {

    	parameters = parameters || {};

    	var font = parameters.font;

    	if ( (font && font.isFont) === false ) {

    		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
    		return new Geometry();

    	}

    	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

    	// translate parameters to ExtrudeGeometry API

    	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    	// defaults

    	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    	ExtrudeGeometry.call( this, shapes, parameters );

    	this.type = 'TextGeometry';

    }

    TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
    TextGeometry.prototype.constructor = TextGeometry;

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     * based on THREE.SphereGeometry
     */

    function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'SphereBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		phiStart: phiStart,
    		phiLength: phiLength,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	radius = radius || 50;

    	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    	phiStart = phiStart !== undefined ? phiStart : 0;
    	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    	var thetaEnd = thetaStart + thetaLength;

    	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    	var positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	var index = 0, vertices = [], normal = new Vector3();

    	for ( var y = 0; y <= heightSegments; y ++ ) {

    		var verticesRow = [];

    		var v = y / heightSegments;

    		for ( var x = 0; x <= widthSegments; x ++ ) {

    			var u = x / widthSegments;

    			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
    			var py = radius * Math.cos( thetaStart + v * thetaLength );
    			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

    			normal.set( px, py, pz ).normalize();

    			positions.setXYZ( index, px, py, pz );
    			normals.setXYZ( index, normal.x, normal.y, normal.z );
    			uvs.setXY( index, u, 1 - v );

    			verticesRow.push( index );

    			index ++;

    		}

    		vertices.push( verticesRow );

    	}

    	var indices = [];

    	for ( var y = 0; y < heightSegments; y ++ ) {

    		for ( var x = 0; x < widthSegments; x ++ ) {

    			var v1 = vertices[ y ][ x + 1 ];
    			var v2 = vertices[ y ][ x ];
    			var v3 = vertices[ y + 1 ][ x ];
    			var v4 = vertices[ y + 1 ][ x + 1 ];

    			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
    			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

    		}

    	}

    	this.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
    	this.addAttribute( 'position', positions );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	this.boundingSphere = new Sphere( new Vector3(), radius );

    }

    SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'SphereGeometry';

    	this.parameters = {
    		radius: radius,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		phiStart: phiStart,
    		phiLength: phiLength,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

    }

    SphereGeometry.prototype = Object.create( Geometry.prototype );
    SphereGeometry.prototype.constructor = SphereGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'RingBufferGeometry';

    	this.parameters = {
    		innerRadius: innerRadius,
    		outerRadius: outerRadius,
    		thetaSegments: thetaSegments,
    		phiSegments: phiSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	innerRadius = innerRadius || 20;
    	outerRadius = outerRadius || 50;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

    	// these are used to calculate buffer length
    	var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
    	var indexCount = thetaSegments * phiSegments * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// some helper variables
    	var index = 0, indexOffset = 0, segment;
    	var radius = innerRadius;
    	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
    	var vertex = new Vector3();
    	var uv = new Vector2();
    	var j, i;

    	// generate vertices, normals and uvs

    	// values are generate from the inside of the ring to the outside

    	for ( j = 0; j <= phiSegments; j ++ ) {

    		for ( i = 0; i <= thetaSegments; i ++ ) {

    			segment = thetaStart + i / thetaSegments * thetaLength;

    			// vertex
    			vertex.x = radius * Math.cos( segment );
    			vertex.y = radius * Math.sin( segment );
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal
    			normals.setXYZ( index, 0, 0, 1 );

    			// uv
    			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
    			uv.y = ( vertex.y / outerRadius + 1 ) / 2;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index++;

    		}

    		// increase the radius for next row of vertices
    		radius += radiusStep;

    	}

    	// generate indices

    	for ( j = 0; j < phiSegments; j ++ ) {

    		var thetaSegmentLevel = j * ( thetaSegments + 1 );

    		for ( i = 0; i < thetaSegments; i ++ ) {

    			segment = i + thetaSegmentLevel;

    			// indices
    			var a = segment;
    			var b = segment + thetaSegments + 1;
    			var c = segment + thetaSegments + 2;
    			var d = segment + 1;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    }

    RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;

    /**
     * @author Kaleb Murphy
     */

    function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'RingGeometry';

    	this.parameters = {
    		innerRadius: innerRadius,
    		outerRadius: outerRadius,
    		thetaSegments: thetaSegments,
    		phiSegments: phiSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

    }

    RingGeometry.prototype = Object.create( Geometry.prototype );
    RingGeometry.prototype.constructor = RingGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */

    function PlaneGeometry( width, height, widthSegments, heightSegments ) {

    	Geometry.call( this );

    	this.type = 'PlaneGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments
    	};

    	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

    }

    PlaneGeometry.prototype = Object.create( Geometry.prototype );
    PlaneGeometry.prototype.constructor = PlaneGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

     // points - to create a closed torus, one must use a set of points
     //    like so: [ a, b, c, d, a ], see first is the same as last.
     // segments - the number of circumference segments to create
     // phiStart - the starting radian
     // phiLength - the radian (0 to 2PI) range of the lathed section
     //    2PI is a closed lathe, less than 2PI is a portion.

    function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

    	BufferGeometry.call( this );

    	this.type = 'LatheBufferGeometry';

    	this.parameters = {
    		points: points,
    		segments: segments,
    		phiStart: phiStart,
    		phiLength: phiLength
    	};

    	segments = Math.floor( segments ) || 12;
    	phiStart = phiStart || 0;
    	phiLength = phiLength || Math.PI * 2;

    	// clamp phiLength so it's in range of [ 0, 2PI ]
    	phiLength = exports.Math.clamp( phiLength, 0, Math.PI * 2 );

    	// these are used to calculate buffer length
    	var vertexCount = ( segments + 1 ) * points.length;
    	var indexCount = segments * points.length * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables
    	var index = 0, indexOffset = 0, base;
    	var inverseSegments = 1.0 / segments;
    	var vertex = new Vector3();
    	var uv = new Vector2();
    	var i, j;

    	// generate vertices and uvs

    	for ( i = 0; i <= segments; i ++ ) {

    		var phi = phiStart + i * inverseSegments * phiLength;

    		var sin = Math.sin( phi );
    		var cos = Math.cos( phi );

    		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

    			// vertex
    			vertex.x = points[ j ].x * sin;
    			vertex.y = points[ j ].y;
    			vertex.z = points[ j ].x * cos;
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// uv
    			uv.x = i / segments;
    			uv.y = j / ( points.length - 1 );
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    	}

    	// generate indices

    	for ( i = 0; i < segments; i ++ ) {

    		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

    			base = j + i * points.length;

    			// indices
    			var a = base;
    			var b = base + points.length;
    			var c = base + points.length + 1;
    			var d = base + 1;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'uv', uvs );

    	// generate normals

    	this.computeVertexNormals();

    	// if the geometry is closed, we need to average the normals along the seam.
    	// because the corresponding vertices are identical (but still have different UVs).

    	if( phiLength === Math.PI * 2 ) {

    		var normals = this.attributes.normal.array;
    		var n1 = new Vector3();
    		var n2 = new Vector3();
    		var n = new Vector3();

    		// this is the buffer offset for the last line of vertices
    		base = segments * points.length * 3;

    		for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

    			// select the normal of the vertex in the first line
    			n1.x = normals[ j + 0 ];
    			n1.y = normals[ j + 1 ];
    			n1.z = normals[ j + 2 ];

    			// select the normal of the vertex in the last line
    			n2.x = normals[ base + j + 0 ];
    			n2.y = normals[ base + j + 1 ];
    			n2.z = normals[ base + j + 2 ];

    			// average normals
    			n.addVectors( n1, n2 ).normalize();

    			// assign the new values to both normals
    			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
    			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
    			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

    		} // next row

    	}

    }

    LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

    /**
     * @author astrodud / http://astrodud.isgreat.org/
     * @author zz85 / https://github.com/zz85
     * @author bhouston / http://clara.io
     */

    // points - to create a closed torus, one must use a set of points
    //    like so: [ a, b, c, d, a ], see first is the same as last.
    // segments - the number of circumference segments to create
    // phiStart - the starting radian
    // phiLength - the radian (0 to 2PI) range of the lathed section
    //    2PI is a closed lathe, less than 2PI is a portion.

    function LatheGeometry( points, segments, phiStart, phiLength ) {

    	Geometry.call( this );

    	this.type = 'LatheGeometry';

    	this.parameters = {
    		points: points,
    		segments: segments,
    		phiStart: phiStart,
    		phiLength: phiLength
    	};

    	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
    	this.mergeVertices();

    }

    LatheGeometry.prototype = Object.create( Geometry.prototype );
    LatheGeometry.prototype.constructor = LatheGeometry;

    /**
     * @author jonobr1 / http://jonobr1.com
     *
     * Creates a one-sided polygonal geometry from a path shape. Similar to
     * ExtrudeGeometry.
     *
     * parameters = {
     *
     *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
     *
     *	material: <int> // material index for front and back faces
     *	uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/

    function ShapeGeometry( shapes, options ) {

    	Geometry.call( this );

    	this.type = 'ShapeGeometry';

    	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

    	this.addShapeList( shapes, options );

    	this.computeFaceNormals();

    }

    ShapeGeometry.prototype = Object.create( Geometry.prototype );
    ShapeGeometry.prototype.constructor = ShapeGeometry;

    /**
     * Add an array of shapes to THREE.ShapeGeometry.
     */
    ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

    	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

    		this.addShape( shapes[ i ], options );

    	}

    	return this;

    };

    /**
     * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
     */
    ShapeGeometry.prototype.addShape = function ( shape, options ) {

    	if ( options === undefined ) options = {};
    	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    	var material = options.material;
    	var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

    	//

    	var i, l, hole;

    	var shapesOffset = this.vertices.length;
    	var shapePoints = shape.extractPoints( curveSegments );

    	var vertices = shapePoints.shape;
    	var holes = shapePoints.holes;

    	var reverse = ! exports.ShapeUtils.isClockWise( vertices );

    	if ( reverse ) {

    		vertices = vertices.reverse();

    		// Maybe we should also check if holes are in the opposite direction, just to be safe...

    		for ( i = 0, l = holes.length; i < l; i ++ ) {

    			hole = holes[ i ];

    			if ( exports.ShapeUtils.isClockWise( hole ) ) {

    				holes[ i ] = hole.reverse();

    			}

    		}

    		reverse = false;

    	}

    	var faces = exports.ShapeUtils.triangulateShape( vertices, holes );

    	// Vertices

    	for ( i = 0, l = holes.length; i < l; i ++ ) {

    		hole = holes[ i ];
    		vertices = vertices.concat( hole );

    	}

    	//

    	var vert, vlen = vertices.length;
    	var face, flen = faces.length;

    	for ( i = 0; i < vlen; i ++ ) {

    		vert = vertices[ i ];

    		this.vertices.push( new Vector3( vert.x, vert.y, 0 ) );

    	}

    	for ( i = 0; i < flen; i ++ ) {

    		face = faces[ i ];

    		var a = face[ 0 ] + shapesOffset;
    		var b = face[ 1 ] + shapesOffset;
    		var c = face[ 2 ] + shapesOffset;

    		this.faces.push( new Face3( a, b, c, null, null, material ) );
    		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

    	}

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     */

    function EdgesGeometry( geometry, thresholdAngle ) {

    	BufferGeometry.call( this );

    	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    	var thresholdDot = Math.cos( exports.Math.DEG2RAD * thresholdAngle );

    	var edge = [ 0, 0 ], hash = {};

    	function sortFunction( a, b ) {

    		return a - b;

    	}

    	var keys = [ 'a', 'b', 'c' ];

    	var geometry2;

    	if ( (geometry && geometry.isBufferGeometry) ) {

    		geometry2 = new Geometry();
    		geometry2.fromBufferGeometry( geometry );

    	} else {

    		geometry2 = geometry.clone();

    	}

    	geometry2.mergeVertices();
    	geometry2.computeFaceNormals();

    	var vertices = geometry2.vertices;
    	var faces = geometry2.faces;

    	for ( var i = 0, l = faces.length; i < l; i ++ ) {

    		var face = faces[ i ];

    		for ( var j = 0; j < 3; j ++ ) {

    			edge[ 0 ] = face[ keys[ j ] ];
    			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
    			edge.sort( sortFunction );

    			var key = edge.toString();

    			if ( hash[ key ] === undefined ) {

    				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

    			} else {

    				hash[ key ].face2 = i;

    			}

    		}

    	}

    	var coords = [];

    	for ( var key in hash ) {

    		var h = hash[ key ];

    		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

    			var vertex = vertices[ h.vert1 ];
    			coords.push( vertex.x );
    			coords.push( vertex.y );
    			coords.push( vertex.z );

    			vertex = vertices[ h.vert2 ];
    			coords.push( vertex.x );
    			coords.push( vertex.y );
    			coords.push( vertex.z );

    		}

    	}

    	this.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );

    }

    EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
    EdgesGeometry.prototype.constructor = EdgesGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'CylinderBufferGeometry';

    	this.parameters = {
    		radiusTop: radiusTop,
    		radiusBottom: radiusBottom,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	var scope = this;

    	radiusTop = radiusTop !== undefined ? radiusTop : 20;
    	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    	height = height !== undefined ? height : 100;

    	radialSegments = Math.floor( radialSegments ) || 8;
    	heightSegments = Math.floor( heightSegments ) || 1;

    	openEnded = openEnded !== undefined ? openEnded : false;
    	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
    	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

    	// used to calculate buffer length

    	var nbCap = 0;

    	if ( openEnded === false ) {

    		if ( radiusTop > 0 ) nbCap ++;
    		if ( radiusBottom > 0 ) nbCap ++;

    	}

    	var vertexCount = calculateVertexCount();
    	var indexCount = calculateIndexCount();

    	// buffers

    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables

    	var index = 0,
    	    indexOffset = 0,
    	    indexArray = [],
    	    halfHeight = height / 2;

    	// group variables
    	var groupStart = 0;

    	// generate geometry

    	generateTorso();

    	if ( openEnded === false ) {

    		if ( radiusTop > 0 ) generateCap( true );
    		if ( radiusBottom > 0 ) generateCap( false );

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	// helper functions

    	function calculateVertexCount() {

    		var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

    		if ( openEnded === false ) {

    			count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );

    		}

    		return count;

    	}

    	function calculateIndexCount() {

    		var count = radialSegments * heightSegments * 2 * 3;

    		if ( openEnded === false ) {

    			count += radialSegments * nbCap * 3;

    		}

    		return count;

    	}

    	function generateTorso() {

    		var x, y;
    		var normal = new Vector3();
    		var vertex = new Vector3();

    		var groupCount = 0;

    		// this will be used to calculate the normal
    		var slope = ( radiusBottom - radiusTop ) / height;

    		// generate vertices, normals and uvs

    		for ( y = 0; y <= heightSegments; y ++ ) {

    			var indexRow = [];

    			var v = y / heightSegments;

    			// calculate the radius of the current row
    			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    			for ( x = 0; x <= radialSegments; x ++ ) {

    				var u = x / radialSegments;

    				var theta = u * thetaLength + thetaStart;

    				var sinTheta = Math.sin( theta );
    				var cosTheta = Math.cos( theta );

    				// vertex
    				vertex.x = radius * sinTheta;
    				vertex.y = - v * height + halfHeight;
    				vertex.z = radius * cosTheta;
    				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    				// normal
    				normal.set( sinTheta, slope, cosTheta ).normalize();
    				normals.setXYZ( index, normal.x, normal.y, normal.z );

    				// uv
    				uvs.setXY( index, u, 1 - v );

    				// save index of vertex in respective row
    				indexRow.push( index );

    				// increase index
    				index ++;

    			}

    			// now save vertices of the row in our index array
    			indexArray.push( indexRow );

    		}

    		// generate indices

    		for ( x = 0; x < radialSegments; x ++ ) {

    			for ( y = 0; y < heightSegments; y ++ ) {

    				// we use the index array to access the correct indices
    				var i1 = indexArray[ y ][ x ];
    				var i2 = indexArray[ y + 1 ][ x ];
    				var i3 = indexArray[ y + 1 ][ x + 1 ];
    				var i4 = indexArray[ y ][ x + 1 ];

    				// face one
    				indices.setX( indexOffset, i1 ); indexOffset ++;
    				indices.setX( indexOffset, i2 ); indexOffset ++;
    				indices.setX( indexOffset, i4 ); indexOffset ++;

    				// face two
    				indices.setX( indexOffset, i2 ); indexOffset ++;
    				indices.setX( indexOffset, i3 ); indexOffset ++;
    				indices.setX( indexOffset, i4 ); indexOffset ++;

    				// update counters
    				groupCount += 6;

    			}

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, 0 );

    		// calculate new start value for groups
    		groupStart += groupCount;

    	}

    	function generateCap( top ) {

    		var x, centerIndexStart, centerIndexEnd;

    		var uv = new Vector2();
    		var vertex = new Vector3();

    		var groupCount = 0;

    		var radius = ( top === true ) ? radiusTop : radiusBottom;
    		var sign = ( top === true ) ? 1 : - 1;

    		// save the index of the first center vertex
    		centerIndexStart = index;

    		// first we generate the center vertex data of the cap.
    		// because the geometry needs one set of uvs per face,
    		// we must generate a center vertex per face/segment

    		for ( x = 1; x <= radialSegments; x ++ ) {

    			// vertex
    			vertices.setXYZ( index, 0, halfHeight * sign, 0 );

    			// normal
    			normals.setXYZ( index, 0, sign, 0 );

    			// uv
    			uv.x = 0.5;
    			uv.y = 0.5;

    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    		// save the index of the last center vertex
    		centerIndexEnd = index;

    		// now we generate the surrounding vertices, normals and uvs

    		for ( x = 0; x <= radialSegments; x ++ ) {

    			var u = x / radialSegments;
    			var theta = u * thetaLength + thetaStart;

    			var cosTheta = Math.cos( theta );
    			var sinTheta = Math.sin( theta );

    			// vertex
    			vertex.x = radius * sinTheta;
    			vertex.y = halfHeight * sign;
    			vertex.z = radius * cosTheta;
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal
    			normals.setXYZ( index, 0, sign, 0 );

    			// uv
    			uv.x = ( cosTheta * 0.5 ) + 0.5;
    			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    		// generate indices

    		for ( x = 0; x < radialSegments; x ++ ) {

    			var c = centerIndexStart + x;
    			var i = centerIndexEnd + x;

    			if ( top === true ) {

    				// face top
    				indices.setX( indexOffset, i ); indexOffset ++;
    				indices.setX( indexOffset, i + 1 ); indexOffset ++;
    				indices.setX( indexOffset, c ); indexOffset ++;

    			} else {

    				// face bottom
    				indices.setX( indexOffset, i + 1 ); indexOffset ++;
    				indices.setX( indexOffset, i ); indexOffset ++;
    				indices.setX( indexOffset, c ); indexOffset ++;

    			}

    			// update counters
    			groupCount += 3;

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

    		// calculate new start value for groups
    		groupStart += groupCount;

    	}

    }

    CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'CylinderGeometry';

    	this.parameters = {
    		radiusTop: radiusTop,
    		radiusBottom: radiusBottom,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
    	this.mergeVertices();

    }

    CylinderGeometry.prototype = Object.create( Geometry.prototype );
    CylinderGeometry.prototype.constructor = CylinderGeometry;

    /**
     * @author abelnation / http://github.com/abelnation
     */

    function ConeGeometry(
    	radius, height,
    	radialSegments, heightSegments,
    	openEnded, thetaStart, thetaLength ) {

    	CylinderGeometry.call( this,
    		0, radius, height,
    		radialSegments, heightSegments,
    		openEnded, thetaStart, thetaLength );

    	this.type = 'ConeGeometry';

    	this.parameters = {
    		radius: radius,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    }

    ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
    ConeGeometry.prototype.constructor = ConeGeometry;

    /*
     * @author: abelnation / http://github.com/abelnation
     */

    function ConeBufferGeometry(
    	radius, height,
    	radialSegments, heightSegments,
    	openEnded, thetaStart, thetaLength ) {

    	CylinderBufferGeometry.call( this,
    		0, radius, height,
    		radialSegments, heightSegments,
    		openEnded, thetaStart, thetaLength );

    	this.type = 'ConeBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    }

    ConeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'CircleBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		segments: segments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	radius = radius || 50;
    	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    	var vertices = segments + 2;

    	var positions = new Float32Array( vertices * 3 );
    	var normals = new Float32Array( vertices * 3 );
    	var uvs = new Float32Array( vertices * 2 );

    	// center data is already zero, but need to set a few extras
    	normals[ 2 ] = 1.0;
    	uvs[ 0 ] = 0.5;
    	uvs[ 1 ] = 0.5;

    	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

    		var segment = thetaStart + s / segments * thetaLength;

    		positions[ i ] = radius * Math.cos( segment );
    		positions[ i + 1 ] = radius * Math.sin( segment );

    		normals[ i + 2 ] = 1; // normal z

    		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
    		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

    	}

    	var indices = [];

    	for ( var i = 1; i <= segments; i ++ ) {

    		indices.push( i, i + 1, 0 );

    	}

    	this.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    	this.boundingSphere = new Sphere( new Vector3(), radius );

    }

    CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

    /**
     * @author hughes
     */

    function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'CircleGeometry';

    	this.parameters = {
    		radius: radius,
    		segments: segments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

    }

    CircleGeometry.prototype = Object.create( Geometry.prototype );
    CircleGeometry.prototype.constructor = CircleGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
     */

    function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    	Geometry.call( this );

    	this.type = 'BoxGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		depth: depth,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		depthSegments: depthSegments
    	};

    	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
    	this.mergeVertices();

    }

    BoxGeometry.prototype = Object.create( Geometry.prototype );
    BoxGeometry.prototype.constructor = BoxGeometry;



    var Geometries = Object.freeze({
    	WireframeGeometry: WireframeGeometry,
    	ParametricGeometry: ParametricGeometry,
    	TetrahedronGeometry: TetrahedronGeometry,
    	OctahedronGeometry: OctahedronGeometry,
    	IcosahedronGeometry: IcosahedronGeometry,
    	DodecahedronGeometry: DodecahedronGeometry,
    	PolyhedronGeometry: PolyhedronGeometry,
    	TubeGeometry: TubeGeometry,
    	TorusKnotGeometry: TorusKnotGeometry,
    	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
    	TorusGeometry: TorusGeometry,
    	TorusBufferGeometry: TorusBufferGeometry,
    	TextGeometry: TextGeometry,
    	SphereBufferGeometry: SphereBufferGeometry,
    	SphereGeometry: SphereGeometry,
    	RingGeometry: RingGeometry,
    	RingBufferGeometry: RingBufferGeometry,
    	PlaneBufferGeometry: PlaneBufferGeometry,
    	PlaneGeometry: PlaneGeometry,
    	LatheGeometry: LatheGeometry,
    	LatheBufferGeometry: LatheBufferGeometry,
    	ShapeGeometry: ShapeGeometry,
    	ExtrudeGeometry: ExtrudeGeometry,
    	EdgesGeometry: EdgesGeometry,
    	ConeGeometry: ConeGeometry,
    	ConeBufferGeometry: ConeBufferGeometry,
    	CylinderGeometry: CylinderGeometry,
    	CylinderBufferGeometry: CylinderBufferGeometry,
    	CircleBufferGeometry: CircleBufferGeometry,
    	CircleGeometry: CircleGeometry,
    	BoxBufferGeometry: BoxBufferGeometry,
    	BoxGeometry: BoxGeometry
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ShadowMaterial() {

    	ShaderMaterial.call( this, {
    		uniforms: exports.UniformsUtils.merge( [
    			UniformsLib[ "lights" ],
    			{
    				opacity: { value: 1.0 }
    			}
    		] ),
    		vertexShader: ShaderChunk[ 'shadow_vert' ],
    		fragmentShader: ShaderChunk[ 'shadow_frag' ]
    	} );

    	this.lights = true;
    	this.transparent = true;

    	Object.defineProperties( this, {
    		opacity: {
    			enumerable: true,
    			get: function () {
    				return this.uniforms.opacity.value;
    			},
    			set: function ( value ) {
    				this.uniforms.opacity.value = value;
    			}
    		}
    	} );

    }

    ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
    ShadowMaterial.prototype.constructor = ShadowMaterial;

    ShadowMaterial.prototype.isShadowMaterial = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function RawShaderMaterial( parameters ) {

    	ShaderMaterial.call( this, parameters );

    	this.type = 'RawShaderMaterial';

    }

    RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;

    RawShaderMaterial.prototype.isRawShaderMaterial = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function MultiMaterial( materials ) {

    	this.uuid = exports.Math.generateUUID();

    	this.type = 'MultiMaterial';

    	this.materials = materials instanceof Array ? materials : [];

    	this.visible = true;

    }

    MultiMaterial.prototype = {

    	constructor: MultiMaterial,

    	isMultiMaterial: true,

    	toJSON: function ( meta ) {

    		var output = {
    			metadata: {
    				version: 4.2,
    				type: 'material',
    				generator: 'MaterialExporter'
    			},
    			uuid: this.uuid,
    			type: this.type,
    			materials: []
    		};

    		var materials = this.materials;

    		for ( var i = 0, l = materials.length; i < l; i ++ ) {

    			var material = materials[ i ].toJSON( meta );
    			delete material.metadata;

    			output.materials.push( material );

    		}

    		output.visible = this.visible;

    		return output;

    	},

    	clone: function () {

    		var material = new this.constructor();

    		for ( var i = 0; i < this.materials.length; i ++ ) {

    			material.materials.push( this.materials[ i ].clone() );

    		}

    		material.visible = this.visible;

    		return material;

    	}

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  roughness: <float>,
     *  metalness: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  roughnessMap: new THREE.Texture( <Image> ),
     *
     *  metalnessMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  envMapIntensity: <float>
     *
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshStandardMaterial( parameters ) {

    	Material.call( this );

    	this.defines = { 'STANDARD': '' };

    	this.type = 'MeshStandardMaterial';

    	this.color = new Color( 0xffffff ); // diffuse
    	this.roughness = 0.5;
    	this.metalness = 0.5;

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.bumpMap = null;
    	this.bumpScale = 1;

    	this.normalMap = null;
    	this.normalScale = new Vector2( 1, 1 );

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.roughnessMap = null;

    	this.metalnessMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.envMapIntensity = 1.0;

    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshStandardMaterial.prototype = Object.create( Material.prototype );
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

    MeshStandardMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.defines = { 'STANDARD': '' };

    	this.color.copy( source.color );
    	this.roughness = source.roughness;
    	this.metalness = source.metalness;

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.bumpMap = source.bumpMap;
    	this.bumpScale = source.bumpScale;

    	this.normalMap = source.normalMap;
    	this.normalScale.copy( source.normalScale );

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.roughnessMap = source.roughnessMap;

    	this.metalnessMap = source.metalnessMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.envMapIntensity = source.envMapIntensity;

    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  reflectivity: <float>
     * }
     */

    function MeshPhysicalMaterial( parameters ) {

    	MeshStandardMaterial.call( this );

    	this.defines = { 'PHYSICAL': '' };

    	this.type = 'MeshPhysicalMaterial';

    	this.reflectivity = 0.5; // maps to F0 = 0.04

    	this.clearCoat = 0.0;
    	this.clearCoatRoughness = 0.0;

    	this.setValues( parameters );

    }

    MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

    MeshPhysicalMaterial.prototype.copy = function ( source ) {

    	MeshStandardMaterial.prototype.copy.call( this, source );

    	this.defines = { 'PHYSICAL': '' };

    	this.reflectivity = source.reflectivity;

    	this.clearCoat = source.clearCoat;
    	this.clearCoatRoughness = source.clearCoatRoughness;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshPhongMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshPhongMaterial';

    	this.color = new Color( 0xffffff ); // diffuse
    	this.specular = new Color( 0x111111 );
    	this.shininess = 30;

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.bumpMap = null;
    	this.bumpScale = 1;

    	this.normalMap = null;
    	this.normalScale = new Vector2( 1, 1 );

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshPhongMaterial.prototype = Object.create( Material.prototype );
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

    MeshPhongMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );
    	this.specular.copy( source.specular );
    	this.shininess = source.shininess;

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.bumpMap = source.bumpMap;
    	this.bumpScale = source.bumpScale;

    	this.normalMap = source.normalMap;
    	this.normalScale.copy( source.normalScale );

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * parameters = {
     *  opacity: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */

    function MeshNormalMaterial( parameters ) {

    	Material.call( this, parameters );

    	this.type = 'MeshNormalMaterial';

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false;
    	this.lights = false;
    	this.morphTargets = false;

    	this.setValues( parameters );

    }

    MeshNormalMaterial.prototype = Object.create( Material.prototype );
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

    MeshNormalMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshLambertMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshLambertMaterial';

    	this.color = new Color( 0xffffff ); // diffuse

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshLambertMaterial.prototype = Object.create( Material.prototype );
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

    MeshLambertMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *
     *  scale: <float>,
     *  dashSize: <float>,
     *  gapSize: <float>
     * }
     */

    function LineDashedMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'LineDashedMaterial';

    	this.color = new Color( 0xffffff );

    	this.linewidth = 1;

    	this.scale = 1;
    	this.dashSize = 3;
    	this.gapSize = 1;

    	this.lights = false;

    	this.setValues( parameters );

    }

    LineDashedMaterial.prototype = Object.create( Material.prototype );
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;

    LineDashedMaterial.prototype.isLineDashedMaterial = true;

    LineDashedMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.linewidth = source.linewidth;

    	this.scale = source.scale;
    	this.dashSize = source.dashSize;
    	this.gapSize = source.gapSize;

    	return this;

    };



    var Materials = Object.freeze({
    	ShadowMaterial: ShadowMaterial,
    	SpriteMaterial: SpriteMaterial,
    	RawShaderMaterial: RawShaderMaterial,
    	ShaderMaterial: ShaderMaterial,
    	PointsMaterial: PointsMaterial,
    	MultiMaterial: MultiMaterial,
    	MeshPhysicalMaterial: MeshPhysicalMaterial,
    	MeshStandardMaterial: MeshStandardMaterial,
    	MeshPhongMaterial: MeshPhongMaterial,
    	MeshNormalMaterial: MeshNormalMaterial,
    	MeshLambertMaterial: MeshLambertMaterial,
    	MeshDepthMaterial: MeshDepthMaterial,
    	MeshBasicMaterial: MeshBasicMaterial,
    	LineDashedMaterial: LineDashedMaterial,
    	LineBasicMaterial: LineBasicMaterial,
    	Material: Material
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    exports.Cache = {

    	enabled: false,

    	files: {},

    	add: function ( key, file ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Adding key:', key );

    		this.files[ key ] = file;

    	},

    	get: function ( key ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Checking key:', key );

    		return this.files[ key ];

    	},

    	remove: function ( key ) {

    		delete this.files[ key ];

    	},

    	clear: function () {

    		this.files = {};

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LoadingManager( onLoad, onProgress, onError ) {

    	var scope = this;

    	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

    	this.onStart = undefined;
    	this.onLoad = onLoad;
    	this.onProgress = onProgress;
    	this.onError = onError;

    	this.itemStart = function ( url ) {

    		itemsTotal ++;

    		if ( isLoading === false ) {

    			if ( scope.onStart !== undefined ) {

    				scope.onStart( url, itemsLoaded, itemsTotal );

    			}

    		}

    		isLoading = true;

    	};

    	this.itemEnd = function ( url ) {

    		itemsLoaded ++;

    		if ( scope.onProgress !== undefined ) {

    			scope.onProgress( url, itemsLoaded, itemsTotal );

    		}

    		if ( itemsLoaded === itemsTotal ) {

    			isLoading = false;

    			if ( scope.onLoad !== undefined ) {

    				scope.onLoad();

    			}

    		}

    	};

    	this.itemError = function ( url ) {

    		if ( scope.onError !== undefined ) {

    			scope.onError( url );

    		}

    	};

    }

    exports.DefaultLoadingManager = new LoadingManager();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function XHRLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( XHRLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		if ( this.path !== undefined ) url = this.path + url;

    		var scope = this;

    		var cached = exports.Cache.get( url );

    		if ( cached !== undefined ) {

    			scope.manager.itemStart( url );

    			setTimeout( function () {

    				if ( onLoad ) onLoad( cached );

    				scope.manager.itemEnd( url );

    			}, 0 );

    			return cached;

    		}

    		var request = new XMLHttpRequest();
    		request.open( 'GET', url, true );

    		request.addEventListener( 'load', function ( event ) {

    			var response = event.target.response;

    			exports.Cache.add( url, response );

    			if ( this.status === 200 ) {

    				if ( onLoad ) onLoad( response );

    				scope.manager.itemEnd( url );

    			} else if ( this.status === 0 ) {

    				// Some browsers return HTTP Status 0 when using non-http protocol
    				// e.g. 'file://' or 'data://'. Handle as success.

    				console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );

    				if ( onLoad ) onLoad( response );

    				scope.manager.itemEnd( url );

    			} else {

    				if ( onError ) onError( event );

    				scope.manager.itemError( url );

    			}

    		}, false );

    		if ( onProgress !== undefined ) {

    			request.addEventListener( 'progress', function ( event ) {

    				onProgress( event );

    			}, false );

    		}

    		request.addEventListener( 'error', function ( event ) {

    			if ( onError ) onError( event );

    			scope.manager.itemError( url );

    		}, false );

    		if ( this.responseType !== undefined ) request.responseType = this.responseType;
    		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

    		if ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );

    		request.send( null );

    		scope.manager.itemStart( url );

    		return request;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	},

    	setResponseType: function ( value ) {

    		this.responseType = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * Abstract Base class to block based textures loader (dds, pvr, ...)
     */

    function CompressedTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	// override in sub classes
    	this._parser = null;

    }

    Object.assign( CompressedTextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var images = [];

    		var texture = new CompressedTexture();
    		texture.image = images;

    		var loader = new XHRLoader( this.manager );
    		loader.setPath( this.path );
    		loader.setResponseType( 'arraybuffer' );

    		function loadTexture( i ) {

    			loader.load( url[ i ], function ( buffer ) {

    				var texDatas = scope._parser( buffer, true );

    				images[ i ] = {
    					width: texDatas.width,
    					height: texDatas.height,
    					format: texDatas.format,
    					mipmaps: texDatas.mipmaps
    				};

    				loaded += 1;

    				if ( loaded === 6 ) {

    					if ( texDatas.mipmapCount === 1 )
    						texture.minFilter = LinearFilter;

    					texture.format = texDatas.format;
    					texture.needsUpdate = true;

    					if ( onLoad ) onLoad( texture );

    				}

    			}, onProgress, onError );

    		}

    		if ( Array.isArray( url ) ) {

    			var loaded = 0;

    			for ( var i = 0, il = url.length; i < il; ++ i ) {

    				loadTexture( i );

    			}

    		} else {

    			// compressed cubemap texture stored in a single DDS file

    			loader.load( url, function ( buffer ) {

    				var texDatas = scope._parser( buffer, true );

    				if ( texDatas.isCubemap ) {

    					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

    					for ( var f = 0; f < faces; f ++ ) {

    						images[ f ] = { mipmaps : [] };

    						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

    							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
    							images[ f ].format = texDatas.format;
    							images[ f ].width = texDatas.width;
    							images[ f ].height = texDatas.height;

    						}

    					}

    				} else {

    					texture.image.width = texDatas.width;
    					texture.image.height = texDatas.height;
    					texture.mipmaps = texDatas.mipmaps;

    				}

    				if ( texDatas.mipmapCount === 1 ) {

    					texture.minFilter = LinearFilter;

    				}

    				texture.format = texDatas.format;
    				texture.needsUpdate = true;

    				if ( onLoad ) onLoad( texture );

    			}, onProgress, onError );

    		}

    		return texture;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author Nikos M. / https://github.com/foo123/
     *
     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
     */

    var DataTextureLoader = BinaryTextureLoader;
    function BinaryTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	// override in sub classes
    	this._parser = null;

    }

    Object.assign( BinaryTextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var texture = new DataTexture();

    		var loader = new XHRLoader( this.manager );
    		loader.setResponseType( 'arraybuffer' );

    		loader.load( url, function ( buffer ) {

    			var texData = scope._parser( buffer );

    			if ( ! texData ) return;

    			if ( undefined !== texData.image ) {

    				texture.image = texData.image;

    			} else if ( undefined !== texData.data ) {

    				texture.image.width = texData.width;
    				texture.image.height = texData.height;
    				texture.image.data = texData.data;

    			}

    			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
    			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

    			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
    			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

    			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

    			if ( undefined !== texData.format ) {

    				texture.format = texData.format;

    			}
    			if ( undefined !== texData.type ) {

    				texture.type = texData.type;

    			}

    			if ( undefined !== texData.mipmaps ) {

    				texture.mipmaps = texData.mipmaps;

    			}

    			if ( 1 === texData.mipmapCount ) {

    				texture.minFilter = LinearFilter;

    			}

    			texture.needsUpdate = true;

    			if ( onLoad ) onLoad( texture, texData );

    		}, onProgress, onError );


    		return texture;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ImageLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( ImageLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
    		image.onload = function () {

    			image.onload = null;

    			URL.revokeObjectURL( image.src );

    			if ( onLoad ) onLoad( image );

    			scope.manager.itemEnd( url );

    		};

    		if ( url.indexOf( 'data:' ) === 0 ) {

    			image.src = url;

    		} else {

    			var loader = new XHRLoader();
    			loader.setPath( this.path );
    			loader.setResponseType( 'blob' );
    			loader.setWithCredentials( this.withCredentials );
    			loader.load( url, function ( blob ) {

    				image.src = URL.createObjectURL( blob );

    			}, onProgress, onError );

    		}

    		scope.manager.itemStart( url );

    		return image;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( CubeTextureLoader.prototype, {

    	load: function ( urls, onLoad, onProgress, onError ) {

    		var texture = new CubeTexture();

    		var loader = new ImageLoader( this.manager );
    		loader.setCrossOrigin( this.crossOrigin );
    		loader.setPath( this.path );

    		var loaded = 0;

    		function loadTexture( i ) {

    			loader.load( urls[ i ], function ( image ) {

    				texture.images[ i ] = image;

    				loaded ++;

    				if ( loaded === 6 ) {

    					texture.needsUpdate = true;

    					if ( onLoad ) onLoad( texture );

    				}

    			}, undefined, onError );

    		}

    		for ( var i = 0; i < urls.length; ++ i ) {

    			loadTexture( i );

    		}

    		return texture;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function TextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( TextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var texture = new Texture();

    		var loader = new ImageLoader( this.manager );
    		loader.setCrossOrigin( this.crossOrigin );
    		loader.setWithCredentials( this.withCredentials );
    		loader.setPath( this.path );
    		loader.load( url, function ( image ) {

    			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
    			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

    			texture.format = isJPEG ? RGBFormat : RGBAFormat;
    			texture.image = image;
    			texture.needsUpdate = true;

    			if ( onLoad !== undefined ) {

    				onLoad( texture );

    			}

    		}, onProgress, onError );

    		return texture;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}



    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Light( color, intensity ) {

    	Object3D.call( this );

    	this.type = 'Light';

    	this.color = new Color( color );
    	this.intensity = intensity !== undefined ? intensity : 1;

    	this.receiveShadow = undefined;

    }

    Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Light,

    	isLight: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.color.copy( source.color );
    		this.intensity = source.intensity;

    		return this;

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.color = this.color.getHex();
    		data.object.intensity = this.intensity;

    		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

    		if ( this.distance !== undefined ) data.object.distance = this.distance;
    		if ( this.angle !== undefined ) data.object.angle = this.angle;
    		if ( this.decay !== undefined ) data.object.decay = this.decay;
    		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

    		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function HemisphereLight( skyColor, groundColor, intensity ) {

    	Light.call( this, skyColor, intensity );

    	this.type = 'HemisphereLight';

    	this.castShadow = undefined;

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.groundColor = new Color( groundColor );

    }

    HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: HemisphereLight,

    	isHemisphereLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.groundColor.copy( source.groundColor );

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LightShadow( camera ) {

    	this.camera = camera;

    	this.bias = 0;
    	this.radius = 1;

    	this.mapSize = new Vector2( 512, 512 );

    	this.map = null;
    	this.matrix = new Matrix4();

    }

    Object.assign( LightShadow.prototype, {

    	copy: function ( source ) {

    		this.camera = source.camera.clone();

    		this.bias = source.bias;
    		this.radius = source.radius;

    		this.mapSize.copy( source.mapSize );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	toJSON: function () {

    		var object = {};

    		if ( this.bias !== 0 ) object.bias = this.bias;
    		if ( this.radius !== 1 ) object.radius = this.radius;
    		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

    		object.camera = this.camera.toJSON( false ).object;
    		delete object.camera.matrix;

    		return object;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function SpotLightShadow() {

    	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

    }

    SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    	constructor: SpotLightShadow,

    	isSpotLightShadow: true,

    	update: function ( light ) {

    		var fov = exports.Math.RAD2DEG * 2 * light.angle;
    		var aspect = this.mapSize.width / this.mapSize.height;
    		var far = light.distance || 500;

    		var camera = this.camera;

    		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

    			camera.fov = fov;
    			camera.aspect = aspect;
    			camera.far = far;
    			camera.updateProjectionMatrix();

    		}

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

    	Light.call( this, color, intensity );

    	this.type = 'SpotLight';

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.target = new Object3D();

    	Object.defineProperty( this, 'power', {
    		get: function () {
    			// intensity = power per solid angle.
    			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			return this.intensity * Math.PI;
    		},
    		set: function ( power ) {
    			// intensity = power per solid angle.
    			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			this.intensity = power / Math.PI;
    		}
    	} );

    	this.distance = ( distance !== undefined ) ? distance : 0;
    	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
    	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    	this.shadow = new SpotLightShadow();

    }

    SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: SpotLight,

    	isSpotLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.distance = source.distance;
    		this.angle = source.angle;
    		this.penumbra = source.penumbra;
    		this.decay = source.decay;

    		this.target = source.target.clone();

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */


    function PointLight( color, intensity, distance, decay ) {

    	Light.call( this, color, intensity );

    	this.type = 'PointLight';

    	Object.defineProperty( this, 'power', {
    		get: function () {
    			// intensity = power per solid angle.
    			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			return this.intensity * 4 * Math.PI;

    		},
    		set: function ( power ) {
    			// intensity = power per solid angle.
    			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			this.intensity = power / ( 4 * Math.PI );
    		}
    	} );

    	this.distance = ( distance !== undefined ) ? distance : 0;
    	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

    }

    PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: PointLight,

    	isPointLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.distance = source.distance;
    		this.decay = source.decay;

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectionalLightShadow( light ) {

    	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

    }

    DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    	constructor: DirectionalLightShadow

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function DirectionalLight( color, intensity ) {

    	Light.call( this, color, intensity );

    	this.type = 'DirectionalLight';

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.target = new Object3D();

    	this.shadow = new DirectionalLightShadow();

    }

    DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: DirectionalLight,

    	isDirectionalLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.target = source.target.clone();

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AmbientLight( color, intensity ) {

    	Light.call( this, color, intensity );

    	this.type = 'AmbientLight';

    	this.castShadow = undefined;

    }

    AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: AmbientLight,

    	isAmbientLight: true,

    } );

    /**
     * @author tschw
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    exports.AnimationUtils = {

    	// same as Array.prototype.slice, but also works on typed arrays
    	arraySlice: function( array, from, to ) {

    		if ( exports.AnimationUtils.isTypedArray( array ) ) {

    			return new array.constructor( array.subarray( from, to ) );

    		}

    		return array.slice( from, to );

    	},

    	// converts an array to a specific type
    	convertArray: function( array, type, forceClone ) {

    		if ( ! array || // let 'undefined' and 'null' pass
    				! forceClone && array.constructor === type ) return array;

    		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

    			return new type( array ); // create typed array

    		}

    		return Array.prototype.slice.call( array ); // create Array

    	},

    	isTypedArray: function( object ) {

    		return ArrayBuffer.isView( object ) &&
    				! ( object instanceof DataView );

    	},

    	// returns an array by which times and values can be sorted
    	getKeyframeOrder: function( times ) {

    		function compareTime( i, j ) {

    			return times[ i ] - times[ j ];

    		}

    		var n = times.length;
    		var result = new Array( n );
    		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

    		result.sort( compareTime );

    		return result;

    	},

    	// uses the array previously returned by 'getKeyframeOrder' to sort data
    	sortedArray: function( values, stride, order ) {

    		var nValues = values.length;
    		var result = new values.constructor( nValues );

    		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

    			var srcOffset = order[ i ] * stride;

    			for ( var j = 0; j !== stride; ++ j ) {

    				result[ dstOffset ++ ] = values[ srcOffset + j ];

    			}

    		}

    		return result;

    	},

    	// function for parsing AOS keyframe formats
    	flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

    		var i = 1, key = jsonKeys[ 0 ];

    		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

    			key = jsonKeys[ i ++ ];

    		}

    		if ( key === undefined ) return; // no data

    		var value = key[ valuePropertyName ];
    		if ( value === undefined ) return; // no data

    		if ( Array.isArray( value ) ) {

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					values.push.apply( values, value ); // push all elements

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		} else if ( value.toArray !== undefined ) {
    			// ...assume THREE.Math-ish

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					value.toArray( values, values.length );

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		} else {
    			// otherwise push as-is

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					values.push( value );

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		}

    	}

    };

    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     * 		http://www.oodesign.com/template-method-pattern.html
     *
     * @author tschw
     */

    function Interpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	this.parameterPositions = parameterPositions;
    	this._cachedIndex = 0;

    	this.resultBuffer = resultBuffer !== undefined ?
    			resultBuffer : new sampleValues.constructor( sampleSize );
    	this.sampleValues = sampleValues;
    	this.valueSize = sampleSize;

    }

    Interpolant.prototype = {

    	constructor: Interpolant,

    	evaluate: function( t ) {

    		var pp = this.parameterPositions,
    			i1 = this._cachedIndex,

    			t1 = pp[   i1   ],
    			t0 = pp[ i1 - 1 ];

    		validate_interval: {

    			seek: {

    				var right;

    				linear_scan: {
    //- See http://jsperf.com/comparison-to-undefined/3
    //- slower code:
    //-
    //- 				if ( t >= t1 || t1 === undefined ) {
    					forward_scan: if ( ! ( t < t1 ) ) {

    						for ( var giveUpAt = i1 + 2; ;) {

    							if ( t1 === undefined ) {

    								if ( t < t0 ) break forward_scan;

    								// after end

    								i1 = pp.length;
    								this._cachedIndex = i1;
    								return this.afterEnd_( i1 - 1, t, t0 );

    							}

    							if ( i1 === giveUpAt ) break; // this loop

    							t0 = t1;
    							t1 = pp[ ++ i1 ];

    							if ( t < t1 ) {

    								// we have arrived at the sought interval
    								break seek;

    							}

    						}

    						// prepare binary search on the right side of the index
    						right = pp.length;
    						break linear_scan;

    					}

    //- slower code:
    //-					if ( t < t0 || t0 === undefined ) {
    					if ( ! ( t >= t0 ) ) {

    						// looping?

    						var t1global = pp[ 1 ];

    						if ( t < t1global ) {

    							i1 = 2; // + 1, using the scan for the details
    							t0 = t1global;

    						}

    						// linear reverse scan

    						for ( var giveUpAt = i1 - 2; ;) {

    							if ( t0 === undefined ) {

    								// before start

    								this._cachedIndex = 0;
    								return this.beforeStart_( 0, t, t1 );

    							}

    							if ( i1 === giveUpAt ) break; // this loop

    							t1 = t0;
    							t0 = pp[ -- i1 - 1 ];

    							if ( t >= t0 ) {

    								// we have arrived at the sought interval
    								break seek;

    							}

    						}

    						// prepare binary search on the left side of the index
    						right = i1;
    						i1 = 0;
    						break linear_scan;

    					}

    					// the interval is valid

    					break validate_interval;

    				} // linear scan

    				// binary search

    				while ( i1 < right ) {

    					var mid = ( i1 + right ) >>> 1;

    					if ( t < pp[ mid ] ) {

    						right = mid;

    					} else {

    						i1 = mid + 1;

    					}

    				}

    				t1 = pp[   i1   ];
    				t0 = pp[ i1 - 1 ];

    				// check boundary cases, again

    				if ( t0 === undefined ) {

    					this._cachedIndex = 0;
    					return this.beforeStart_( 0, t, t1 );

    				}

    				if ( t1 === undefined ) {

    					i1 = pp.length;
    					this._cachedIndex = i1;
    					return this.afterEnd_( i1 - 1, t0, t );

    				}

    			} // seek

    			this._cachedIndex = i1;

    			this.intervalChanged_( i1, t0, t1 );

    		} // validate_interval

    		return this.interpolate_( i1, t0, t, t1 );

    	},

    	settings: null, // optional, subclass-specific settings structure
    	// Note: The indirection allows central control of many interpolants.

    	// --- Protected interface

    	DefaultSettings_: {},

    	getSettings_: function() {

    		return this.settings || this.DefaultSettings_;

    	},

    	copySampleValue_: function( index ) {

    		// copies a sample value to the result buffer

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,
    			offset = index * stride;

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] = values[ offset + i ];

    		}

    		return result;

    	},

    	// Template methods for derived classes:

    	interpolate_: function( i1, t0, t, t1 ) {

    		throw new Error( "call to abstract method" );
    		// implementations shall return this.resultBuffer

    	},

    	intervalChanged_: function( i1, t0, t1 ) {

    		// empty

    	}

    };

    Object.assign( Interpolant.prototype, {

    	beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
    		Interpolant.prototype.copySampleValue_,

    	afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
    		Interpolant.prototype.copySampleValue_

    } );

    /**
     * Fast and simple cubic spline interpolant.
     *
     * It was derived from a Hermitian construction setting the first derivative
     * at each sample position to the linear slope between neighboring positions
     * over their parameter interval.
     *
     * @author tschw
     */

    function CubicInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    	this._weightPrev = -0;
    	this._offsetPrev = -0;
    	this._weightNext = -0;
    	this._offsetNext = -0;

    }

    CubicInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: CubicInterpolant,

    	DefaultSettings_: {

    		endingStart: 	ZeroCurvatureEnding,
    		endingEnd:		ZeroCurvatureEnding

    	},

    	intervalChanged_: function( i1, t0, t1 ) {

    		var pp = this.parameterPositions,
    			iPrev = i1 - 2,
    			iNext = i1 + 1,

    			tPrev = pp[ iPrev ],
    			tNext = pp[ iNext ];

    		if ( tPrev === undefined ) {

    			switch ( this.getSettings_().endingStart ) {

    				case ZeroSlopeEnding:

    					// f'(t0) = 0
    					iPrev = i1;
    					tPrev = 2 * t0 - t1;

    					break;

    				case WrapAroundEnding:

    					// use the other end of the curve
    					iPrev = pp.length - 2;
    					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

    					break;

    				default: // ZeroCurvatureEnding

    					// f''(t0) = 0 a.k.a. Natural Spline
    					iPrev = i1;
    					tPrev = t1;

    			}

    		}

    		if ( tNext === undefined ) {

    			switch ( this.getSettings_().endingEnd ) {

    				case ZeroSlopeEnding:

    					// f'(tN) = 0
    					iNext = i1;
    					tNext = 2 * t1 - t0;

    					break;

    				case WrapAroundEnding:

    					// use the other end of the curve
    					iNext = 1;
    					tNext = t1 + pp[ 1 ] - pp[ 0 ];

    					break;

    				default: // ZeroCurvatureEnding

    					// f''(tN) = 0, a.k.a. Natural Spline
    					iNext = i1 - 1;
    					tNext = t0;

    			}

    		}

    		var halfDt = ( t1 - t0 ) * 0.5,
    			stride = this.valueSize;

    		this._weightPrev = halfDt / ( t0 - tPrev );
    		this._weightNext = halfDt / ( tNext - t1 );
    		this._offsetPrev = iPrev * stride;
    		this._offsetNext = iNext * stride;

    	},

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			o1 = i1 * stride,		o0 = o1 - stride,
    			oP = this._offsetPrev, 	oN = this._offsetNext,
    			wP = this._weightPrev,	wN = this._weightNext,

    			p = ( t - t0 ) / ( t1 - t0 ),
    			pp = p * p,
    			ppp = pp * p;

    		// evaluate polynomials

    		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
    		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
    		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
    		var sN =       wN   * ppp   -           wN      * pp;

    		// combine data linearly

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] =
    					sP * values[ oP + i ] +
    					s0 * values[ o0 + i ] +
    					s1 * values[ o1 + i ] +
    					sN * values[ oN + i ];

    		}

    		return result;

    	}

    } );

    /**
     * @author tschw
     */

    function LinearInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    LinearInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: LinearInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			offset1 = i1 * stride,
    			offset0 = offset1 - stride,

    			weight1 = ( t - t0 ) / ( t1 - t0 ),
    			weight0 = 1 - weight1;

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] =
    					values[ offset0 + i ] * weight0 +
    					values[ offset1 + i ] * weight1;

    		}

    		return result;

    	}

    } );

    /**
     *
     * Interpolant that evaluates to the sample value at the position preceeding
     * the parameter.
     *
     * @author tschw
     */

    function DiscreteInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    DiscreteInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: DiscreteInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		return this.copySampleValue_( i1 - 1 );

    	}

    } );

    var KeyframeTrackPrototype;

    KeyframeTrackPrototype = {

    	TimeBufferType: Float32Array,
    	ValueBufferType: Float32Array,

    	DefaultInterpolation: InterpolateLinear,

    	InterpolantFactoryMethodDiscrete: function( result ) {

    		return new DiscreteInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodLinear: function( result ) {

    		return new LinearInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodSmooth: function( result ) {

    		return new CubicInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	setInterpolation: function( interpolation ) {

    		var factoryMethod;

    		switch ( interpolation ) {

    			case InterpolateDiscrete:

    				factoryMethod = this.InterpolantFactoryMethodDiscrete;

    				break;

    			case InterpolateLinear:

    				factoryMethod = this.InterpolantFactoryMethodLinear;

    				break;

    			case InterpolateSmooth:

    				factoryMethod = this.InterpolantFactoryMethodSmooth;

    				break;

    		}

    		if ( factoryMethod === undefined ) {

    			var message = "unsupported interpolation for " +
    					this.ValueTypeName + " keyframe track named " + this.name;

    			if ( this.createInterpolant === undefined ) {

    				// fall back to default, unless the default itself is messed up
    				if ( interpolation !== this.DefaultInterpolation ) {

    					this.setInterpolation( this.DefaultInterpolation );

    				} else {

    					throw new Error( message ); // fatal, in this case

    				}

    			}

    			console.warn( message );
    			return;

    		}

    		this.createInterpolant = factoryMethod;

    	},

    	getInterpolation: function() {

    		switch ( this.createInterpolant ) {

    			case this.InterpolantFactoryMethodDiscrete:

    				return InterpolateDiscrete;

    			case this.InterpolantFactoryMethodLinear:

    				return InterpolateLinear;

    			case this.InterpolantFactoryMethodSmooth:

    				return InterpolateSmooth;

    		}

    	},

    	getValueSize: function() {

    		return this.values.length / this.times.length;

    	},

    	// move all keyframes either forwards or backwards in time
    	shift: function( timeOffset ) {

    		if( timeOffset !== 0.0 ) {

    			var times = this.times;

    			for( var i = 0, n = times.length; i !== n; ++ i ) {

    				times[ i ] += timeOffset;

    			}

    		}

    		return this;

    	},

    	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    	scale: function( timeScale ) {

    		if( timeScale !== 1.0 ) {

    			var times = this.times;

    			for( var i = 0, n = times.length; i !== n; ++ i ) {

    				times[ i ] *= timeScale;

    			}

    		}

    		return this;

    	},

    	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    	trim: function( startTime, endTime ) {

    		var times = this.times,
    			nKeys = times.length,
    			from = 0,
    			to = nKeys - 1;

    		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
    		while ( to !== -1 && times[ to ] > endTime ) -- to;

    		++ to; // inclusive -> exclusive bound

    		if( from !== 0 || to !== nKeys ) {

    			// empty tracks are forbidden, so keep at least one keyframe
    			if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;

    			var stride = this.getValueSize();
    			this.times = exports.AnimationUtils.arraySlice( times, from, to );
    			this.values = exports.AnimationUtils.
    					arraySlice( this.values, from * stride, to * stride );

    		}

    		return this;

    	},

    	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    	validate: function() {

    		var valid = true;

    		var valueSize = this.getValueSize();
    		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

    			console.error( "invalid value size in track", this );
    			valid = false;

    		}

    		var times = this.times,
    			values = this.values,

    			nKeys = times.length;

    		if( nKeys === 0 ) {

    			console.error( "track is empty", this );
    			valid = false;

    		}

    		var prevTime = null;

    		for( var i = 0; i !== nKeys; i ++ ) {

    			var currTime = times[ i ];

    			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

    				console.error( "time is not a valid number", this, i, currTime );
    				valid = false;
    				break;

    			}

    			if( prevTime !== null && prevTime > currTime ) {

    				console.error( "out of order keys", this, i, currTime, prevTime );
    				valid = false;
    				break;

    			}

    			prevTime = currTime;

    		}

    		if ( values !== undefined ) {

    			if ( exports.AnimationUtils.isTypedArray( values ) ) {

    				for ( var i = 0, n = values.length; i !== n; ++ i ) {

    					var value = values[ i ];

    					if ( isNaN( value ) ) {

    						console.error( "value is not a valid number", this, i, value );
    						valid = false;
    						break;

    					}

    				}

    			}

    		}

    		return valid;

    	},

    	// removes equivalent sequential keys as common in morph target sequences
    	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    	optimize: function() {

    		var times = this.times,
    			values = this.values,
    			stride = this.getValueSize(),

    			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

    			writeIndex = 1,
    			lastIndex = times.length - 1;

    		for( var i = 1; i < lastIndex; ++ i ) {

    			var keep = false;

    			var time = times[ i ];
    			var timeNext = times[ i + 1 ];

    			// remove adjacent keyframes scheduled at the same time

    			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

    				if ( ! smoothInterpolation ) {

    					// remove unnecessary keyframes same as their neighbors

    					var offset = i * stride,
    						offsetP = offset - stride,
    						offsetN = offset + stride;

    					for ( var j = 0; j !== stride; ++ j ) {

    						var value = values[ offset + j ];

    						if ( value !== values[ offsetP + j ] ||
    								value !== values[ offsetN + j ] ) {

    							keep = true;
    							break;

    						}

    					}

    				} else keep = true;

    			}

    			// in-place compaction

    			if ( keep ) {

    				if ( i !== writeIndex ) {

    					times[ writeIndex ] = times[ i ];

    					var readOffset = i * stride,
    						writeOffset = writeIndex * stride;

    					for ( var j = 0; j !== stride; ++ j )

    						values[ writeOffset + j ] = values[ readOffset + j ];

    				}

    				++ writeIndex;

    			}

    		}

    		// flush last keyframe (compaction looks ahead)

    		if ( lastIndex > 0 ) {

    			times[ writeIndex ] = times[ lastIndex ];

    			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

    				values[ writeOffset + j ] = values[ readOffset + j ];

    			++ writeIndex;

    		}

    		if ( writeIndex !== times.length ) {

    			this.times = exports.AnimationUtils.arraySlice( times, 0, writeIndex );
    			this.values = exports.AnimationUtils.arraySlice( values, 0, writeIndex * stride );

    		}

    		return this;

    	}

    }

    function KeyframeTrackConstructor( name, times, values, interpolation ) {

    	if( name === undefined ) throw new Error( "track name is undefined" );

    	if( times === undefined || times.length === 0 ) {

    		throw new Error( "no keyframes in track named " + name );

    	}

    	this.name = name;

    	this.times = exports.AnimationUtils.convertArray( times, this.TimeBufferType );
    	this.values = exports.AnimationUtils.convertArray( values, this.ValueBufferType );

    	this.setInterpolation( interpolation || this.DefaultInterpolation );

    	this.validate();
    	this.optimize();

    }

    /**
     *
     * A Track of vectored keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function VectorKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    VectorKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: VectorKeyframeTrack,

    	ValueTypeName: 'vector'

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited

    } );

    /**
     * Spherical linear unit quaternion interpolant.
     *
     * @author tschw
     */

    function QuaternionLinearInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    QuaternionLinearInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: QuaternionLinearInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			offset = i1 * stride,

    			alpha = ( t - t0 ) / ( t1 - t0 );

    		for ( var end = offset + stride; offset !== end; offset += 4 ) {

    			Quaternion.slerpFlat( result, 0,
    					values, offset - stride, values, offset, alpha );

    		}

    		return result;

    	}

    } );

    /**
     *
     * A Track of quaternion keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function QuaternionKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    QuaternionKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: QuaternionKeyframeTrack,

    	ValueTypeName: 'quaternion',

    	// ValueBufferType is inherited

    	DefaultInterpolation: InterpolateLinear,

    	InterpolantFactoryMethodLinear: function( result ) {

    		return new QuaternionLinearInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodSmooth: undefined // not yet implemented

    } );

    /**
     *
     * A Track of numeric keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function NumberKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    NumberKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: NumberKeyframeTrack,

    	ValueTypeName: 'number',

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited

    } );

    /**
     *
     * A Track that interpolates Strings
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function StringKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    StringKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: StringKeyframeTrack,

    	ValueTypeName: 'string',
    	ValueBufferType: Array,

    	DefaultInterpolation: InterpolateDiscrete,

    	InterpolantFactoryMethodLinear: undefined,

    	InterpolantFactoryMethodSmooth: undefined

    } );

    /**
     *
     * A Track of Boolean keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function BooleanKeyframeTrack( name, times, values ) {

    	KeyframeTrackConstructor.call( this, name, times, values );

    }

    BooleanKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: BooleanKeyframeTrack,

    	ValueTypeName: 'bool',
    	ValueBufferType: Array,

    	DefaultInterpolation: InterpolateDiscrete,

    	InterpolantFactoryMethodLinear: undefined,
    	InterpolantFactoryMethodSmooth: undefined

    	// Note: Actually this track could have a optimized / compressed
    	// representation of a single value and a custom interpolant that
    	// computes "firstValue ^ isOdd( index )".

    } );

    /**
     *
     * A Track of keyframe values that represent color.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function ColorKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    ColorKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: ColorKeyframeTrack,

    	ValueTypeName: 'color'

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited


    	// Note: Very basic implementation and nothing special yet.
    	// However, this is the place for color space parameterization.

    } );

    /**
     *
     * A timed sequence of keyframes for a specific property.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function KeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.apply( this, arguments );

    }

    KeyframeTrack.prototype = KeyframeTrackPrototype;
    KeyframeTrackPrototype.constructor = KeyframeTrack;

    // Static methods:

    Object.assign( KeyframeTrack, {

    	// Serialization (in static context, because of constructor invocation
    	// and automatic invocation of .toJSON):

    	parse: function( json ) {

    		if( json.type === undefined ) {

    			throw new Error( "track type undefined, can not parse" );

    		}

    		var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

    		if ( json.times === undefined ) {

    			var times = [], values = [];

    			exports.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

    			json.times = times;
    			json.values = values;

    		}

    		// derived classes can define a static parse method
    		if ( trackType.parse !== undefined ) {

    			return trackType.parse( json );

    		} else {

    			// by default, we asssume a constructor compatible with the base
    			return new trackType(
    					json.name, json.times, json.values, json.interpolation );

    		}

    	},

    	toJSON: function( track ) {

    		var trackType = track.constructor;

    		var json;

    		// derived classes can define a static toJSON method
    		if ( trackType.toJSON !== undefined ) {

    			json = trackType.toJSON( track );

    		} else {

    			// by default, we assume the data can be serialized as-is
    			json = {

    				'name': track.name,
    				'times': exports.AnimationUtils.convertArray( track.times, Array ),
    				'values': exports.AnimationUtils.convertArray( track.values, Array )

    			};

    			var interpolation = track.getInterpolation();

    			if ( interpolation !== track.DefaultInterpolation ) {

    				json.interpolation = interpolation;

    			}

    		}

    		json.type = track.ValueTypeName; // mandatory

    		return json;

    	},

    	_getTrackTypeForValueTypeName: function( typeName ) {

    		switch( typeName.toLowerCase() ) {

    			case "scalar":
    			case "double":
    			case "float":
    			case "number":
    			case "integer":

    				return NumberKeyframeTrack;

    			case "vector":
    			case "vector2":
    			case "vector3":
    			case "vector4":

    				return VectorKeyframeTrack;

    			case "color":

    				return ColorKeyframeTrack;

    			case "quaternion":

    				return QuaternionKeyframeTrack;

    			case "bool":
    			case "boolean":

    				return BooleanKeyframeTrack;

    			case "string":

    				return StringKeyframeTrack;

    		}

    		throw new Error( "Unsupported typeName: " + typeName );

    	}

    } );

    /**
     *
     * Reusable set of Tracks that represent an animation.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    function AnimationClip( name, duration, tracks ) {

    	this.name = name;
    	this.tracks = tracks;
    	this.duration = ( duration !== undefined ) ? duration : -1;

    	this.uuid = exports.Math.generateUUID();

    	// this means it should figure out its duration by scanning the tracks
    	if ( this.duration < 0 ) {

    		this.resetDuration();

    	}

    	this.optimize();

    }

    AnimationClip.prototype = {

    	constructor: AnimationClip,

    	resetDuration: function() {

    		var tracks = this.tracks,
    			duration = 0;

    		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

    			var track = this.tracks[ i ];

    			duration = Math.max(
    					duration, track.times[ track.times.length - 1 ] );

    		}

    		this.duration = duration;

    	},

    	trim: function() {

    		for ( var i = 0; i < this.tracks.length; i ++ ) {

    			this.tracks[ i ].trim( 0, this.duration );

    		}

    		return this;

    	},

    	optimize: function() {

    		for ( var i = 0; i < this.tracks.length; i ++ ) {

    			this.tracks[ i ].optimize();

    		}

    		return this;

    	}

    };

    // Static methods:

    Object.assign( AnimationClip, {

    	parse: function( json ) {

    		var tracks = [],
    			jsonTracks = json.tracks,
    			frameTime = 1.0 / ( json.fps || 1.0 );

    		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

    			tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

    		}

    		return new AnimationClip( json.name, json.duration, tracks );

    	},


    	toJSON: function( clip ) {

    		var tracks = [],
    			clipTracks = clip.tracks;

    		var json = {

    			'name': clip.name,
    			'duration': clip.duration,
    			'tracks': tracks

    		};

    		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

    			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

    		}

    		return json;

    	},


    	CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

    		var numMorphTargets = morphTargetSequence.length;
    		var tracks = [];

    		for ( var i = 0; i < numMorphTargets; i ++ ) {

    			var times = [];
    			var values = [];

    			times.push(
    					( i + numMorphTargets - 1 ) % numMorphTargets,
    					i,
    					( i + 1 ) % numMorphTargets );

    			values.push( 0, 1, 0 );

    			var order = exports.AnimationUtils.getKeyframeOrder( times );
    			times = exports.AnimationUtils.sortedArray( times, 1, order );
    			values = exports.AnimationUtils.sortedArray( values, 1, order );

    			// if there is a key at the first frame, duplicate it as the
    			// last frame as well for perfect loop.
    			if ( ! noLoop && times[ 0 ] === 0 ) {

    				times.push( numMorphTargets );
    				values.push( values[ 0 ] );

    			}

    			tracks.push(
    					new NumberKeyframeTrack(
    						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
    						times, values
    					).scale( 1.0 / fps ) );
    		}

    		return new AnimationClip( name, -1, tracks );

    	},

    	findByName: function( objectOrClipArray, name ) {

    		var clipArray = objectOrClipArray;

    		if ( ! Array.isArray( objectOrClipArray ) ) {

    			var o = objectOrClipArray;
    			clipArray = o.geometry && o.geometry.animations || o.animations;

    		}

    		for ( var i = 0; i < clipArray.length; i ++ ) {

    			if ( clipArray[ i ].name === name ) {

    				return clipArray[ i ];

    			}
    		}

    		return null;

    	},

    	CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

    		var animationToMorphTargets = {};

    		// tested with https://regex101.com/ on trick sequences
    		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
    		var pattern = /^([\w-]*?)([\d]+)$/;

    		// sort morph target names into animation groups based
    		// patterns like Walk_001, Walk_002, Run_001, Run_002
    		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

    			var morphTarget = morphTargets[ i ];
    			var parts = morphTarget.name.match( pattern );

    			if ( parts && parts.length > 1 ) {

    				var name = parts[ 1 ];

    				var animationMorphTargets = animationToMorphTargets[ name ];
    				if ( ! animationMorphTargets ) {

    					animationToMorphTargets[ name ] = animationMorphTargets = [];

    				}

    				animationMorphTargets.push( morphTarget );

    			}

    		}

    		var clips = [];

    		for ( var name in animationToMorphTargets ) {

    			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

    		}

    		return clips;

    	},

    	// parse the animation.hierarchy format
    	parseAnimation: function( animation, bones ) {

    		if ( ! animation ) {

    			console.error( "  no animation in JSONLoader data" );
    			return null;

    		}

    		var addNonemptyTrack = function(
    				trackType, trackName, animationKeys, propertyName, destTracks ) {

    			// only return track if there are actually keys.
    			if ( animationKeys.length !== 0 ) {

    				var times = [];
    				var values = [];

    				exports.AnimationUtils.flattenJSON(
    						animationKeys, times, values, propertyName );

    				// empty keys are filtered out, so check again
    				if ( times.length !== 0 ) {

    					destTracks.push( new trackType( trackName, times, values ) );

    				}

    			}

    		};

    		var tracks = [];

    		var clipName = animation.name || 'default';
    		// automatic length determination in AnimationClip.
    		var duration = animation.length || -1;
    		var fps = animation.fps || 30;

    		var hierarchyTracks = animation.hierarchy || [];

    		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

    			var animationKeys = hierarchyTracks[ h ].keys;

    			// skip empty tracks
    			if ( ! animationKeys || animationKeys.length === 0 ) continue;

    			// process morph targets in a way exactly compatible
    			// with AnimationHandler.init( animation )
    			if ( animationKeys[0].morphTargets ) {

    				// figure out all morph targets used in this track
    				var morphTargetNames = {};
    				for ( var k = 0; k < animationKeys.length; k ++ ) {

    					if ( animationKeys[k].morphTargets ) {

    						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

    							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
    						}

    					}

    				}

    				// create a track for each morph target with all zero
    				// morphTargetInfluences except for the keys in which
    				// the morphTarget is named.
    				for ( var morphTargetName in morphTargetNames ) {

    					var times = [];
    					var values = [];

    					for ( var m = 0;
    							m !== animationKeys[k].morphTargets.length; ++ m ) {

    						var animationKey = animationKeys[k];

    						times.push( animationKey.time );
    						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

    					}

    					tracks.push( new NumberKeyframeTrack(
    							'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

    				}

    				duration = morphTargetNames.length * ( fps || 1.0 );

    			} else {
    				// ...assume skeletal animation

    				var boneName = '.bones[' + bones[ h ].name + ']';

    				addNonemptyTrack(
    						VectorKeyframeTrack, boneName + '.position',
    						animationKeys, 'pos', tracks );

    				addNonemptyTrack(
    						QuaternionKeyframeTrack, boneName + '.quaternion',
    						animationKeys, 'rot', tracks );

    				addNonemptyTrack(
    						VectorKeyframeTrack, boneName + '.scale',
    						animationKeys, 'scl', tracks );

    			}

    		}

    		if ( tracks.length === 0 ) {

    			return null;

    		}

    		var clip = new AnimationClip( clipName, duration, tracks );

    		return clip;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function MaterialLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;
    	this.textures = {};

    }

    Object.assign( MaterialLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			onLoad( scope.parse( JSON.parse( text ) ) );

    		}, onProgress, onError );

    	},

    	setTextures: function ( value ) {

    		this.textures = value;

    	},

    	parse: function ( json ) {

    		var textures = this.textures;

    		function getTexture( name ) {

    			if ( textures[ name ] === undefined ) {

    				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

    			}

    			return textures[ name ];

    		}

    		var material = new Materials[ json.type ]();

    		if ( json.uuid !== undefined ) material.uuid = json.uuid;
    		if ( json.name !== undefined ) material.name = json.name;
    		if ( json.color !== undefined ) material.color.setHex( json.color );
    		if ( json.roughness !== undefined ) material.roughness = json.roughness;
    		if ( json.metalness !== undefined ) material.metalness = json.metalness;
    		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
    		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
    		if ( json.shininess !== undefined ) material.shininess = json.shininess;
    		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
    		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
    		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
    		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
    		if ( json.fog !== undefined ) material.fog = json.fog;
    		if ( json.shading !== undefined ) material.shading = json.shading;
    		if ( json.blending !== undefined ) material.blending = json.blending;
    		if ( json.side !== undefined ) material.side = json.side;
    		if ( json.opacity !== undefined ) material.opacity = json.opacity;
    		if ( json.transparent !== undefined ) material.transparent = json.transparent;
    		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
    		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
    		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
    		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
    		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
    		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
    		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
    		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
    		if ( json.skinning !== undefined ) material.skinning = json.skinning;
    		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

    		// for PointsMaterial

    		if ( json.size !== undefined ) material.size = json.size;
    		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

    		// maps

    		if ( json.map !== undefined ) material.map = getTexture( json.map );

    		if ( json.alphaMap !== undefined ) {

    			material.alphaMap = getTexture( json.alphaMap );
    			material.transparent = true;

    		}

    		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
    		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

    		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
    		if ( json.normalScale !== undefined ) {

    			var normalScale = json.normalScale;

    			if ( Array.isArray( normalScale ) === false ) {

    				// Blender exporter used to export a scalar. See #7459

    				normalScale = [ normalScale, normalScale ];

    			}

    			material.normalScale = new Vector2().fromArray( normalScale );

    		}

    		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
    		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
    		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

    		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
    		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

    		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
    		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

    		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

    		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

    		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

    		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
    		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

    		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
    		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

    		// MultiMaterial

    		if ( json.materials !== undefined ) {

    			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

    				material.materials.push( this.parse( json.materials[ i ] ) );

    			}

    		}

    		return material;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometryLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( BufferGeometryLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			onLoad( scope.parse( JSON.parse( text ) ) );

    		}, onProgress, onError );

    	},

    	parse: function ( json ) {

    		var geometry = new BufferGeometry();

    		var index = json.data.index;

    		var TYPED_ARRAYS = {
    			'Int8Array': Int8Array,
    			'Uint8Array': Uint8Array,
    			'Uint8ClampedArray': Uint8ClampedArray,
    			'Int16Array': Int16Array,
    			'Uint16Array': Uint16Array,
    			'Int32Array': Int32Array,
    			'Uint32Array': Uint32Array,
    			'Float32Array': Float32Array,
    			'Float64Array': Float64Array
    		};

    		if ( index !== undefined ) {

    			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
    			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

    		}

    		var attributes = json.data.attributes;

    		for ( var key in attributes ) {

    			var attribute = attributes[ key ];
    			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

    			geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

    		}

    		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    		if ( groups !== undefined ) {

    			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

    				var group = groups[ i ];

    				geometry.addGroup( group.start, group.count, group.materialIndex );

    			}

    		}

    		var boundingSphere = json.data.boundingSphere;

    		if ( boundingSphere !== undefined ) {

    			var center = new Vector3();

    			if ( boundingSphere.center !== undefined ) {

    				center.fromArray( boundingSphere.center );

    			}

    			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

    		}

    		return geometry;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Loader() {

    	this.onLoadStart = function () {};
    	this.onLoadProgress = function () {};
    	this.onLoadComplete = function () {};

    }

    Loader.prototype = {

    	constructor: Loader,

    	crossOrigin: undefined,

    	extractUrlBase: function ( url ) {

    		var parts = url.split( '/' );

    		if ( parts.length === 1 ) return './';

    		parts.pop();

    		return parts.join( '/' ) + '/';

    	},

    	initMaterials: function ( materials, texturePath, crossOrigin ) {

    		var array = [];

    		for ( var i = 0; i < materials.length; ++ i ) {

    			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

    		}

    		return array;

    	},

    	createMaterial: ( function () {

    		var color, textureLoader, materialLoader;

    		return function createMaterial( m, texturePath, crossOrigin ) {

    			if ( color === undefined ) color = new Color();
    			if ( textureLoader === undefined ) textureLoader = new TextureLoader();
    			if ( materialLoader === undefined ) materialLoader = new MaterialLoader();

    			// convert from old material format

    			var textures = {};

    			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

    				var fullPath = texturePath + path;
    				var loader = Loader.Handlers.get( fullPath );

    				var texture;

    				if ( loader !== null ) {

    					texture = loader.load( fullPath );

    				} else {

    					textureLoader.setCrossOrigin( crossOrigin );
    					texture = textureLoader.load( fullPath );

    				}

    				if ( repeat !== undefined ) {

    					texture.repeat.fromArray( repeat );

    					if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
    					if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

    				}

    				if ( offset !== undefined ) {

    					texture.offset.fromArray( offset );

    				}

    				if ( wrap !== undefined ) {

    					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
    					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

    					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
    					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

    				}

    				if ( anisotropy !== undefined ) {

    					texture.anisotropy = anisotropy;

    				}

    				var uuid = exports.Math.generateUUID();

    				textures[ uuid ] = texture;

    				return uuid;

    			}

    			//

    			var json = {
    				uuid: exports.Math.generateUUID(),
    				type: 'MeshLambertMaterial'
    			};

    			for ( var name in m ) {

    				var value = m[ name ];

    				switch ( name ) {
    					case 'DbgColor':
    					case 'DbgIndex':
    					case 'opticalDensity':
    					case 'illumination':
    						break;
    					case 'DbgName':
    						json.name = value;
    						break;
    					case 'blending':
    						json.blending = BlendingMode[ value ];
    						break;
    					case 'colorAmbient':
    					case 'mapAmbient':
    						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
    						break;
    					case 'colorDiffuse':
    						json.color = color.fromArray( value ).getHex();
    						break;
    					case 'colorSpecular':
    						json.specular = color.fromArray( value ).getHex();
    						break;
    					case 'colorEmissive':
    						json.emissive = color.fromArray( value ).getHex();
    						break;
    					case 'specularCoef':
    						json.shininess = value;
    						break;
    					case 'shading':
    						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
    						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
    						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
    						break;
    					case 'mapDiffuse':
    						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
    						break;
    					case 'mapDiffuseRepeat':
    					case 'mapDiffuseOffset':
    					case 'mapDiffuseWrap':
    					case 'mapDiffuseAnisotropy':
    						break;
    					case 'mapEmissive':
    						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
    						break;
    					case 'mapEmissiveRepeat':
    					case 'mapEmissiveOffset':
    					case 'mapEmissiveWrap':
    					case 'mapEmissiveAnisotropy':
    						break;
    					case 'mapLight':
    						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
    						break;
    					case 'mapLightRepeat':
    					case 'mapLightOffset':
    					case 'mapLightWrap':
    					case 'mapLightAnisotropy':
    						break;
    					case 'mapAO':
    						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
    						break;
    					case 'mapAORepeat':
    					case 'mapAOOffset':
    					case 'mapAOWrap':
    					case 'mapAOAnisotropy':
    						break;
    					case 'mapBump':
    						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
    						break;
    					case 'mapBumpScale':
    						json.bumpScale = value;
    						break;
    					case 'mapBumpRepeat':
    					case 'mapBumpOffset':
    					case 'mapBumpWrap':
    					case 'mapBumpAnisotropy':
    						break;
    					case 'mapNormal':
    						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
    						break;
    					case 'mapNormalFactor':
    						json.normalScale = [ value, value ];
    						break;
    					case 'mapNormalRepeat':
    					case 'mapNormalOffset':
    					case 'mapNormalWrap':
    					case 'mapNormalAnisotropy':
    						break;
    					case 'mapSpecular':
    						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
    						break;
    					case 'mapSpecularRepeat':
    					case 'mapSpecularOffset':
    					case 'mapSpecularWrap':
    					case 'mapSpecularAnisotropy':
    						break;
    					case 'mapMetalness':
    						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
    						break;
    					case 'mapMetalnessRepeat':
    					case 'mapMetalnessOffset':
    					case 'mapMetalnessWrap':
    					case 'mapMetalnessAnisotropy':
    						break;
    					case 'mapRoughness':
    						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
    						break;
    					case 'mapRoughnessRepeat':
    					case 'mapRoughnessOffset':
    					case 'mapRoughnessWrap':
    					case 'mapRoughnessAnisotropy':
    						break;
    					case 'mapAlpha':
    						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
    						break;
    					case 'mapAlphaRepeat':
    					case 'mapAlphaOffset':
    					case 'mapAlphaWrap':
    					case 'mapAlphaAnisotropy':
    						break;
    					case 'flipSided':
    						json.side = BackSide;
    						break;
    					case 'doubleSided':
    						json.side = DoubleSide;
    						break;
    					case 'transparency':
    						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
    						json.opacity = value;
    						break;
    					case 'depthTest':
    					case 'depthWrite':
    					case 'colorWrite':
    					case 'opacity':
    					case 'reflectivity':
    					case 'transparent':
    					case 'visible':
    					case 'wireframe':
    						json[ name ] = value;
    						break;
    					case 'vertexColors':
    						if ( value === true ) json.vertexColors = VertexColors;
    						if ( value === 'face' ) json.vertexColors = FaceColors;
    						break;
    					default:
    						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
    						break;
    				}

    			}

    			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
    			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

    			if ( json.opacity < 1 ) json.transparent = true;

    			materialLoader.setTextures( textures );

    			return materialLoader.parse( json );

    		};

    	} )()

    };

    Loader.Handlers = {

    	handlers: [],

    	add: function ( regex, loader ) {

    		this.handlers.push( regex, loader );

    	},

    	get: function ( file ) {

    		var handlers = this.handlers;

    		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

    			var regex = handlers[ i ];
    			var loader  = handlers[ i + 1 ];

    			if ( regex.test( file ) ) {

    				return loader;

    			}

    		}

    		return null;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function JSONLoader( manager ) {

    	if ( typeof manager === 'boolean' ) {

    		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
    		manager = undefined;

    	}

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	this.withCredentials = false;

    }

    Object.assign( JSONLoader.prototype, {

    	load: function( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

    		var loader = new XHRLoader( this.manager );
    		loader.setWithCredentials( this.withCredentials );
    		loader.load( url, function ( text ) {

    			var json = JSON.parse( text );
    			var metadata = json.metadata;

    			if ( metadata !== undefined ) {

    				var type = metadata.type;

    				if ( type !== undefined ) {

    					if ( type.toLowerCase() === 'object' ) {

    						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
    						return;

    					}

    					if ( type.toLowerCase() === 'scene' ) {

    						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
    						return;

    					}

    				}

    			}

    			var object = scope.parse( json, texturePath );
    			onLoad( object.geometry, object.materials );

    		}, onProgress, onError );

    	},

    	setTexturePath: function ( value ) {

    		this.texturePath = value;

    	},

    	parse: function ( json, texturePath ) {

    		var geometry = new Geometry(),
    		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

    		parseModel( scale );

    		parseSkin();
    		parseMorphing( scale );
    		parseAnimations();

    		geometry.computeFaceNormals();
    		geometry.computeBoundingSphere();

    		function parseModel( scale ) {

    			function isBitSet( value, position ) {

    				return value & ( 1 << position );

    			}

    			var i, j, fi,

    			offset, zLength,

    		colorIndex, normalIndex, uvIndex, materialIndex,

    			type,
    			isQuad,
    			hasMaterial,
    			hasFaceVertexUv,
    			hasFaceNormal, hasFaceVertexNormal,
    			hasFaceColor, hasFaceVertexColor,

    		vertex, face, faceA, faceB, hex, normal,

    			uvLayer, uv, u, v,

    			faces = json.faces,
    			vertices = json.vertices,
    			normals = json.normals,
    			colors = json.colors,

    			nUvLayers = 0;

    			if ( json.uvs !== undefined ) {

    				// disregard empty arrays

    				for ( i = 0; i < json.uvs.length; i ++ ) {

    					if ( json.uvs[ i ].length ) nUvLayers ++;

    				}

    				for ( i = 0; i < nUvLayers; i ++ ) {

    					geometry.faceVertexUvs[ i ] = [];

    				}

    			}

    			offset = 0;
    			zLength = vertices.length;

    			while ( offset < zLength ) {

    				vertex = new Vector3();

    				vertex.x = vertices[ offset ++ ] * scale;
    				vertex.y = vertices[ offset ++ ] * scale;
    				vertex.z = vertices[ offset ++ ] * scale;

    				geometry.vertices.push( vertex );

    			}

    			offset = 0;
    			zLength = faces.length;

    			while ( offset < zLength ) {

    				type = faces[ offset ++ ];


    				isQuad              = isBitSet( type, 0 );
    				hasMaterial         = isBitSet( type, 1 );
    				hasFaceVertexUv     = isBitSet( type, 3 );
    				hasFaceNormal       = isBitSet( type, 4 );
    				hasFaceVertexNormal = isBitSet( type, 5 );
    				hasFaceColor	     = isBitSet( type, 6 );
    				hasFaceVertexColor  = isBitSet( type, 7 );

    				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

    				if ( isQuad ) {

    					faceA = new Face3();
    					faceA.a = faces[ offset ];
    					faceA.b = faces[ offset + 1 ];
    					faceA.c = faces[ offset + 3 ];

    					faceB = new Face3();
    					faceB.a = faces[ offset + 1 ];
    					faceB.b = faces[ offset + 2 ];
    					faceB.c = faces[ offset + 3 ];

    					offset += 4;

    					if ( hasMaterial ) {

    						materialIndex = faces[ offset ++ ];
    						faceA.materialIndex = materialIndex;
    						faceB.materialIndex = materialIndex;

    					}

    					// to get face <=> uv index correspondence

    					fi = geometry.faces.length;

    					if ( hasFaceVertexUv ) {

    						for ( i = 0; i < nUvLayers; i ++ ) {

    							uvLayer = json.uvs[ i ];

    							geometry.faceVertexUvs[ i ][ fi ] = [];
    							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

    							for ( j = 0; j < 4; j ++ ) {

    								uvIndex = faces[ offset ++ ];

    								u = uvLayer[ uvIndex * 2 ];
    								v = uvLayer[ uvIndex * 2 + 1 ];

    								uv = new Vector2( u, v );

    								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
    								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

    							}

    						}

    					}

    					if ( hasFaceNormal ) {

    						normalIndex = faces[ offset ++ ] * 3;

    						faceA.normal.set(
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ]
    						);

    						faceB.normal.copy( faceA.normal );

    					}

    					if ( hasFaceVertexNormal ) {

    						for ( i = 0; i < 4; i ++ ) {

    							normalIndex = faces[ offset ++ ] * 3;

    							normal = new Vector3(
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ]
    							);


    							if ( i !== 2 ) faceA.vertexNormals.push( normal );
    							if ( i !== 0 ) faceB.vertexNormals.push( normal );

    						}

    					}


    					if ( hasFaceColor ) {

    						colorIndex = faces[ offset ++ ];
    						hex = colors[ colorIndex ];

    						faceA.color.setHex( hex );
    						faceB.color.setHex( hex );

    					}


    					if ( hasFaceVertexColor ) {

    						for ( i = 0; i < 4; i ++ ) {

    							colorIndex = faces[ offset ++ ];
    							hex = colors[ colorIndex ];

    							if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
    							if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

    						}

    					}

    					geometry.faces.push( faceA );
    					geometry.faces.push( faceB );

    				} else {

    					face = new Face3();
    					face.a = faces[ offset ++ ];
    					face.b = faces[ offset ++ ];
    					face.c = faces[ offset ++ ];

    					if ( hasMaterial ) {

    						materialIndex = faces[ offset ++ ];
    						face.materialIndex = materialIndex;

    					}

    					// to get face <=> uv index correspondence

    					fi = geometry.faces.length;

    					if ( hasFaceVertexUv ) {

    						for ( i = 0; i < nUvLayers; i ++ ) {

    							uvLayer = json.uvs[ i ];

    							geometry.faceVertexUvs[ i ][ fi ] = [];

    							for ( j = 0; j < 3; j ++ ) {

    								uvIndex = faces[ offset ++ ];

    								u = uvLayer[ uvIndex * 2 ];
    								v = uvLayer[ uvIndex * 2 + 1 ];

    								uv = new Vector2( u, v );

    								geometry.faceVertexUvs[ i ][ fi ].push( uv );

    							}

    						}

    					}

    					if ( hasFaceNormal ) {

    						normalIndex = faces[ offset ++ ] * 3;

    						face.normal.set(
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ]
    						);

    					}

    					if ( hasFaceVertexNormal ) {

    						for ( i = 0; i < 3; i ++ ) {

    							normalIndex = faces[ offset ++ ] * 3;

    							normal = new Vector3(
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ]
    							);

    							face.vertexNormals.push( normal );

    						}

    					}


    					if ( hasFaceColor ) {

    						colorIndex = faces[ offset ++ ];
    						face.color.setHex( colors[ colorIndex ] );

    					}


    					if ( hasFaceVertexColor ) {

    						for ( i = 0; i < 3; i ++ ) {

    							colorIndex = faces[ offset ++ ];
    							face.vertexColors.push( new Color( colors[ colorIndex ] ) );

    						}

    					}

    					geometry.faces.push( face );

    				}

    			}

    		}

    		function parseSkin() {

    			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

    			if ( json.skinWeights ) {

    				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

    					var x =                               json.skinWeights[ i ];
    					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
    					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
    					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

    					geometry.skinWeights.push( new Vector4( x, y, z, w ) );

    				}

    			}

    			if ( json.skinIndices ) {

    				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

    					var a =                               json.skinIndices[ i ];
    					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
    					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
    					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

    					geometry.skinIndices.push( new Vector4( a, b, c, d ) );

    				}

    			}

    			geometry.bones = json.bones;

    			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

    				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
    					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

    			}

    		}

    		function parseMorphing( scale ) {

    			if ( json.morphTargets !== undefined ) {

    				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

    					geometry.morphTargets[ i ] = {};
    					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
    					geometry.morphTargets[ i ].vertices = [];

    					var dstVertices = geometry.morphTargets[ i ].vertices;
    					var srcVertices = json.morphTargets[ i ].vertices;

    					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

    						var vertex = new Vector3();
    						vertex.x = srcVertices[ v ] * scale;
    						vertex.y = srcVertices[ v + 1 ] * scale;
    						vertex.z = srcVertices[ v + 2 ] * scale;

    						dstVertices.push( vertex );

    					}

    				}

    			}

    			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

    				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

    				var faces = geometry.faces;
    				var morphColors = json.morphColors[ 0 ].colors;

    				for ( var i = 0, l = faces.length; i < l; i ++ ) {

    					faces[ i ].color.fromArray( morphColors, i * 3 );

    				}

    			}

    		}

    		function parseAnimations() {

    			var outputAnimations = [];

    			// parse old style Bone/Hierarchy animations
    			var animations = [];

    			if ( json.animation !== undefined ) {

    				animations.push( json.animation );

    			}

    			if ( json.animations !== undefined ) {

    				if ( json.animations.length ) {

    					animations = animations.concat( json.animations );

    				} else {

    					animations.push( json.animations );

    				}

    			}

    			for ( var i = 0; i < animations.length; i ++ ) {

    				var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
    				if ( clip ) outputAnimations.push( clip );

    			}

    			// parse implicit morph animations
    			if ( geometry.morphTargets ) {

    				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
    				var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
    				outputAnimations = outputAnimations.concat( morphAnimationClips );

    			}

    			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

    		}

    		if ( json.materials === undefined || json.materials.length === 0 ) {

    			return { geometry: geometry };

    		} else {

    			var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

    			return { geometry: geometry, materials: materials };

    		}

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ObjectLoader ( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;
    	this.texturePath = '';

    }

    Object.assign( ObjectLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		if ( this.texturePath === '' ) {

    			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

    		}

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			scope.parse( JSON.parse( text ), onLoad );

    		}, onProgress, onError );

    	},

    	setTexturePath: function ( value ) {

    		this.texturePath = value;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;

    	},

    	parse: function ( json, onLoad ) {

    		var geometries = this.parseGeometries( json.geometries );

    		var images = this.parseImages( json.images, function () {

    			if ( onLoad !== undefined ) onLoad( object );

    		} );

    		var textures  = this.parseTextures( json.textures, images );
    		var materials = this.parseMaterials( json.materials, textures );

    		var object = this.parseObject( json.object, geometries, materials );

    		if ( json.animations ) {

    			object.animations = this.parseAnimations( json.animations );

    		}

    		if ( json.images === undefined || json.images.length === 0 ) {

    			if ( onLoad !== undefined ) onLoad( object );

    		}

    		return object;

    	},

    	parseGeometries: function ( json ) {

    		var geometries = {};

    		if ( json !== undefined ) {

    			var geometryLoader = new JSONLoader();
    			var bufferGeometryLoader = new BufferGeometryLoader();

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var geometry;
    				var data = json[ i ];

    				switch ( data.type ) {

    					case 'PlaneGeometry':
    					case 'PlaneBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.width,
    							data.height,
    							data.widthSegments,
    							data.heightSegments
    						);

    						break;

    					case 'BoxGeometry':
    					case 'BoxBufferGeometry':
    					case 'CubeGeometry': // backwards compatible

    						geometry = new Geometries[ data.type ](
    							data.width,
    							data.height,
    							data.depth,
    							data.widthSegments,
    							data.heightSegments,
    							data.depthSegments
    						);

    						break;

    					case 'CircleGeometry':
    					case 'CircleBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.segments,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'CylinderGeometry':
    					case 'CylinderBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radiusTop,
    							data.radiusBottom,
    							data.height,
    							data.radialSegments,
    							data.heightSegments,
    							data.openEnded,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'ConeGeometry':
    					case 'ConeBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.height,
    							data.radialSegments,
    							data.heightSegments,
    							data.openEnded,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'SphereGeometry':
    					case 'SphereBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.widthSegments,
    							data.heightSegments,
    							data.phiStart,
    							data.phiLength,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'DodecahedronGeometry':
    					case 'IcosahedronGeometry':
    					case 'OctahedronGeometry':
    					case 'TetrahedronGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.detail
    						);

    						break;

    					case 'RingGeometry':
    					case 'RingBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.innerRadius,
    							data.outerRadius,
    							data.thetaSegments,
    							data.phiSegments,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'TorusGeometry':
    					case 'TorusBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.tube,
    							data.radialSegments,
    							data.tubularSegments,
    							data.arc
    						);

    						break;

    					case 'TorusKnotGeometry':
    					case 'TorusKnotBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.tube,
    							data.tubularSegments,
    							data.radialSegments,
    							data.p,
    							data.q
    						);

    						break;

    					case 'LatheGeometry':
    					case 'LatheBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.points,
    							data.segments,
    							data.phiStart,
    							data.phiLength
    						);

    						break;

    					case 'BufferGeometry':

    						geometry = bufferGeometryLoader.parse( data );

    						break;

    					case 'Geometry':

    						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

    						break;

    					default:

    						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

    						continue;

    				}

    				geometry.uuid = data.uuid;

    				if ( data.name !== undefined ) geometry.name = data.name;

    				geometries[ data.uuid ] = geometry;

    			}

    		}

    		return geometries;

    	},

    	parseMaterials: function ( json, textures ) {

    		var materials = {};

    		if ( json !== undefined ) {

    			var loader = new MaterialLoader();
    			loader.setTextures( textures );

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var material = loader.parse( json[ i ] );
    				materials[ material.uuid ] = material;

    			}

    		}

    		return materials;

    	},

    	parseAnimations: function ( json ) {

    		var animations = [];

    		for ( var i = 0; i < json.length; i ++ ) {

    			var clip = AnimationClip.parse( json[ i ] );

    			animations.push( clip );

    		}

    		return animations;

    	},

    	parseImages: function ( json, onLoad ) {

    		var scope = this;
    		var images = {};

    		function loadImage( url ) {

    			scope.manager.itemStart( url );

    			return loader.load( url, function () {

    				scope.manager.itemEnd( url );

    			}, undefined, function () {

    				scope.manager.itemError( url );

    			} );

    		}

    		if ( json !== undefined && json.length > 0 ) {

    			var manager = new LoadingManager( onLoad );

    			var loader = new ImageLoader( manager );
    			loader.setCrossOrigin( this.crossOrigin );

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var image = json[ i ];
    				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

    				images[ image.uuid ] = loadImage( path );

    			}

    		}

    		return images;

    	},

    	parseTextures: function ( json, images ) {

    		function parseConstant( value, type ) {

    			if ( typeof( value ) === 'number' ) return value;

    			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

    			return type[ value ];

    		}

    		var textures = {};

    		if ( json !== undefined ) {

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var data = json[ i ];

    				if ( data.image === undefined ) {

    					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

    				}

    				if ( images[ data.image ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

    				}

    				var texture = new Texture( images[ data.image ] );
    				texture.needsUpdate = true;

    				texture.uuid = data.uuid;

    				if ( data.name !== undefined ) texture.name = data.name;

    				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );

    				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
    				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
    				if ( data.wrap !== undefined ) {

    					texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
    					texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );

    				}

    				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
    				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
    				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

    				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

    				textures[ data.uuid ] = texture;

    			}

    		}

    		return textures;

    	},

    	parseObject: function () {

    		var matrix = new Matrix4();

    		return function parseObject( data, geometries, materials ) {

    			var object;

    			function getGeometry( name ) {

    				if ( geometries[ name ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

    				}

    				return geometries[ name ];

    			}

    			function getMaterial( name ) {

    				if ( name === undefined ) return undefined;

    				if ( materials[ name ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined material', name );

    				}

    				return materials[ name ];

    			}

    			switch ( data.type ) {

    				case 'Scene':

    					object = new Scene();

    					if ( data.background !== undefined ) {

    						if ( Number.isInteger( data.background ) ) {

    							object.background = new Color( data.background );

    						}

    					}

    					if ( data.fog !== undefined ) {

    						if ( data.fog.type === 'Fog' ) {

    							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

    						} else if ( data.fog.type === 'FogExp2' ) {

    							object.fog = new FogExp2( data.fog.color, data.fog.density );

    						}

    					}

    					break;

    				case 'PerspectiveCamera':

    					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

    					if ( data.focus !== undefined ) object.focus = data.focus;
    					if ( data.zoom !== undefined ) object.zoom = data.zoom;
    					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
    					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
    					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

    					break;

    				case 'OrthographicCamera':

    					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

    					break;

    				case 'AmbientLight':

    					object = new AmbientLight( data.color, data.intensity );

    					break;

    				case 'DirectionalLight':

    					object = new DirectionalLight( data.color, data.intensity );

    					break;

    				case 'PointLight':

    					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

    					break;

    				case 'SpotLight':

    					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

    					break;

    				case 'HemisphereLight':

    					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

    					break;

    				case 'Mesh':

    					var geometry = getGeometry( data.geometry );
    					var material = getMaterial( data.material );

    					if ( geometry.bones && geometry.bones.length > 0 ) {

    						object = new SkinnedMesh( geometry, material );

    					} else {

    						object = new Mesh( geometry, material );

    					}

    					break;

    				case 'LOD':

    					object = new LOD();

    					break;

    				case 'Line':

    					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

    					break;

    				case 'LineSegments':

    					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

    					break;

    				case 'PointCloud':
    				case 'Points':

    					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

    					break;

    				case 'Sprite':

    					object = new Sprite( getMaterial( data.material ) );

    					break;

    				case 'Group':

    					object = new Group();

    					break;

    				default:

    					object = new Object3D();

    			}

    			object.uuid = data.uuid;

    			if ( data.name !== undefined ) object.name = data.name;
    			if ( data.matrix !== undefined ) {

    				matrix.fromArray( data.matrix );
    				matrix.decompose( object.position, object.quaternion, object.scale );

    			} else {

    				if ( data.position !== undefined ) object.position.fromArray( data.position );
    				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
    				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
    				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

    			}

    			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
    			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

    			if ( data.shadow ) {

    				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
    				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
    				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
    				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

    			}

    			if ( data.visible !== undefined ) object.visible = data.visible;
    			if ( data.userData !== undefined ) object.userData = data.userData;

    			if ( data.children !== undefined ) {

    				for ( var child in data.children ) {

    					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

    				}

    			}

    			if ( data.type === 'LOD' ) {

    				var levels = data.levels;

    				for ( var l = 0; l < levels.length; l ++ ) {

    					var level = levels[ l ];
    					var child = object.getObjectByProperty( 'uuid', level.object );

    					if ( child !== undefined ) {

    						object.addLevel( child, level.distance );

    					}

    				}

    			}

    			return object;

    		};

    	}()

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Extensible curve object
     *
     * Some common of Curve methods
     * .getPoint(t), getTangent(t)
     * .getPointAt(u), getTangentAt(u)
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following classes subclasses THREE.Curve:
     *
     * -- 2d classes --
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.CubicBezierCurve
     * THREE.SplineCurve
     * THREE.ArcCurve
     * THREE.EllipseCurve
     *
     * -- 3d classes --
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     * THREE.CubicBezierCurve3
     * THREE.SplineCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath
     *
     **/

    /**************************************************************
     *	Abstract Curve base class
     **************************************************************/

    function Curve() {}

    Curve.prototype = {

    	constructor: Curve,

    	// Virtual base class method to overwrite and implement in subclasses
    	//	- t [0 .. 1]

    	getPoint: function ( t ) {

    		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
    		return null;

    	},

    	// Get point at relative position in curve according to arc length
    	// - u [0 .. 1]

    	getPointAt: function ( u ) {

    		var t = this.getUtoTmapping( u );
    		return this.getPoint( t );

    	},

    	// Get sequence of points using getPoint( t )

    	getPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 5;

    		var points = [];

    		for ( var d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPoint( d / divisions ) );

    		}

    		return points;

    	},

    	// Get sequence of points using getPointAt( u )

    	getSpacedPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 5;

    		var points = [];

    		for ( var d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPointAt( d / divisions ) );

    		}

    		return points;

    	},

    	// Get total curve arc length

    	getLength: function () {

    		var lengths = this.getLengths();
    		return lengths[ lengths.length - 1 ];

    	},

    	// Get list of cumulative segment lengths

    	getLengths: function ( divisions ) {

    		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

    		if ( this.cacheArcLengths
    			&& ( this.cacheArcLengths.length === divisions + 1 )
    			&& ! this.needsUpdate ) {

    			//console.log( "cached", this.cacheArcLengths );
    			return this.cacheArcLengths;

    		}

    		this.needsUpdate = false;

    		var cache = [];
    		var current, last = this.getPoint( 0 );
    		var p, sum = 0;

    		cache.push( 0 );

    		for ( p = 1; p <= divisions; p ++ ) {

    			current = this.getPoint ( p / divisions );
    			sum += current.distanceTo( last );
    			cache.push( sum );
    			last = current;

    		}

    		this.cacheArcLengths = cache;

    		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

    	},

    	updateArcLengths: function() {

    		this.needsUpdate = true;
    		this.getLengths();

    	},

    	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

    	getUtoTmapping: function ( u, distance ) {

    		var arcLengths = this.getLengths();

    		var i = 0, il = arcLengths.length;

    		var targetArcLength; // The targeted u distance value to get

    		if ( distance ) {

    			targetArcLength = distance;

    		} else {

    			targetArcLength = u * arcLengths[ il - 1 ];

    		}

    		//var time = Date.now();

    		// binary search for the index with largest value smaller than target u distance

    		var low = 0, high = il - 1, comparison;

    		while ( low <= high ) {

    			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

    			comparison = arcLengths[ i ] - targetArcLength;

    			if ( comparison < 0 ) {

    				low = i + 1;

    			} else if ( comparison > 0 ) {

    				high = i - 1;

    			} else {

    				high = i;
    				break;

    				// DONE

    			}

    		}

    		i = high;

    		//console.log('b' , i, low, high, Date.now()- time);

    		if ( arcLengths[ i ] === targetArcLength ) {

    			var t = i / ( il - 1 );
    			return t;

    		}

    		// we could get finer grain at lengths, or use simple interpolation between two points

    		var lengthBefore = arcLengths[ i ];
    		var lengthAfter = arcLengths[ i + 1 ];

    		var segmentLength = lengthAfter - lengthBefore;

    		// determine where we are between the 'before' and 'after' points

    		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    		// add that fractional amount to t

    		var t = ( i + segmentFraction ) / ( il - 1 );

    		return t;

    	},

    	// Returns a unit vector tangent at t
    	// In case any sub curve does not implement its tangent derivation,
    	// 2 points a small delta apart will be used to find its gradient
    	// which seems to give a reasonable approximation

    	getTangent: function( t ) {

    		var delta = 0.0001;
    		var t1 = t - delta;
    		var t2 = t + delta;

    		// Capping in case of danger

    		if ( t1 < 0 ) t1 = 0;
    		if ( t2 > 1 ) t2 = 1;

    		var pt1 = this.getPoint( t1 );
    		var pt2 = this.getPoint( t2 );

    		var vec = pt2.clone().sub( pt1 );
    		return vec.normalize();

    	},

    	getTangentAt: function ( u ) {

    		var t = this.getUtoTmapping( u );
    		return this.getTangent( t );

    	}

    };

    // TODO: Transformation for Curves?

    /**************************************************************
     *	3D Curves
     **************************************************************/

    // A Factory method for creating new curve subclasses

    Curve.create = function ( constructor, getPointFunc ) {

    	constructor.prototype = Object.create( Curve.prototype );
    	constructor.prototype.constructor = constructor;
    	constructor.prototype.getPoint = getPointFunc;

    	return constructor;

    };

    /**************************************************************
     *	Line
     **************************************************************/

    function LineCurve( v1, v2 ) {

    	this.v1 = v1;
    	this.v2 = v2;

    }

    LineCurve.prototype = Object.create( Curve.prototype );
    LineCurve.prototype.constructor = LineCurve;

    LineCurve.prototype.isLineCurve = true;

    LineCurve.prototype.getPoint = function ( t ) {

    	if ( t === 1 ) {

    		return this.v2.clone();

    	}

    	var point = this.v2.clone().sub( this.v1 );
    	point.multiplyScalar( t ).add( this.v1 );

    	return point;

    };

    // Line curve is linear, so we can overwrite default getPointAt

    LineCurve.prototype.getPointAt = function ( u ) {

    	return this.getPoint( u );

    };

    LineCurve.prototype.getTangent = function( t ) {

    	var tangent = this.v2.clone().sub( this.v1 );

    	return tangent.normalize();

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     **/

    /**************************************************************
     *	Curved Path - a curve path is simply a array of connected
     *  curves, but retains the api of a curve
     **************************************************************/

    function CurvePath() {

    	this.curves = [];

    	this.autoClose = false; // Automatically closes the path

    }

    CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

    	constructor: CurvePath,

    	add: function ( curve ) {

    		this.curves.push( curve );

    	},

    	closePath: function () {

    		// Add a line curve if start and end of lines are not connected
    		var startPoint = this.curves[ 0 ].getPoint( 0 );
    		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    		if ( ! startPoint.equals( endPoint ) ) {

    			this.curves.push( new LineCurve( endPoint, startPoint ) );

    		}

    	},

    	// To get accurate point with reference to
    	// entire path distance at time t,
    	// following has to be done:

    	// 1. Length of each sub path have to be known
    	// 2. Locate and identify type of curve
    	// 3. Get t for the curve
    	// 4. Return curve.getPointAt(t')

    	getPoint: function ( t ) {

    		var d = t * this.getLength();
    		var curveLengths = this.getCurveLengths();
    		var i = 0;

    		// To think about boundaries points.

    		while ( i < curveLengths.length ) {

    			if ( curveLengths[ i ] >= d ) {

    				var diff = curveLengths[ i ] - d;
    				var curve = this.curves[ i ];

    				var segmentLength = curve.getLength();
    				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

    				return curve.getPointAt( u );

    			}

    			i ++;

    		}

    		return null;

    		// loop where sum != 0, sum > d , sum+1 <d

    	},

    	// We cannot use the default THREE.Curve getPoint() with getLength() because in
    	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    	// getPoint() depends on getLength

    	getLength: function () {

    		var lens = this.getCurveLengths();
    		return lens[ lens.length - 1 ];

    	},

    	// cacheLengths must be recalculated.
    	updateArcLengths: function () {

    		this.needsUpdate = true;
    		this.cacheLengths = null;
    		this.getLengths();

    	},

    	// Compute lengths and cache them
    	// We cannot overwrite getLengths() because UtoT mapping uses it.

    	getCurveLengths: function () {

    		// We use cache values if curves and cache array are same length

    		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

    			return this.cacheLengths;

    		}

    		// Get length of sub-curve
    		// Push sums into cached array

    		var lengths = [], sums = 0;

    		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

    			sums += this.curves[ i ].getLength();
    			lengths.push( sums );

    		}

    		this.cacheLengths = lengths;

    		return lengths;

    	},

    	getSpacedPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 40;

    		var points = [];

    		for ( var i = 0; i <= divisions; i ++ ) {

    			points.push( this.getPoint( i / divisions ) );

    		}

    		if ( this.autoClose ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	},

    	getPoints: function ( divisions ) {

    		divisions = divisions || 12;

    		var points = [], last;

    		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

    			var curve = curves[ i ];
    			var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
    				: (curve && curve.isLineCurve) ? 1
    				: (curve && curve.isSplineCurve) ? divisions * curve.points.length
    				: divisions;

    			var pts = curve.getPoints( resolution );

    			for ( var j = 0; j < pts.length; j++ ) {

    				var point = pts[ j ];

    				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

    				points.push( point );
    				last = point;

    			}

    		}

    		if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	},

    	/**************************************************************
    	 *	Create Geometries Helpers
    	 **************************************************************/

    	/// Generate geometry from path points (for Line or Points objects)

    	createPointsGeometry: function ( divisions ) {

    		var pts = this.getPoints( divisions );
    		return this.createGeometry( pts );

    	},

    	// Generate geometry from equidistant sampling along the path

    	createSpacedPointsGeometry: function ( divisions ) {

    		var pts = this.getSpacedPoints( divisions );
    		return this.createGeometry( pts );

    	},

    	createGeometry: function ( points ) {

    		var geometry = new Geometry();

    		for ( var i = 0, l = points.length; i < l; i ++ ) {

    			var point = points[ i ];
    			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

    		}

    		return geometry;

    	}

    } );

    /**************************************************************
     *	Ellipse curve
     **************************************************************/

    function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    	this.aX = aX;
    	this.aY = aY;

    	this.xRadius = xRadius;
    	this.yRadius = yRadius;

    	this.aStartAngle = aStartAngle;
    	this.aEndAngle = aEndAngle;

    	this.aClockwise = aClockwise;

    	this.aRotation = aRotation || 0;

    }

    EllipseCurve.prototype = Object.create( Curve.prototype );
    EllipseCurve.prototype.constructor = EllipseCurve;

    EllipseCurve.prototype.isEllipseCurve = true;

    EllipseCurve.prototype.getPoint = function( t ) {

    	var twoPi = Math.PI * 2;
    	var deltaAngle = this.aEndAngle - this.aStartAngle;
    	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

    	// ensures that deltaAngle is 0 .. 2 PI
    	while ( deltaAngle < 0 ) deltaAngle += twoPi;
    	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

    	if ( deltaAngle < Number.EPSILON ) {

    		if ( samePoints ) {

    			deltaAngle = 0;

    		} else {

    			deltaAngle = twoPi;

    		}

    	}

    	if ( this.aClockwise === true && ! samePoints ) {

    		if ( deltaAngle === twoPi ) {

    			deltaAngle = - twoPi;

    		} else {

    			deltaAngle = deltaAngle - twoPi;

    		}

    	}

    	var angle = this.aStartAngle + t * deltaAngle;
    	var x = this.aX + this.xRadius * Math.cos( angle );
    	var y = this.aY + this.yRadius * Math.sin( angle );

    	if ( this.aRotation !== 0 ) {

    		var cos = Math.cos( this.aRotation );
    		var sin = Math.sin( this.aRotation );

    		var tx = x - this.aX;
    		var ty = y - this.aY;

    		// Rotate the point about the center of the ellipse.
    		x = tx * cos - ty * sin + this.aX;
    		y = tx * sin + ty * cos + this.aY;

    	}

    	return new Vector2( x, y );

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    exports.CurveUtils = {

    	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

    		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

    	},

    	// Puay Bing, thanks for helping with this derivative!

    	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

    		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
    			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
    			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
    			3 * t * t * p3;

    	},

    	tangentSpline: function ( t, p0, p1, p2, p3 ) {

    		// To check if my formulas are correct

    		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
    		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
    		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
    		var h11 = 3 * t * t - 2 * t;	// t3 − t2

    		return h00 + h10 + h01 + h11;

    	},

    	// Catmull-Rom

    	interpolate: function( p0, p1, p2, p3, t ) {

    		var v0 = ( p2 - p0 ) * 0.5;
    		var v1 = ( p3 - p1 ) * 0.5;
    		var t2 = t * t;
    		var t3 = t * t2;
    		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    	}

    };

    /**************************************************************
     *	Spline curve
     **************************************************************/

    function SplineCurve( points /* array of Vector2 */ ) {

    	this.points = ( points === undefined ) ? [] : points;

    }

    SplineCurve.prototype = Object.create( Curve.prototype );
    SplineCurve.prototype.constructor = SplineCurve;

    SplineCurve.prototype.isSplineCurve = true;

    SplineCurve.prototype.getPoint = function ( t ) {

    	var points = this.points;
    	var point = ( points.length - 1 ) * t;

    	var intPoint = Math.floor( point );
    	var weight = point - intPoint;

    	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    	var point1 = points[ intPoint ];
    	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    	var interpolate = exports.CurveUtils.interpolate;

    	return new Vector2(
    		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
    		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
    	);

    };

    /**************************************************************
     *	Cubic Bezier curve
     **************************************************************/

    function CubicBezierCurve( v0, v1, v2, v3 ) {

    	this.v0 = v0;
    	this.v1 = v1;
    	this.v2 = v2;
    	this.v3 = v3;

    }

    CubicBezierCurve.prototype = Object.create( Curve.prototype );
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;

    CubicBezierCurve.prototype.getPoint = function ( t ) {

    	var b3 = exports.ShapeUtils.b3;

    	return new Vector2(
    		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    	);

    };

    CubicBezierCurve.prototype.getTangent = function( t ) {

    	var tangentCubicBezier = exports.CurveUtils.tangentCubicBezier;

    	return new Vector2(
    		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    	).normalize();

    };

    /**************************************************************
     *	Quadratic Bezier curve
     **************************************************************/


    function QuadraticBezierCurve( v0, v1, v2 ) {

    	this.v0 = v0;
    	this.v1 = v1;
    	this.v2 = v2;

    }

    QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;


    QuadraticBezierCurve.prototype.getPoint = function ( t ) {

    	var b2 = exports.ShapeUtils.b2;

    	return new Vector2(
    		b2( t, this.v0.x, this.v1.x, this.v2.x ),
    		b2( t, this.v0.y, this.v1.y, this.v2.y )
    	);

    };


    QuadraticBezierCurve.prototype.getTangent = function( t ) {

    	var tangentQuadraticBezier = exports.CurveUtils.tangentQuadraticBezier;

    	return new Vector2(
    		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
    		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
    	).normalize();

    };

    var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

    	fromPoints: function ( vectors ) {

    		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

    		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

    			this.lineTo( vectors[ i ].x, vectors[ i ].y );

    		}

    	},

    	moveTo: function ( x, y ) {

    		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

    	},

    	lineTo: function ( x, y ) {

    		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
    		this.curves.push( curve );

    		this.currentPoint.set( x, y );

    	},

    	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

    		var curve = new QuadraticBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCPx, aCPy ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    	},

    	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

    		var curve = new CubicBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCP1x, aCP1y ),
    			new Vector2( aCP2x, aCP2y ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    	},

    	splineThru: function ( pts /*Array of Vector*/ ) {

    		var npts = [ this.currentPoint.clone() ].concat( pts );

    		var curve = new SplineCurve( npts );
    		this.curves.push( curve );

    		this.currentPoint.copy( pts[ pts.length - 1 ] );

    	},

    	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		var x0 = this.currentPoint.x;
    		var y0 = this.currentPoint.y;

    		this.absarc( aX + x0, aY + y0, aRadius,
    			aStartAngle, aEndAngle, aClockwise );

    	},

    	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    	},

    	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		var x0 = this.currentPoint.x;
    		var y0 = this.currentPoint.y;

    		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    	},

    	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    		if ( this.curves.length > 0 ) {

    			// if a previous curve is present, attempt to join
    			var firstPoint = curve.getPoint( 0 );

    			if ( ! firstPoint.equals( this.currentPoint ) ) {

    				this.lineTo( firstPoint.x, firstPoint.y );

    			}

    		}

    		this.curves.push( curve );

    		var lastPoint = curve.getPoint( 1 );
    		this.currentPoint.copy( lastPoint );

    	}

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Defines a 2d shape plane using paths.
     **/

    // STEP 1 Create a path.
    // STEP 2 Turn path into shape.
    // STEP 3 ExtrudeGeometry takes in Shape/Shapes
    // STEP 3a - Extract points from each shape, turn to vertices
    // STEP 3b - Triangulate each shape, add faces.

    function Shape() {

    	Path.apply( this, arguments );

    	this.holes = [];

    }

    Shape.prototype = Object.assign( Object.create( PathPrototype ), {

    	constructor: Shape,

    	getPointsHoles: function ( divisions ) {

    		var holesPts = [];

    		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

    			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

    		}

    		return holesPts;

    	},

    	// Get points of shape and holes (keypoints based on segments parameter)

    	extractAllPoints: function ( divisions ) {

    		return {

    			shape: this.getPoints( divisions ),
    			holes: this.getPointsHoles( divisions )

    		};

    	},

    	extractPoints: function ( divisions ) {

    		return this.extractAllPoints( divisions );

    	}

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Creates free form 2d path using series of points, lines or curves.
     *
     **/

    function Path( points ) {

    	CurvePath.call( this );
    	this.currentPoint = new Vector2();

    	if ( points ) {

    		this.fromPoints( points );

    	}

    }

    Path.prototype = PathPrototype;
    PathPrototype.constructor = Path;


    // minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
    function ShapePath() {
    	this.subPaths = [];
    	this.currentPath = null;
    }

    ShapePath.prototype = {
    	moveTo: function ( x, y ) {
    		this.currentPath = new Path();
    		this.subPaths.push(this.currentPath);
    		this.currentPath.moveTo( x, y );
    	},
    	lineTo: function ( x, y ) {
    		this.currentPath.lineTo( x, y );
    	},
    	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
    		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
    	},
    	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
    		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
    	},
    	splineThru: function ( pts ) {
    		this.currentPath.splineThru( pts );
    	},

    	toShapes: function ( isCCW, noHoles ) {

    		function toShapesNoHoles( inSubpaths ) {

    			var shapes = [];

    			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

    				var tmpPath = inSubpaths[ i ];

    				var tmpShape = new Shape();
    				tmpShape.curves = tmpPath.curves;

    				shapes.push( tmpShape );

    			}

    			return shapes;

    		}

    		function isPointInsidePolygon( inPt, inPolygon ) {

    			var polyLen = inPolygon.length;

    			// inPt on polygon contour => immediate success    or
    			// toggling of inside/outside at every single! intersection point of an edge
    			//  with the horizontal line through inPt, left of inPt
    			//  not counting lowerY endpoints of edges and whole edges on that line
    			var inside = false;
    			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

    				var edgeLowPt  = inPolygon[ p ];
    				var edgeHighPt = inPolygon[ q ];

    				var edgeDx = edgeHighPt.x - edgeLowPt.x;
    				var edgeDy = edgeHighPt.y - edgeLowPt.y;

    				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

    					// not parallel
    					if ( edgeDy < 0 ) {

    						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
    						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

    					}
    					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

    					if ( inPt.y === edgeLowPt.y ) {

    						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
    						// continue;				// no intersection or edgeLowPt => doesn't count !!!

    					} else {

    						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
    						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
    						if ( perpEdge < 0 ) 				continue;
    						inside = ! inside;		// true intersection left of inPt

    					}

    				} else {

    					// parallel or collinear
    					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
    					// edge lies on the same horizontal line as inPt
    					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
    						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
    					// continue;

    				}

    			}

    			return	inside;

    		}

    		var isClockWise = exports.ShapeUtils.isClockWise;

    		var subPaths = this.subPaths;
    		if ( subPaths.length === 0 ) return [];

    		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


    		var solid, tmpPath, tmpShape, shapes = [];

    		if ( subPaths.length === 1 ) {

    			tmpPath = subPaths[ 0 ];
    			tmpShape = new Shape();
    			tmpShape.curves = tmpPath.curves;
    			shapes.push( tmpShape );
    			return shapes;

    		}

    		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
    		holesFirst = isCCW ? ! holesFirst : holesFirst;

    		// console.log("Holes first", holesFirst);

    		var betterShapeHoles = [];
    		var newShapes = [];
    		var newShapeHoles = [];
    		var mainIdx = 0;
    		var tmpPoints;

    		newShapes[ mainIdx ] = undefined;
    		newShapeHoles[ mainIdx ] = [];

    		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

    			tmpPath = subPaths[ i ];
    			tmpPoints = tmpPath.getPoints();
    			solid = isClockWise( tmpPoints );
    			solid = isCCW ? ! solid : solid;

    			if ( solid ) {

    				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

    				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
    				newShapes[ mainIdx ].s.curves = tmpPath.curves;

    				if ( holesFirst )	mainIdx ++;
    				newShapeHoles[ mainIdx ] = [];

    				//console.log('cw', i);

    			} else {

    				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

    				//console.log('ccw', i);

    			}

    		}

    		// only Holes? -> probably all Shapes with wrong orientation
    		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


    		if ( newShapes.length > 1 ) {

    			var ambiguous = false;
    			var toChange = [];

    			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				betterShapeHoles[ sIdx ] = [];

    			}

    			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				var sho = newShapeHoles[ sIdx ];

    				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

    					var ho = sho[ hIdx ];
    					var hole_unassigned = true;

    					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

    						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

    							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
    							if ( hole_unassigned ) {

    								hole_unassigned = false;
    								betterShapeHoles[ s2Idx ].push( ho );

    							} else {

    								ambiguous = true;

    							}

    						}

    					}
    					if ( hole_unassigned ) {

    						betterShapeHoles[ sIdx ].push( ho );

    					}

    				}

    			}
    			// console.log("ambiguous: ", ambiguous);
    			if ( toChange.length > 0 ) {

    				// console.log("to change: ", toChange);
    				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

    			}

    		}

    		var tmpHoles;

    		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

    			tmpShape = newShapes[ i ].s;
    			shapes.push( tmpShape );
    			tmpHoles = newShapeHoles[ i ];

    			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

    				tmpShape.holes.push( tmpHoles[ j ].h );

    			}

    		}

    		//console.log("shape", shapes);

    		return shapes;

    	}
    }

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author mrdoob / http://mrdoob.com/
     */

    function Font( data ) {

    	this.data = data;

    }

    Object.assign( Font.prototype, {

    	isFont: true,

    	generateShapes: function ( text, size, divisions ) {

    		function createPaths( text ) {

    			var chars = String( text ).split( '' );
    			var scale = size / data.resolution;
    			var offset = 0;

    			var paths = [];

    			for ( var i = 0; i < chars.length; i ++ ) {

    				var ret = createPath( chars[ i ], scale, offset );
    				offset += ret.offset;

    				paths.push( ret.path );

    			}

    			return paths;

    		}

    		function createPath( c, scale, offset ) {

    			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

    			if ( ! glyph ) return;

    			var path = new ShapePath();

    			var pts = [], b2 = exports.ShapeUtils.b2, b3 = exports.ShapeUtils.b3;
    			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

    			if ( glyph.o ) {

    				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

    				for ( var i = 0, l = outline.length; i < l; ) {

    					var action = outline[ i ++ ];

    					switch ( action ) {

    						case 'm': // moveTo

    							x = outline[ i ++ ] * scale + offset;
    							y = outline[ i ++ ] * scale;

    							path.moveTo( x, y );

    							break;

    						case 'l': // lineTo

    							x = outline[ i ++ ] * scale + offset;
    							y = outline[ i ++ ] * scale;

    							path.lineTo( x, y );

    							break;

    						case 'q': // quadraticCurveTo

    							cpx  = outline[ i ++ ] * scale + offset;
    							cpy  = outline[ i ++ ] * scale;
    							cpx1 = outline[ i ++ ] * scale + offset;
    							cpy1 = outline[ i ++ ] * scale;

    							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

    							laste = pts[ pts.length - 1 ];

    							if ( laste ) {

    								cpx0 = laste.x;
    								cpy0 = laste.y;

    								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

    									var t = i2 / divisions;
    									b2( t, cpx0, cpx1, cpx );
    									b2( t, cpy0, cpy1, cpy );

    								}

    							}

    							break;

    						case 'b': // bezierCurveTo

    							cpx  = outline[ i ++ ] * scale + offset;
    							cpy  = outline[ i ++ ] * scale;
    							cpx1 = outline[ i ++ ] * scale + offset;
    							cpy1 = outline[ i ++ ] * scale;
    							cpx2 = outline[ i ++ ] * scale + offset;
    							cpy2 = outline[ i ++ ] * scale;

    							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

    							laste = pts[ pts.length - 1 ];

    							if ( laste ) {

    								cpx0 = laste.x;
    								cpy0 = laste.y;

    								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

    									var t = i2 / divisions;
    									b3( t, cpx0, cpx1, cpx2, cpx );
    									b3( t, cpy0, cpy1, cpy2, cpy );

    								}

    							}

    							break;

    					}

    				}

    			}

    			return { offset: glyph.ha * scale, path: path };

    		}

    		//

    		if ( size === undefined ) size = 100;
    		if ( divisions === undefined ) divisions = 4;

    		var data = this.data;

    		var paths = createPaths( text );
    		var shapes = [];

    		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

    			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

    		}

    		return shapes;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function FontLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( FontLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( this.manager );
    		loader.load( url, function ( text ) {

    			var json;

    			try {

    				json = JSON.parse( text );

    			} catch ( e ) {

    				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
    				json = JSON.parse( text.substring( 65, text.length - 2 ) );

    			}

    			var font = scope.parse( json );

    			if ( onLoad ) onLoad( font );

    		}, onProgress, onError );

    	},

    	parse: function ( json ) {

    		return new Font( json );

    	}

    } );

    var context;

    function getAudioContext() {

    	if ( context === undefined ) {

    		context = new ( window.AudioContext || window.webkitAudioContext )();

    	}

    	return context;

    }

    /**
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */

    function AudioLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( AudioLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var loader = new XHRLoader( this.manager );
    		loader.setResponseType( 'arraybuffer' );
    		loader.load( url, function ( buffer ) {

    			var context = getAudioContext();

    			context.decodeAudioData( buffer, function ( audioBuffer ) {

    				onLoad( audioBuffer );

    			} );

    		}, onProgress, onError );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function StereoCamera() {

    	this.type = 'StereoCamera';

    	this.aspect = 1;

    	this.eyeSep = 0.064;

    	this.cameraL = new PerspectiveCamera();
    	this.cameraL.layers.enable( 1 );
    	this.cameraL.matrixAutoUpdate = false;

    	this.cameraR = new PerspectiveCamera();
    	this.cameraR.layers.enable( 2 );
    	this.cameraR.matrixAutoUpdate = false;

    }

    Object.assign( StereoCamera.prototype, {

    	update: ( function () {

    		var instance, focus, fov, aspect, near, far, zoom;

    		var eyeRight = new Matrix4();
    		var eyeLeft = new Matrix4();

    		return function update( camera ) {

    			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
    												aspect !== camera.aspect * this.aspect || near !== camera.near ||
    												far !== camera.far || zoom !== camera.zoom;

    			if ( needsUpdate ) {

    				instance = this;
    				focus = camera.focus;
    				fov = camera.fov;
    				aspect = camera.aspect * this.aspect;
    				near = camera.near;
    				far = camera.far;
    				zoom = camera.zoom;

    				// Off-axis stereoscopic effect based on
    				// http://paulbourke.net/stereographics/stereorender/

    				var projectionMatrix = camera.projectionMatrix.clone();
    				var eyeSep = this.eyeSep / 2;
    				var eyeSepOnProjection = eyeSep * near / focus;
    				var ymax = ( near * Math.tan( exports.Math.DEG2RAD * fov * 0.5 ) ) / zoom;
    				var xmin, xmax;

    				// translate xOffset

    				eyeLeft.elements[ 12 ] = - eyeSep;
    				eyeRight.elements[ 12 ] = eyeSep;

    				// for left eye

    				xmin = - ymax * aspect + eyeSepOnProjection;
    				xmax = ymax * aspect + eyeSepOnProjection;

    				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
    				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

    				this.cameraL.projectionMatrix.copy( projectionMatrix );

    				// for right eye

    				xmin = - ymax * aspect - eyeSepOnProjection;
    				xmax = ymax * aspect - eyeSepOnProjection;

    				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
    				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

    				this.cameraR.projectionMatrix.copy( projectionMatrix );

    			}

    			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
    			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

    		};

    	} )()

    } );

    /**
     * Camera for rendering cube maps
     *	- renders scene into axis-aligned cube
     *
     * @author alteredq / http://alteredqualia.com/
     */

    function CubeCamera( near, far, cubeResolution ) {

    	Object3D.call( this );

    	this.type = 'CubeCamera';

    	var fov = 90, aspect = 1;

    	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPX.up.set( 0, - 1, 0 );
    	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
    	this.add( cameraPX );

    	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNX.up.set( 0, - 1, 0 );
    	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
    	this.add( cameraNX );

    	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPY.up.set( 0, 0, 1 );
    	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
    	this.add( cameraPY );

    	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNY.up.set( 0, 0, - 1 );
    	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
    	this.add( cameraNY );

    	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPZ.up.set( 0, - 1, 0 );
    	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
    	this.add( cameraPZ );

    	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNZ.up.set( 0, - 1, 0 );
    	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
    	this.add( cameraNZ );

    	var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

    	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

    	this.updateCubeMap = function ( renderer, scene ) {

    		if ( this.parent === null ) this.updateMatrixWorld();

    		var renderTarget = this.renderTarget;
    		var generateMipmaps = renderTarget.texture.generateMipmaps;

    		renderTarget.texture.generateMipmaps = false;

    		renderTarget.activeCubeFace = 0;
    		renderer.render( scene, cameraPX, renderTarget );

    		renderTarget.activeCubeFace = 1;
    		renderer.render( scene, cameraNX, renderTarget );

    		renderTarget.activeCubeFace = 2;
    		renderer.render( scene, cameraPY, renderTarget );

    		renderTarget.activeCubeFace = 3;
    		renderer.render( scene, cameraNY, renderTarget );

    		renderTarget.activeCubeFace = 4;
    		renderer.render( scene, cameraPZ, renderTarget );

    		renderTarget.texture.generateMipmaps = generateMipmaps;

    		renderTarget.activeCubeFace = 5;
    		renderer.render( scene, cameraNZ, renderTarget );

    		renderer.setRenderTarget( null );

    	};

    }

    CubeCamera.prototype = Object.create( Object3D.prototype );
    CubeCamera.prototype.constructor = CubeCamera;

    function AudioListener() {

    	Object3D.call( this );

    	this.type = 'AudioListener';

    	this.context = getAudioContext();

    	this.gain = this.context.createGain();
    	this.gain.connect( this.context.destination );

    	this.filter = null;

    }

    AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: AudioListener,

    	getInput: function () {

    		return this.gain;

    	},

    	removeFilter: function ( ) {

    		if ( this.filter !== null ) {

    			this.gain.disconnect( this.filter );
    			this.filter.disconnect( this.context.destination );
    			this.gain.connect( this.context.destination );
    			this.filter = null;

    		}

    	},

    	getFilter: function () {

    		return this.filter;

    	},

    	setFilter: function ( value ) {

    		if ( this.filter !== null ) {

    			this.gain.disconnect( this.filter );
    			this.filter.disconnect( this.context.destination );

    		} else {

    			this.gain.disconnect( this.context.destination );

    		}

    		this.filter = value;
    		this.gain.connect( this.filter );
    		this.filter.connect( this.context.destination );

    	},

    	getMasterVolume: function () {

    		return this.gain.gain.value;

    	},

    	setMasterVolume: function ( value ) {

    		this.gain.gain.value = value;

    	},

    	updateMatrixWorld: ( function () {

    		var position = new Vector3();
    		var quaternion = new Quaternion();
    		var scale = new Vector3();

    		var orientation = new Vector3();

    		return function updateMatrixWorld( force ) {

    			Object3D.prototype.updateMatrixWorld.call( this, force );

    			var listener = this.context.listener;
    			var up = this.up;

    			this.matrixWorld.decompose( position, quaternion, scale );

    			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    			listener.setPosition( position.x, position.y, position.z );
    			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

    		};

    	} )()

    } );

    function Audio( listener ) {

    	Object3D.call( this );

    	this.type = 'Audio';

    	this.context = listener.context;
    	this.source = this.context.createBufferSource();
    	this.source.onended = this.onEnded.bind( this );

    	this.gain = this.context.createGain();
    	this.gain.connect( listener.getInput() );

    	this.autoplay = false;

    	this.startTime = 0;
    	this.playbackRate = 1;
    	this.isPlaying = false;
    	this.hasPlaybackControl = true;
    	this.sourceType = 'empty';

    	this.filters = [];

    }

    Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Audio,

    	getOutput: function () {

    		return this.gain;

    	},

    	setNodeSource: function ( audioNode ) {

    		this.hasPlaybackControl = false;
    		this.sourceType = 'audioNode';
    		this.source = audioNode;
    		this.connect();

    		return this;

    	},

    	setBuffer: function ( audioBuffer ) {

    		this.source.buffer = audioBuffer;
    		this.sourceType = 'buffer';

    		if ( this.autoplay ) this.play();

    		return this;

    	},

    	play: function () {

    		if ( this.isPlaying === true ) {

    			console.warn( 'THREE.Audio: Audio is already playing.' );
    			return;

    		}

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		var source = this.context.createBufferSource();

    		source.buffer = this.source.buffer;
    		source.loop = this.source.loop;
    		source.onended = this.source.onended;
    		source.start( 0, this.startTime );
    		source.playbackRate.value = this.playbackRate;

    		this.isPlaying = true;

    		this.source = source;

    		return this.connect();

    	},

    	pause: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.stop();
    		this.startTime = this.context.currentTime;
    		this.isPlaying = false;

    		return this;

    	},

    	stop: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.stop();
    		this.startTime = 0;
    		this.isPlaying = false;

    		return this;

    	},

    	connect: function () {

    		if ( this.filters.length > 0 ) {

    			this.source.connect( this.filters[ 0 ] );

    			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

    				this.filters[ i - 1 ].connect( this.filters[ i ] );

    			}

    			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

    		} else {

    			this.source.connect( this.getOutput() );

    		}

    		return this;

    	},

    	disconnect: function () {

    		if ( this.filters.length > 0 ) {

    			this.source.disconnect( this.filters[ 0 ] );

    			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

    				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

    			}

    			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

    		} else {

    			this.source.disconnect( this.getOutput() );

    		}

    		return this;

    	},

    	getFilters: function () {

    		return this.filters;

    	},

    	setFilters: function ( value ) {

    		if ( ! value ) value = [];

    		if ( this.isPlaying === true ) {

    			this.disconnect();
    			this.filters = value;
    			this.connect();

    		} else {

    			this.filters = value;

    		}

    		return this;

    	},

    	getFilter: function () {

    		return this.getFilters()[ 0 ];

    	},

    	setFilter: function ( filter ) {

    		return this.setFilters( filter ? [ filter ] : [] );

    	},

    	setPlaybackRate: function ( value ) {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.playbackRate = value;

    		if ( this.isPlaying === true ) {

    			this.source.playbackRate.value = this.playbackRate;

    		}

    		return this;

    	},

    	getPlaybackRate: function () {

    		return this.playbackRate;

    	},

    	onEnded: function () {

    		this.isPlaying = false;

    	},

    	getLoop: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return false;

    		}

    		return this.source.loop;

    	},

    	setLoop: function ( value ) {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.loop = value;

    	},

    	getVolume: function () {

    		return this.gain.gain.value;

    	},


    	setVolume: function ( value ) {

    		this.gain.gain.value = value;

    		return this;

    	}

    } );

    function PositionalAudio( listener ) {

    	Audio.call( this, listener );

    	this.panner = this.context.createPanner();
    	this.panner.connect( this.gain );

    }

    PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

    	constructor: PositionalAudio,

    	getOutput: function () {

    		return this.panner;

    	},

    	getRefDistance: function () {

    		return this.panner.refDistance;

    	},

    	setRefDistance: function ( value ) {

    		this.panner.refDistance = value;

    	},

    	getRolloffFactor: function () {

    		return this.panner.rolloffFactor;

    	},

    	setRolloffFactor: function ( value ) {

    		this.panner.rolloffFactor = value;

    	},

    	getDistanceModel: function () {

    		return this.panner.distanceModel;

    	},

    	setDistanceModel: function ( value ) {

    		this.panner.distanceModel = value;

    	},

    	getMaxDistance: function () {

    		return this.panner.maxDistance;

    	},

    	setMaxDistance: function ( value ) {

    		this.panner.maxDistance = value;

    	},

    	updateMatrixWorld: ( function () {

    		var position = new Vector3();

    		return function updateMatrixWorld( force ) {

    			Object3D.prototype.updateMatrixWorld.call( this, force );

    			position.setFromMatrixPosition( this.matrixWorld );

    			this.panner.setPosition( position.x, position.y, position.z );

    		};

    	} )()


    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AudioAnalyser( audio, fftSize ) {

    	this.analyser = audio.context.createAnalyser();
    	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

    	this.data = new Uint8Array( this.analyser.frequencyBinCount );

    	audio.getOutput().connect( this.analyser );

    }

    Object.assign( AudioAnalyser.prototype, {

    	getFrequencyData: function () {

    		this.analyser.getByteFrequencyData( this.data );

    		return this.data;

    	},

    	getAverageFrequency: function () {

    		var value = 0, data = this.getFrequencyData();

    		for ( var i = 0; i < data.length; i ++ ) {

    			value += data[ i ];

    		}

    		return value / data.length;

    	}

    } );

    /**
     *
     * Buffered scene graph property that allows weighted accumulation.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function PropertyMixer( binding, typeName, valueSize ) {

    	this.binding = binding;
    	this.valueSize = valueSize;

    	var bufferType = Float64Array,
    		mixFunction;

    	switch ( typeName ) {

    		case 'quaternion':			mixFunction = this._slerp;		break;

    		case 'string':
    		case 'bool':

    			bufferType = Array,		mixFunction = this._select;		break;

    		default:					mixFunction = this._lerp;

    	}

    	this.buffer = new bufferType( valueSize * 4 );
    	// layout: [ incoming | accu0 | accu1 | orig ]
    	//
    	// interpolators can use .buffer as their .result
    	// the data then goes to 'incoming'
    	//
    	// 'accu0' and 'accu1' are used frame-interleaved for
    	// the cumulative result and are compared to detect
    	// changes
    	//
    	// 'orig' stores the original state of the property

    	this._mixBufferRegion = mixFunction;

    	this.cumulativeWeight = 0;

    	this.useCount = 0;
    	this.referenceCount = 0;

    }

    PropertyMixer.prototype = {

    	constructor: PropertyMixer,

    	// accumulate data in the 'incoming' region into 'accu<i>'
    	accumulate: function( accuIndex, weight ) {

    		// note: happily accumulating nothing when weight = 0, the caller knows
    		// the weight and shouldn't have made the call in the first place

    		var buffer = this.buffer,
    			stride = this.valueSize,
    			offset = accuIndex * stride + stride,

    			currentWeight = this.cumulativeWeight;

    		if ( currentWeight === 0 ) {

    			// accuN := incoming * weight

    			for ( var i = 0; i !== stride; ++ i ) {

    				buffer[ offset + i ] = buffer[ i ];

    			}

    			currentWeight = weight;

    		} else {

    			// accuN := accuN + incoming * weight

    			currentWeight += weight;
    			var mix = weight / currentWeight;
    			this._mixBufferRegion( buffer, offset, 0, mix, stride );

    		}

    		this.cumulativeWeight = currentWeight;

    	},

    	// apply the state of 'accu<i>' to the binding when accus differ
    	apply: function( accuIndex ) {

    		var stride = this.valueSize,
    			buffer = this.buffer,
    			offset = accuIndex * stride + stride,

    			weight = this.cumulativeWeight,

    			binding = this.binding;

    		this.cumulativeWeight = 0;

    		if ( weight < 1 ) {

    			// accuN := accuN + original * ( 1 - cumulativeWeight )

    			var originalValueOffset = stride * 3;

    			this._mixBufferRegion(
    					buffer, offset, originalValueOffset, 1 - weight, stride );

    		}

    		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

    			if ( buffer[ i ] !== buffer[ i + stride ] ) {

    				// value has changed -> update scene graph

    				binding.setValue( buffer, offset );
    				break;

    			}

    		}

    	},

    	// remember the state of the bound property and copy it to both accus
    	saveOriginalState: function() {

    		var binding = this.binding;

    		var buffer = this.buffer,
    			stride = this.valueSize,

    			originalValueOffset = stride * 3;

    		binding.getValue( buffer, originalValueOffset );

    		// accu[0..1] := orig -- initially detect changes against the original
    		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

    			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

    		}

    		this.cumulativeWeight = 0;

    	},

    	// apply the state previously taken via 'saveOriginalState' to the binding
    	restoreOriginalState: function() {

    		var originalValueOffset = this.valueSize * 3;
    		this.binding.setValue( this.buffer, originalValueOffset );

    	},


    	// mix functions

    	_select: function( buffer, dstOffset, srcOffset, t, stride ) {

    		if ( t >= 0.5 ) {

    			for ( var i = 0; i !== stride; ++ i ) {

    				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

    			}

    		}

    	},

    	_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    		Quaternion.slerpFlat( buffer, dstOffset,
    				buffer, dstOffset, buffer, srcOffset, t );

    	},

    	_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    		var s = 1 - t;

    		for ( var i = 0; i !== stride; ++ i ) {

    			var j = dstOffset + i;

    			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

    		}

    	}

    };

    /**
     *
     * A reference to a real property in the scene graph.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function PropertyBinding( rootNode, path, parsedPath ) {

    	this.path = path;
    	this.parsedPath = parsedPath ||
    			PropertyBinding.parseTrackName( path );

    	this.node = PropertyBinding.findNode(
    			rootNode, this.parsedPath.nodeName ) || rootNode;

    	this.rootNode = rootNode;

    }

    PropertyBinding.prototype = {

    	constructor: PropertyBinding,

    	getValue: function getValue_unbound( targetArray, offset ) {

    		this.bind();
    		this.getValue( targetArray, offset );

    		// Note: This class uses a State pattern on a per-method basis:
    		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
    		// prototype version of these methods with one that represents
    		// the bound state. When the property is not found, the methods
    		// become no-ops.

    	},

    	setValue: function getValue_unbound( sourceArray, offset ) {

    		this.bind();
    		this.setValue( sourceArray, offset );

    	},

    	// create getter / setter pair for a property in the scene graph
    	bind: function() {

    		var targetObject = this.node,
    			parsedPath = this.parsedPath,

    			objectName = parsedPath.objectName,
    			propertyName = parsedPath.propertyName,
    			propertyIndex = parsedPath.propertyIndex;

    		if ( ! targetObject ) {

    			targetObject = PropertyBinding.findNode(
    					this.rootNode, parsedPath.nodeName ) || this.rootNode;

    			this.node = targetObject;

    		}

    		// set fail state so we can just 'return' on error
    		this.getValue = this._getValue_unavailable;
    		this.setValue = this._setValue_unavailable;

     		// ensure there is a value node
    		if ( ! targetObject ) {

    			console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
    			return;

    		}

    		if ( objectName ) {

    			var objectIndex = parsedPath.objectIndex;

    			// special cases were we need to reach deeper into the hierarchy to get the face materials....
    			switch ( objectName ) {

    				case 'materials':

    					if ( ! targetObject.material ) {

    						console.error( '  can not bind to material as node does not have a material', this );
    						return;

    					}

    					if ( ! targetObject.material.materials ) {

    						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
    						return;

    					}

    					targetObject = targetObject.material.materials;

    					break;

    				case 'bones':

    					if ( ! targetObject.skeleton ) {

    						console.error( '  can not bind to bones as node does not have a skeleton', this );
    						return;

    					}

    					// potential future optimization: skip this if propertyIndex is already an integer
    					// and convert the integer string to a true integer.

    					targetObject = targetObject.skeleton.bones;

    					// support resolving morphTarget names into indices.
    					for ( var i = 0; i < targetObject.length; i ++ ) {

    						if ( targetObject[ i ].name === objectIndex ) {

    							objectIndex = i;
    							break;

    						}

    					}

    					break;

    				default:

    					if ( targetObject[ objectName ] === undefined ) {

    						console.error( '  can not bind to objectName of node, undefined', this );
    						return;

    					}

    					targetObject = targetObject[ objectName ];

    			}


    			if ( objectIndex !== undefined ) {

    				if ( targetObject[ objectIndex ] === undefined ) {

    					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
    					return;

    				}

    				targetObject = targetObject[ objectIndex ];

    			}

    		}

    		// resolve property
    		var nodeProperty = targetObject[ propertyName ];

    		if ( nodeProperty === undefined ) {

    			var nodeName = parsedPath.nodeName;

    			console.error( "  trying to update property for track: " + nodeName +
    					'.' + propertyName + " but it wasn't found.", targetObject );
    			return;

    		}

    		// determine versioning scheme
    		var versioning = this.Versioning.None;

    		if ( targetObject.needsUpdate !== undefined ) { // material

    			versioning = this.Versioning.NeedsUpdate;
    			this.targetObject = targetObject;

    		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

    			versioning = this.Versioning.MatrixWorldNeedsUpdate;
    			this.targetObject = targetObject;

    		}

    		// determine how the property gets bound
    		var bindingType = this.BindingType.Direct;

    		if ( propertyIndex !== undefined ) {
    			// access a sub element of the property array (only primitives are supported right now)

    			if ( propertyName === "morphTargetInfluences" ) {
    				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

    				// support resolving morphTarget names into indices.
    				if ( ! targetObject.geometry ) {

    					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
    					return;

    				}

    				if ( ! targetObject.geometry.morphTargets ) {

    					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
    					return;

    				}

    				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

    					if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

    						propertyIndex = i;
    						break;

    					}

    				}

    			}

    			bindingType = this.BindingType.ArrayElement;

    			this.resolvedProperty = nodeProperty;
    			this.propertyIndex = propertyIndex;

    		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
    			// must use copy for Object3D.Euler/Quaternion

    			bindingType = this.BindingType.HasFromToArray;

    			this.resolvedProperty = nodeProperty;

    		} else if ( nodeProperty.length !== undefined ) {

    			bindingType = this.BindingType.EntireArray;

    			this.resolvedProperty = nodeProperty;

    		} else {

    			this.propertyName = propertyName;

    		}

    		// select getter / setter
    		this.getValue = this.GetterByBindingType[ bindingType ];
    		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

    	},

    	unbind: function() {

    		this.node = null;

    		// back to the prototype version of getValue / setValue
    		// note: avoiding to mutate the shape of 'this' via 'delete'
    		this.getValue = this._getValue_unbound;
    		this.setValue = this._setValue_unbound;

    	}

    };

    Object.assign( PropertyBinding.prototype, { // prototype, continued

    	// these are used to "bind" a nonexistent property
    	_getValue_unavailable: function() {},
    	_setValue_unavailable: function() {},

    	// initial state of these methods that calls 'bind'
    	_getValue_unbound: PropertyBinding.prototype.getValue,
    	_setValue_unbound: PropertyBinding.prototype.setValue,

    	BindingType: {
    		Direct: 0,
    		EntireArray: 1,
    		ArrayElement: 2,
    		HasFromToArray: 3
    	},

    	Versioning: {
    		None: 0,
    		NeedsUpdate: 1,
    		MatrixWorldNeedsUpdate: 2
    	},

    	GetterByBindingType: [

    		function getValue_direct( buffer, offset ) {

    			buffer[ offset ] = this.node[ this.propertyName ];

    		},

    		function getValue_array( buffer, offset ) {

    			var source = this.resolvedProperty;

    			for ( var i = 0, n = source.length; i !== n; ++ i ) {

    				buffer[ offset ++ ] = source[ i ];

    			}

    		},

    		function getValue_arrayElement( buffer, offset ) {

    			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

    		},

    		function getValue_toArray( buffer, offset ) {

    			this.resolvedProperty.toArray( buffer, offset );

    		}

    	],

    	SetterByBindingTypeAndVersioning: [

    		[
    			// Direct

    			function setValue_direct( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];

    			},

    			function setValue_direct_setNeedsUpdate( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// EntireArray

    			function setValue_array( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    			},

    			function setValue_array_setNeedsUpdate( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// ArrayElement

    			function setValue_arrayElement( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

    			},

    			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// HasToFromArray

    			function setValue_fromArray( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );

    			},

    			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		]

    	]

    } );

    PropertyBinding.Composite =
    		function( targetGroup, path, optionalParsedPath ) {

    	var parsedPath = optionalParsedPath ||
    			PropertyBinding.parseTrackName( path );

    	this._targetGroup = targetGroup;
    	this._bindings = targetGroup.subscribe_( path, parsedPath );

    };

    PropertyBinding.Composite.prototype = {

    	constructor: PropertyBinding.Composite,

    	getValue: function( array, offset ) {

    		this.bind(); // bind all binding

    		var firstValidIndex = this._targetGroup.nCachedObjects_,
    			binding = this._bindings[ firstValidIndex ];

    		// and only call .getValue on the first
    		if ( binding !== undefined ) binding.getValue( array, offset );

    	},

    	setValue: function( array, offset ) {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].setValue( array, offset );

    		}

    	},

    	bind: function() {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].bind();

    		}

    	},

    	unbind: function() {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].unbind();

    		}

    	}

    };

    PropertyBinding.create = function( root, path, parsedPath ) {

    	if ( ! ( (root && root.isAnimationObjectGroup) ) ) {

    		return new PropertyBinding( root, path, parsedPath );

    	} else {

    		return new PropertyBinding.Composite( root, path, parsedPath );

    	}

    };

    PropertyBinding.parseTrackName = function( trackName ) {

    	// matches strings in the form of:
    	//    nodeName.property
    	//    nodeName.property[accessor]
    	//    nodeName.material.property[accessor]
    	//    uuid.property[accessor]
    	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
    	//    parentName/nodeName.property
    	//    parentName/parentName/nodeName.property[index]
    	//    .bone[Armature.DEF_cog].position
    	//    scene:helium_balloon_model:helium_balloon_model.position
    	// created and tested via https://regex101.com/#javascript

    	var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
    	var matches = re.exec( trackName );

    	if ( ! matches ) {

    		throw new Error( "cannot parse trackName at all: " + trackName );

    	}

    	var results = {
    		// directoryName: matches[ 1 ], // (tschw) currently unused
    		nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
    		objectName: matches[ 3 ],
    		objectIndex: matches[ 4 ],
    		propertyName: matches[ 5 ],
    		propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
    	};

    	if ( results.propertyName === null || results.propertyName.length === 0 ) {

    		throw new Error( "can not parse propertyName from trackName: " + trackName );

    	}

    	return results;

    };

    PropertyBinding.findNode = function( root, nodeName ) {

    	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

    		return root;

    	}

    	// search into skeleton bones.
    	if ( root.skeleton ) {

    		var searchSkeleton = function( skeleton ) {

    			for( var i = 0; i < skeleton.bones.length; i ++ ) {

    				var bone = skeleton.bones[ i ];

    				if ( bone.name === nodeName ) {

    					return bone;

    				}
    			}

    			return null;

    		};

    		var bone = searchSkeleton( root.skeleton );

    		if ( bone ) {

    			return bone;

    		}
    	}

    	// search into node subtree.
    	if ( root.children ) {

    		var searchNodeSubtree = function( children ) {

    			for( var i = 0; i < children.length; i ++ ) {

    				var childNode = children[ i ];

    				if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

    					return childNode;

    				}

    				var result = searchNodeSubtree( childNode.children );

    				if ( result ) return result;

    			}

    			return null;

    		};

    		var subTreeNode = searchNodeSubtree( root.children );

    		if ( subTreeNode ) {

    			return subTreeNode;

    		}

    	}

    	return null;

    };

    /**
     *
     * A group of objects that receives a shared animation state.
     *
     * Usage:
     *
     * 	-	Add objects you would otherwise pass as 'root' to the
     * 		constructor or the .clipAction method of AnimationMixer.
     *
     * 	-	Instead pass this object as 'root'.
     *
     * 	-	You can also add and remove objects later when the mixer
     * 		is running.
     *
     * Note:
     *
     *  	Objects of this class appear as one object to the mixer,
     *  	so cache control of the individual objects must be done
     *  	on the group.
     *
     * Limitation:
     *
     * 	- 	The animated properties must be compatible among the
     * 		all objects in the group.
     *
     *  -	A single property can either be controlled through a
     *  	target group or directly, but not both.
     *
     * @author tschw
     */

    function AnimationObjectGroup( var_args ) {

    	this.uuid = exports.Math.generateUUID();

    	// cached objects followed by the active ones
    	this._objects = Array.prototype.slice.call( arguments );

    	this.nCachedObjects_ = 0;			// threshold
    	// note: read by PropertyBinding.Composite

    	var indices = {};
    	this._indicesByUUID = indices;		// for bookkeeping

    	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    		indices[ arguments[ i ].uuid ] = i;

    	}

    	this._paths = [];					// inside: string
    	this._parsedPaths = [];				// inside: { we don't care, here }
    	this._bindings = []; 				// inside: Array< PropertyBinding >
    	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

    	var scope = this;

    	this.stats = {

    		objects: {
    			get total() { return scope._objects.length; },
    			get inUse() { return this.total - scope.nCachedObjects_;  }
    		},

    		get bindingsPerObject() { return scope._bindings.length; }

    	};

    }

    AnimationObjectGroup.prototype = {

    	constructor: AnimationObjectGroup,

    	isAnimationObjectGroup: true,

    	add: function( var_args ) {

    		var objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			paths = this._paths,
    			parsedPaths = this._parsedPaths,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index === undefined ) {

    				// unknown object -> add it to the ACTIVE region

    				index = nObjects ++;
    				indicesByUUID[ uuid ] = index;
    				objects.push( object );

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					bindings[ j ].push(
    							new PropertyBinding(
    								object, paths[ j ], parsedPaths[ j ] ) );

    				}

    			} else if ( index < nCachedObjects ) {

    				var knownObject = objects[ index ];

    				// move existing object to the ACTIVE region

    				var firstActiveIndex = -- nCachedObjects,
    					lastCachedObject = objects[ firstActiveIndex ];

    				indicesByUUID[ lastCachedObject.uuid ] = index;
    				objects[ index ] = lastCachedObject;

    				indicesByUUID[ uuid ] = firstActiveIndex;
    				objects[ firstActiveIndex ] = object;

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					var bindingsForPath = bindings[ j ],
    						lastCached = bindingsForPath[ firstActiveIndex ],
    						binding = bindingsForPath[ index ];

    					bindingsForPath[ index ] = lastCached;

    					if ( binding === undefined ) {

    						// since we do not bother to create new bindings
    						// for objects that are cached, the binding may
    						// or may not exist

    						binding = new PropertyBinding(
    								object, paths[ j ], parsedPaths[ j ] );

    					}

    					bindingsForPath[ firstActiveIndex ] = binding;

    				}

    			} else if ( objects[ index ] !== knownObject) {

    				console.error( "Different objects with the same UUID " +
    						"detected. Clean the caches or recreate your " +
    						"infrastructure when reloading scenes..." );

    			} // else the object is already where we want it to be

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	remove: function( var_args ) {

    		var objects = this._objects,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index !== undefined && index >= nCachedObjects ) {

    				// move existing object into the CACHED region

    				var lastCachedIndex = nCachedObjects ++,
    					firstActiveObject = objects[ lastCachedIndex ];

    				indicesByUUID[ firstActiveObject.uuid ] = index;
    				objects[ index ] = firstActiveObject;

    				indicesByUUID[ uuid ] = lastCachedIndex;
    				objects[ lastCachedIndex ] = object;

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					var bindingsForPath = bindings[ j ],
    						firstActive = bindingsForPath[ lastCachedIndex ],
    						binding = bindingsForPath[ index ];

    					bindingsForPath[ index ] = firstActive;
    					bindingsForPath[ lastCachedIndex ] = binding;

    				}

    			}

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	// remove & forget
    	uncache: function( var_args ) {

    		var objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index !== undefined ) {

    				delete indicesByUUID[ uuid ];

    				if ( index < nCachedObjects ) {

    					// object is cached, shrink the CACHED region

    					var firstActiveIndex = -- nCachedObjects,
    						lastCachedObject = objects[ firstActiveIndex ],
    						lastIndex = -- nObjects,
    						lastObject = objects[ lastIndex ];

    					// last cached object takes this object's place
    					indicesByUUID[ lastCachedObject.uuid ] = index;
    					objects[ index ] = lastCachedObject;

    					// last object goes to the activated slot and pop
    					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
    					objects[ firstActiveIndex ] = lastObject;
    					objects.pop();

    					// accounting is done, now do the same for all bindings

    					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    						var bindingsForPath = bindings[ j ],
    							lastCached = bindingsForPath[ firstActiveIndex ],
    							last = bindingsForPath[ lastIndex ];

    						bindingsForPath[ index ] = lastCached;
    						bindingsForPath[ firstActiveIndex ] = last;
    						bindingsForPath.pop();

    					}

    				} else {

    					// object is active, just swap with the last and pop

    					var lastIndex = -- nObjects,
    						lastObject = objects[ lastIndex ];

    					indicesByUUID[ lastObject.uuid ] = index;
    					objects[ index ] = lastObject;
    					objects.pop();

    					// accounting is done, now do the same for all bindings

    					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    						var bindingsForPath = bindings[ j ];

    						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
    						bindingsForPath.pop();

    					}

    				} // cached or active

    			} // if object is known

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	// Internal interface used by befriended PropertyBinding.Composite:

    	subscribe_: function( path, parsedPath ) {
    		// returns an array of bindings for the given path that is changed
    		// according to the contained objects in the group

    		var indicesByPath = this._bindingsIndicesByPath,
    			index = indicesByPath[ path ],
    			bindings = this._bindings;

    		if ( index !== undefined ) return bindings[ index ];

    		var paths = this._paths,
    			parsedPaths = this._parsedPaths,
    			objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			bindingsForPath = new Array( nObjects );

    		index = bindings.length;

    		indicesByPath[ path ] = index;

    		paths.push( path );
    		parsedPaths.push( parsedPath );
    		bindings.push( bindingsForPath );

    		for ( var i = nCachedObjects,
    				n = objects.length; i !== n; ++ i ) {

    			var object = objects[ i ];

    			bindingsForPath[ i ] =
    					new PropertyBinding( object, path, parsedPath );

    		}

    		return bindingsForPath;

    	},

    	unsubscribe_: function( path ) {
    		// tells the group to forget about a property path and no longer
    		// update the array previously obtained with 'subscribe_'

    		var indicesByPath = this._bindingsIndicesByPath,
    			index = indicesByPath[ path ];

    		if ( index !== undefined ) {

    			var paths = this._paths,
    				parsedPaths = this._parsedPaths,
    				bindings = this._bindings,
    				lastBindingsIndex = bindings.length - 1,
    				lastBindings = bindings[ lastBindingsIndex ],
    				lastBindingsPath = path[ lastBindingsIndex ];

    			indicesByPath[ lastBindingsPath ] = index;

    			bindings[ index ] = lastBindings;
    			bindings.pop();

    			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
    			parsedPaths.pop();

    			paths[ index ] = paths[ lastBindingsIndex ];
    			paths.pop();

    		}

    	}

    };

    /**
     *
     * Action provided by AnimationMixer for scheduling clip playback on specific
     * objects.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     *
     */

    function AnimationAction( mixer, clip, localRoot ) {

    	this._mixer = mixer;
    	this._clip = clip;
    	this._localRoot = localRoot || null;

    	var tracks = clip.tracks,
    		nTracks = tracks.length,
    		interpolants = new Array( nTracks );

    	var interpolantSettings = {
    			endingStart: 	ZeroCurvatureEnding,
    			endingEnd:		ZeroCurvatureEnding
    	};

    	for ( var i = 0; i !== nTracks; ++ i ) {

    		var interpolant = tracks[ i ].createInterpolant( null );
    		interpolants[ i ] = interpolant;
    		interpolant.settings = interpolantSettings;

    	}

    	this._interpolantSettings = interpolantSettings;

    	this._interpolants = interpolants;	// bound by the mixer

    	// inside: PropertyMixer (managed by the mixer)
    	this._propertyBindings = new Array( nTracks );

    	this._cacheIndex = null;			// for the memory manager
    	this._byClipCacheIndex = null;		// for the memory manager

    	this._timeScaleInterpolant = null;
    	this._weightInterpolant = null;

    	this.loop = LoopRepeat;
    	this._loopCount = -1;

    	// global mixer time when the action is to be started
    	// it's set back to 'null' upon start of the action
    	this._startTime = null;

    	// scaled local time of the action
    	// gets clamped or wrapped to 0..clip.duration according to loop
    	this.time = 0;

    	this.timeScale = 1;
    	this._effectiveTimeScale = 1;

    	this.weight = 1;
    	this._effectiveWeight = 1;

    	this.repetitions = Infinity; 		// no. of repetitions when looping

    	this.paused = false;				// false -> zero effective time scale
    	this.enabled = true;				// true -> zero effective weight

    	this.clampWhenFinished 	= false;	// keep feeding the last frame?

    	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
    	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

    };

    AnimationAction.prototype = {

    	constructor: AnimationAction,

    	// State & Scheduling

    	play: function() {

    		this._mixer._activateAction( this );

    		return this;

    	},

    	stop: function() {

    		this._mixer._deactivateAction( this );

    		return this.reset();

    	},

    	reset: function() {

    		this.paused = false;
    		this.enabled = true;

    		this.time = 0;			// restart clip
    		this._loopCount = -1;	// forget previous loops
    		this._startTime = null;	// forget scheduling

    		return this.stopFading().stopWarping();

    	},

    	isRunning: function() {

    		return this.enabled && ! this.paused && this.timeScale !== 0 &&
    				this._startTime === null && this._mixer._isActiveAction( this );

    	},

    	// return true when play has been called
    	isScheduled: function() {

    		return this._mixer._isActiveAction( this );

    	},

    	startAt: function( time ) {

    		this._startTime = time;

    		return this;

    	},

    	setLoop: function( mode, repetitions ) {

    		this.loop = mode;
    		this.repetitions = repetitions;

    		return this;

    	},

    	// Weight

    	// set the weight stopping any scheduled fading
    	// although .enabled = false yields an effective weight of zero, this
    	// method does *not* change .enabled, because it would be confusing
    	setEffectiveWeight: function( weight ) {

    		this.weight = weight;

    		// note: same logic as when updated at runtime
    		this._effectiveWeight = this.enabled ? weight : 0;

    		return this.stopFading();

    	},

    	// return the weight considering fading and .enabled
    	getEffectiveWeight: function() {

    		return this._effectiveWeight;

    	},

    	fadeIn: function( duration ) {

    		return this._scheduleFading( duration, 0, 1 );

    	},

    	fadeOut: function( duration ) {

    		return this._scheduleFading( duration, 1, 0 );

    	},

    	crossFadeFrom: function( fadeOutAction, duration, warp ) {

    		fadeOutAction.fadeOut( duration );
    		this.fadeIn( duration );

    		if( warp ) {

    			var fadeInDuration = this._clip.duration,
    				fadeOutDuration = fadeOutAction._clip.duration,

    				startEndRatio = fadeOutDuration / fadeInDuration,
    				endStartRatio = fadeInDuration / fadeOutDuration;

    			fadeOutAction.warp( 1.0, startEndRatio, duration );
    			this.warp( endStartRatio, 1.0, duration );

    		}

    		return this;

    	},

    	crossFadeTo: function( fadeInAction, duration, warp ) {

    		return fadeInAction.crossFadeFrom( this, duration, warp );

    	},

    	stopFading: function() {

    		var weightInterpolant = this._weightInterpolant;

    		if ( weightInterpolant !== null ) {

    			this._weightInterpolant = null;
    			this._mixer._takeBackControlInterpolant( weightInterpolant );

    		}

    		return this;

    	},

    	// Time Scale Control

    	// set the weight stopping any scheduled warping
    	// although .paused = true yields an effective time scale of zero, this
    	// method does *not* change .paused, because it would be confusing
    	setEffectiveTimeScale: function( timeScale ) {

    		this.timeScale = timeScale;
    		this._effectiveTimeScale = this.paused ? 0 :timeScale;

    		return this.stopWarping();

    	},

    	// return the time scale considering warping and .paused
    	getEffectiveTimeScale: function() {

    		return this._effectiveTimeScale;

    	},

    	setDuration: function( duration ) {

    		this.timeScale = this._clip.duration / duration;

    		return this.stopWarping();

    	},

    	syncWith: function( action ) {

    		this.time = action.time;
    		this.timeScale = action.timeScale;

    		return this.stopWarping();

    	},

    	halt: function( duration ) {

    		return this.warp( this._effectiveTimeScale, 0, duration );

    	},

    	warp: function( startTimeScale, endTimeScale, duration ) {

    		var mixer = this._mixer, now = mixer.time,
    			interpolant = this._timeScaleInterpolant,

    			timeScale = this.timeScale;

    		if ( interpolant === null ) {

    			interpolant = mixer._lendControlInterpolant(),
    			this._timeScaleInterpolant = interpolant;

    		}

    		var times = interpolant.parameterPositions,
    			values = interpolant.sampleValues;

    		times[ 0 ] = now;
    		times[ 1 ] = now + duration;

    		values[ 0 ] = startTimeScale / timeScale;
    		values[ 1 ] = endTimeScale / timeScale;

    		return this;

    	},

    	stopWarping: function() {

    		var timeScaleInterpolant = this._timeScaleInterpolant;

    		if ( timeScaleInterpolant !== null ) {

    			this._timeScaleInterpolant = null;
    			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

    		}

    		return this;

    	},

    	// Object Accessors

    	getMixer: function() {

    		return this._mixer;

    	},

    	getClip: function() {

    		return this._clip;

    	},

    	getRoot: function() {

    		return this._localRoot || this._mixer._root;

    	},

    	// Interna

    	_update: function( time, deltaTime, timeDirection, accuIndex ) {
    		// called by the mixer

    		var startTime = this._startTime;

    		if ( startTime !== null ) {

    			// check for scheduled start of action

    			var timeRunning = ( time - startTime ) * timeDirection;
    			if ( timeRunning < 0 || timeDirection === 0 ) {

    				return; // yet to come / don't decide when delta = 0

    			}

    			// start

    			this._startTime = null; // unschedule
    			deltaTime = timeDirection * timeRunning;

    		}

    		// apply time scale and advance time

    		deltaTime *= this._updateTimeScale( time );
    		var clipTime = this._updateTime( deltaTime );

    		// note: _updateTime may disable the action resulting in
    		// an effective weight of 0

    		var weight = this._updateWeight( time );

    		if ( weight > 0 ) {

    			var interpolants = this._interpolants;
    			var propertyMixers = this._propertyBindings;

    			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

    				interpolants[ j ].evaluate( clipTime );
    				propertyMixers[ j ].accumulate( accuIndex, weight );

    			}

    		}

    	},

    	_updateWeight: function( time ) {

    		var weight = 0;

    		if ( this.enabled ) {

    			weight = this.weight;
    			var interpolant = this._weightInterpolant;

    			if ( interpolant !== null ) {

    				var interpolantValue = interpolant.evaluate( time )[ 0 ];

    				weight *= interpolantValue;

    				if ( time > interpolant.parameterPositions[ 1 ] ) {

    					this.stopFading();

    					if ( interpolantValue === 0 ) {

    						// faded out, disable
    						this.enabled = false;

    					}

    				}

    			}

    		}

    		this._effectiveWeight = weight;
    		return weight;

    	},

    	_updateTimeScale: function( time ) {

    		var timeScale = 0;

    		if ( ! this.paused ) {

    			timeScale = this.timeScale;

    			var interpolant = this._timeScaleInterpolant;

    			if ( interpolant !== null ) {

    				var interpolantValue = interpolant.evaluate( time )[ 0 ];

    				timeScale *= interpolantValue;

    				if ( time > interpolant.parameterPositions[ 1 ] ) {

    					this.stopWarping();

    					if ( timeScale === 0 ) {

    						// motion has halted, pause
    						this.paused = true;

    					} else {

    						// warp done - apply final time scale
    						this.timeScale = timeScale;

    					}

    				}

    			}

    		}

    		this._effectiveTimeScale = timeScale;
    		return timeScale;

    	},

    	_updateTime: function( deltaTime ) {

    		var time = this.time + deltaTime;

    		if ( deltaTime === 0 ) return time;

    		var duration = this._clip.duration,

    			loop = this.loop,
    			loopCount = this._loopCount;

    		if ( loop === LoopOnce ) {

    			if ( loopCount === -1 ) {
    				// just started

    				this.loopCount = 0;
    				this._setEndings( true, true, false );

    			}

    			handle_stop: {

    				if ( time >= duration ) {

    					time = duration;

    				} else if ( time < 0 ) {

    					time = 0;

    				} else break handle_stop;

    				if ( this.clampWhenFinished ) this.paused = true;
    				else this.enabled = false;

    				this._mixer.dispatchEvent( {
    					type: 'finished', action: this,
    					direction: deltaTime < 0 ? -1 : 1
    				} );

    			}

    		} else { // repetitive Repeat or PingPong

    			var pingPong = ( loop === LoopPingPong );

    			if ( loopCount === -1 ) {
    				// just started

    				if ( deltaTime >= 0 ) {

    					loopCount = 0;

    					this._setEndings(
    							true, this.repetitions === 0, pingPong );

    				} else {

    					// when looping in reverse direction, the initial
    					// transition through zero counts as a repetition,
    					// so leave loopCount at -1

    					this._setEndings(
    							this.repetitions === 0, true, pingPong );

    				}

    			}

    			if ( time >= duration || time < 0 ) {
    				// wrap around

    				var loopDelta = Math.floor( time / duration ); // signed
    				time -= duration * loopDelta;

    				loopCount += Math.abs( loopDelta );

    				var pending = this.repetitions - loopCount;

    				if ( pending < 0 ) {
    					// have to stop (switch state, clamp time, fire event)

    					if ( this.clampWhenFinished ) this.paused = true;
    					else this.enabled = false;

    					time = deltaTime > 0 ? duration : 0;

    					this._mixer.dispatchEvent( {
    						type: 'finished', action: this,
    						direction: deltaTime > 0 ? 1 : -1
    					} );

    				} else {
    					// keep running

    					if ( pending === 0 ) {
    						// entering the last round

    						var atStart = deltaTime < 0;
    						this._setEndings( atStart, ! atStart, pingPong );

    					} else {

    						this._setEndings( false, false, pingPong );

    					}

    					this._loopCount = loopCount;

    					this._mixer.dispatchEvent( {
    						type: 'loop', action: this, loopDelta: loopDelta
    					} );

    				}

    			}

    			if ( pingPong && ( loopCount & 1 ) === 1 ) {
    				// invert time for the "pong round"

    				this.time = time;
    				return duration - time;

    			}

    		}

    		this.time = time;
    		return time;

    	},

    	_setEndings: function( atStart, atEnd, pingPong ) {

    		var settings = this._interpolantSettings;

    		if ( pingPong ) {

    			settings.endingStart 	= ZeroSlopeEnding;
    			settings.endingEnd		= ZeroSlopeEnding;

    		} else {

    			// assuming for LoopOnce atStart == atEnd == true

    			if ( atStart ) {

    				settings.endingStart = this.zeroSlopeAtStart ?
    						ZeroSlopeEnding : ZeroCurvatureEnding;

    			} else {

    				settings.endingStart = WrapAroundEnding;

    			}

    			if ( atEnd ) {

    				settings.endingEnd = this.zeroSlopeAtEnd ?
    						ZeroSlopeEnding : ZeroCurvatureEnding;

    			} else {

    				settings.endingEnd 	 = WrapAroundEnding;

    			}

    		}

    	},

    	_scheduleFading: function( duration, weightNow, weightThen ) {

    		var mixer = this._mixer, now = mixer.time,
    			interpolant = this._weightInterpolant;

    		if ( interpolant === null ) {

    			interpolant = mixer._lendControlInterpolant(),
    			this._weightInterpolant = interpolant;

    		}

    		var times = interpolant.parameterPositions,
    			values = interpolant.sampleValues;

    		times[ 0 ] = now; 				values[ 0 ] = weightNow;
    		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

    		return this;

    	}

    };

    /**
     *
     * Player for AnimationClips.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function AnimationMixer( root ) {

    	this._root = root;
    	this._initMemoryManager();
    	this._accuIndex = 0;

    	this.time = 0;

    	this.timeScale = 1.0;

    }

    Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {

    	// return an action for a clip optionally using a custom root target
    	// object (this method allocates a lot of dynamic memory in case a
    	// previously unknown clip/root combination is specified)
    	clipAction: function( clip, optionalRoot ) {

    		var root = optionalRoot || this._root,
    			rootUuid = root.uuid,

    			clipObject = typeof clip === 'string' ?
    					AnimationClip.findByName( root, clip ) : clip,

    			clipUuid = clipObject !== null ? clipObject.uuid : clip,

    			actionsForClip = this._actionsByClip[ clipUuid ],
    			prototypeAction = null;

    		if ( actionsForClip !== undefined ) {

    			var existingAction =
    					actionsForClip.actionByRoot[ rootUuid ];

    			if ( existingAction !== undefined ) {

    				return existingAction;

    			}

    			// we know the clip, so we don't have to parse all
    			// the bindings again but can just copy
    			prototypeAction = actionsForClip.knownActions[ 0 ];

    			// also, take the clip from the prototype action
    			if ( clipObject === null )
    				clipObject = prototypeAction._clip;

    		}

    		// clip must be known when specified via string
    		if ( clipObject === null ) return null;

    		// allocate all resources required to run it
    		var newAction = new AnimationAction( this, clipObject, optionalRoot );

    		this._bindAction( newAction, prototypeAction );

    		// and make the action known to the memory manager
    		this._addInactiveAction( newAction, clipUuid, rootUuid );

    		return newAction;

    	},

    	// get an existing action
    	existingAction: function( clip, optionalRoot ) {

    		var root = optionalRoot || this._root,
    			rootUuid = root.uuid,

    			clipObject = typeof clip === 'string' ?
    					AnimationClip.findByName( root, clip ) : clip,

    			clipUuid = clipObject ? clipObject.uuid : clip,

    			actionsForClip = this._actionsByClip[ clipUuid ];

    		if ( actionsForClip !== undefined ) {

    			return actionsForClip.actionByRoot[ rootUuid ] || null;

    		}

    		return null;

    	},

    	// deactivates all previously scheduled actions
    	stopAllAction: function() {

    		var actions = this._actions,
    			nActions = this._nActiveActions,
    			bindings = this._bindings,
    			nBindings = this._nActiveBindings;

    		this._nActiveActions = 0;
    		this._nActiveBindings = 0;

    		for ( var i = 0; i !== nActions; ++ i ) {

    			actions[ i ].reset();

    		}

    		for ( var i = 0; i !== nBindings; ++ i ) {

    			bindings[ i ].useCount = 0;

    		}

    		return this;

    	},

    	// advance the time and update apply the animation
    	update: function( deltaTime ) {

    		deltaTime *= this.timeScale;

    		var actions = this._actions,
    			nActions = this._nActiveActions,

    			time = this.time += deltaTime,
    			timeDirection = Math.sign( deltaTime ),

    			accuIndex = this._accuIndex ^= 1;

    		// run active actions

    		for ( var i = 0; i !== nActions; ++ i ) {

    			var action = actions[ i ];

    			if ( action.enabled ) {

    				action._update( time, deltaTime, timeDirection, accuIndex );

    			}

    		}

    		// update scene graph

    		var bindings = this._bindings,
    			nBindings = this._nActiveBindings;

    		for ( var i = 0; i !== nBindings; ++ i ) {

    			bindings[ i ].apply( accuIndex );

    		}

    		return this;

    	},

    	// return this mixer's root target object
    	getRoot: function() {

    		return this._root;

    	},

    	// free all resources specific to a particular clip
    	uncacheClip: function( clip ) {

    		var actions = this._actions,
    			clipUuid = clip.uuid,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ];

    		if ( actionsForClip !== undefined ) {

    			// note: just calling _removeInactiveAction would mess up the
    			// iteration state and also require updating the state we can
    			// just throw away

    			var actionsToRemove = actionsForClip.knownActions;

    			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

    				var action = actionsToRemove[ i ];

    				this._deactivateAction( action );

    				var cacheIndex = action._cacheIndex,
    					lastInactiveAction = actions[ actions.length - 1 ];

    				action._cacheIndex = null;
    				action._byClipCacheIndex = null;

    				lastInactiveAction._cacheIndex = cacheIndex;
    				actions[ cacheIndex ] = lastInactiveAction;
    				actions.pop();

    				this._removeInactiveBindingsForAction( action );

    			}

    			delete actionsByClip[ clipUuid ];

    		}

    	},

    	// free all resources specific to a particular root target object
    	uncacheRoot: function( root ) {

    		var rootUuid = root.uuid,
    			actionsByClip = this._actionsByClip;

    		for ( var clipUuid in actionsByClip ) {

    			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
    				action = actionByRoot[ rootUuid ];

    			if ( action !== undefined ) {

    				this._deactivateAction( action );
    				this._removeInactiveAction( action );

    			}

    		}

    		var bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ];

    		if ( bindingByName !== undefined ) {

    			for ( var trackName in bindingByName ) {

    				var binding = bindingByName[ trackName ];
    				binding.restoreOriginalState();
    				this._removeInactiveBinding( binding );

    			}

    		}

    	},

    	// remove a targeted clip from the cache
    	uncacheAction: function( clip, optionalRoot ) {

    		var action = this.existingAction( clip, optionalRoot );

    		if ( action !== null ) {

    			this._deactivateAction( action );
    			this._removeInactiveAction( action );

    		}

    	}

    } );

    // Implementation details:

    Object.assign( AnimationMixer.prototype, {

    	_bindAction: function( action, prototypeAction ) {

    		var root = action._localRoot || this._root,
    			tracks = action._clip.tracks,
    			nTracks = tracks.length,
    			bindings = action._propertyBindings,
    			interpolants = action._interpolants,
    			rootUuid = root.uuid,
    			bindingsByRoot = this._bindingsByRootAndName,
    			bindingsByName = bindingsByRoot[ rootUuid ];

    		if ( bindingsByName === undefined ) {

    			bindingsByName = {};
    			bindingsByRoot[ rootUuid ] = bindingsByName;

    		}

    		for ( var i = 0; i !== nTracks; ++ i ) {

    			var track = tracks[ i ],
    				trackName = track.name,
    				binding = bindingsByName[ trackName ];

    			if ( binding !== undefined ) {

    				bindings[ i ] = binding;

    			} else {

    				binding = bindings[ i ];

    				if ( binding !== undefined ) {

    					// existing binding, make sure the cache knows

    					if ( binding._cacheIndex === null ) {

    						++ binding.referenceCount;
    						this._addInactiveBinding( binding, rootUuid, trackName );

    					}

    					continue;

    				}

    				var path = prototypeAction && prototypeAction.
    						_propertyBindings[ i ].binding.parsedPath;

    				binding = new PropertyMixer(
    						PropertyBinding.create( root, trackName, path ),
    						track.ValueTypeName, track.getValueSize() );

    				++ binding.referenceCount;
    				this._addInactiveBinding( binding, rootUuid, trackName );

    				bindings[ i ] = binding;

    			}

    			interpolants[ i ].resultBuffer = binding.buffer;

    		}

    	},

    	_activateAction: function( action ) {

    		if ( ! this._isActiveAction( action ) ) {

    			if ( action._cacheIndex === null ) {

    				// this action has been forgotten by the cache, but the user
    				// appears to be still using it -> rebind

    				var rootUuid = ( action._localRoot || this._root ).uuid,
    					clipUuid = action._clip.uuid,
    					actionsForClip = this._actionsByClip[ clipUuid ];

    				this._bindAction( action,
    						actionsForClip && actionsForClip.knownActions[ 0 ] );

    				this._addInactiveAction( action, clipUuid, rootUuid );

    			}

    			var bindings = action._propertyBindings;

    			// increment reference counts / sort out state
    			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    				var binding = bindings[ i ];

    				if ( binding.useCount ++ === 0 ) {

    					this._lendBinding( binding );
    					binding.saveOriginalState();

    				}

    			}

    			this._lendAction( action );

    		}

    	},

    	_deactivateAction: function( action ) {

    		if ( this._isActiveAction( action ) ) {

    			var bindings = action._propertyBindings;

    			// decrement reference counts / sort out state
    			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    				var binding = bindings[ i ];

    				if ( -- binding.useCount === 0 ) {

    					binding.restoreOriginalState();
    					this._takeBackBinding( binding );

    				}

    			}

    			this._takeBackAction( action );

    		}

    	},

    	// Memory manager

    	_initMemoryManager: function() {

    		this._actions = []; // 'nActiveActions' followed by inactive ones
    		this._nActiveActions = 0;

    		this._actionsByClip = {};
    		// inside:
    		// {
    		// 		knownActions: Array< AnimationAction >	- used as prototypes
    		// 		actionByRoot: AnimationAction			- lookup
    		// }


    		this._bindings = []; // 'nActiveBindings' followed by inactive ones
    		this._nActiveBindings = 0;

    		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


    		this._controlInterpolants = []; // same game as above
    		this._nActiveControlInterpolants = 0;

    		var scope = this;

    		this.stats = {

    			actions: {
    				get total() { return scope._actions.length; },
    				get inUse() { return scope._nActiveActions; }
    			},
    			bindings: {
    				get total() { return scope._bindings.length; },
    				get inUse() { return scope._nActiveBindings; }
    			},
    			controlInterpolants: {
    				get total() { return scope._controlInterpolants.length; },
    				get inUse() { return scope._nActiveControlInterpolants; }
    			}

    		};

    	},

    	// Memory management for AnimationAction objects

    	_isActiveAction: function( action ) {

    		var index = action._cacheIndex;
    		return index !== null && index < this._nActiveActions;

    	},

    	_addInactiveAction: function( action, clipUuid, rootUuid ) {

    		var actions = this._actions,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ];

    		if ( actionsForClip === undefined ) {

    			actionsForClip = {

    				knownActions: [ action ],
    				actionByRoot: {}

    			};

    			action._byClipCacheIndex = 0;

    			actionsByClip[ clipUuid ] = actionsForClip;

    		} else {

    			var knownActions = actionsForClip.knownActions;

    			action._byClipCacheIndex = knownActions.length;
    			knownActions.push( action );

    		}

    		action._cacheIndex = actions.length;
    		actions.push( action );

    		actionsForClip.actionByRoot[ rootUuid ] = action;

    	},

    	_removeInactiveAction: function( action ) {

    		var actions = this._actions,
    			lastInactiveAction = actions[ actions.length - 1 ],
    			cacheIndex = action._cacheIndex;

    		lastInactiveAction._cacheIndex = cacheIndex;
    		actions[ cacheIndex ] = lastInactiveAction;
    		actions.pop();

    		action._cacheIndex = null;


    		var clipUuid = action._clip.uuid,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ],
    			knownActionsForClip = actionsForClip.knownActions,

    			lastKnownAction =
    				knownActionsForClip[ knownActionsForClip.length - 1 ],

    			byClipCacheIndex = action._byClipCacheIndex;

    		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
    		knownActionsForClip.pop();

    		action._byClipCacheIndex = null;


    		var actionByRoot = actionsForClip.actionByRoot,
    			rootUuid = ( actions._localRoot || this._root ).uuid;

    		delete actionByRoot[ rootUuid ];

    		if ( knownActionsForClip.length === 0 ) {

    			delete actionsByClip[ clipUuid ];

    		}

    		this._removeInactiveBindingsForAction( action );

    	},

    	_removeInactiveBindingsForAction: function( action ) {

    		var bindings = action._propertyBindings;
    		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    			var binding = bindings[ i ];

    			if ( -- binding.referenceCount === 0 ) {

    				this._removeInactiveBinding( binding );

    			}

    		}

    	},

    	_lendAction: function( action ) {

    		// [ active actions |  inactive actions  ]
    		// [  active actions >| inactive actions ]
    		//                 s        a
    		//                  <-swap->
    		//                 a        s

    		var actions = this._actions,
    			prevIndex = action._cacheIndex,

    			lastActiveIndex = this._nActiveActions ++,

    			firstInactiveAction = actions[ lastActiveIndex ];

    		action._cacheIndex = lastActiveIndex;
    		actions[ lastActiveIndex ] = action;

    		firstInactiveAction._cacheIndex = prevIndex;
    		actions[ prevIndex ] = firstInactiveAction;

    	},

    	_takeBackAction: function( action ) {

    		// [  active actions  | inactive actions ]
    		// [ active actions |< inactive actions  ]
    		//        a        s
    		//         <-swap->
    		//        s        a

    		var actions = this._actions,
    			prevIndex = action._cacheIndex,

    			firstInactiveIndex = -- this._nActiveActions,

    			lastActiveAction = actions[ firstInactiveIndex ];

    		action._cacheIndex = firstInactiveIndex;
    		actions[ firstInactiveIndex ] = action;

    		lastActiveAction._cacheIndex = prevIndex;
    		actions[ prevIndex ] = lastActiveAction;

    	},

    	// Memory management for PropertyMixer objects

    	_addInactiveBinding: function( binding, rootUuid, trackName ) {

    		var bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ],

    			bindings = this._bindings;

    		if ( bindingByName === undefined ) {

    			bindingByName = {};
    			bindingsByRoot[ rootUuid ] = bindingByName;

    		}

    		bindingByName[ trackName ] = binding;

    		binding._cacheIndex = bindings.length;
    		bindings.push( binding );

    	},

    	_removeInactiveBinding: function( binding ) {

    		var bindings = this._bindings,
    			propBinding = binding.binding,
    			rootUuid = propBinding.rootNode.uuid,
    			trackName = propBinding.path,
    			bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ],

    			lastInactiveBinding = bindings[ bindings.length - 1 ],
    			cacheIndex = binding._cacheIndex;

    		lastInactiveBinding._cacheIndex = cacheIndex;
    		bindings[ cacheIndex ] = lastInactiveBinding;
    		bindings.pop();

    		delete bindingByName[ trackName ];

    		remove_empty_map: {

    			for ( var _ in bindingByName ) break remove_empty_map;

    			delete bindingsByRoot[ rootUuid ];

    		}

    	},

    	_lendBinding: function( binding ) {

    		var bindings = this._bindings,
    			prevIndex = binding._cacheIndex,

    			lastActiveIndex = this._nActiveBindings ++,

    			firstInactiveBinding = bindings[ lastActiveIndex ];

    		binding._cacheIndex = lastActiveIndex;
    		bindings[ lastActiveIndex ] = binding;

    		firstInactiveBinding._cacheIndex = prevIndex;
    		bindings[ prevIndex ] = firstInactiveBinding;

    	},

    	_takeBackBinding: function( binding ) {

    		var bindings = this._bindings,
    			prevIndex = binding._cacheIndex,

    			firstInactiveIndex = -- this._nActiveBindings,

    			lastActiveBinding = bindings[ firstInactiveIndex ];

    		binding._cacheIndex = firstInactiveIndex;
    		bindings[ firstInactiveIndex ] = binding;

    		lastActiveBinding._cacheIndex = prevIndex;
    		bindings[ prevIndex ] = lastActiveBinding;

    	},


    	// Memory management of Interpolants for weight and time scale

    	_lendControlInterpolant: function() {

    		var interpolants = this._controlInterpolants,
    			lastActiveIndex = this._nActiveControlInterpolants ++,
    			interpolant = interpolants[ lastActiveIndex ];

    		if ( interpolant === undefined ) {

    			interpolant = new LinearInterpolant(
    					new Float32Array( 2 ), new Float32Array( 2 ),
    						1, this._controlInterpolantsResultBuffer );

    			interpolant.__cacheIndex = lastActiveIndex;
    			interpolants[ lastActiveIndex ] = interpolant;

    		}

    		return interpolant;

    	},

    	_takeBackControlInterpolant: function( interpolant ) {

    		var interpolants = this._controlInterpolants,
    			prevIndex = interpolant.__cacheIndex,

    			firstInactiveIndex = -- this._nActiveControlInterpolants,

    			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

    		interpolant.__cacheIndex = firstInactiveIndex;
    		interpolants[ firstInactiveIndex ] = interpolant;

    		lastActiveInterpolant.__cacheIndex = prevIndex;
    		interpolants[ prevIndex ] = lastActiveInterpolant;

    	},

    	_controlInterpolantsResultBuffer: new Float32Array( 1 )

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Uniform( value ) {

    	if ( typeof value === 'string' ) {

    		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
    		value = arguments[ 1 ];

    	}

    	this.value = value;

    	this.dynamic = false;

    }

    Uniform.prototype = {

    	constructor: Uniform,

    	onUpdate: function ( callback ) {

    		this.dynamic = true;
    		this.onUpdateCallback = callback;

    		return this;

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferGeometry() {

    	BufferGeometry.call( this );

    	this.type = 'InstancedBufferGeometry';
    	this.maxInstancedCount = undefined;

    }

    InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;

    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

    InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

    	this.groups.push( {

    		start: start,
    		count: count,
    		instances: instances

    	} );

    };

    InstancedBufferGeometry.prototype.copy = function ( source ) {

    	var index = source.index;

    	if ( index !== null ) {

    		this.setIndex( index.clone() );

    	}

    	var attributes = source.attributes;

    	for ( var name in attributes ) {

    		var attribute = attributes[ name ];
    		this.addAttribute( name, attribute.clone() );

    	}

    	var groups = source.groups;

    	for ( var i = 0, l = groups.length; i < l; i ++ ) {

    		var group = groups[ i ];
    		this.addGroup( group.start, group.count, group.instances );

    	}

    	return this;

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

    	this.uuid = exports.Math.generateUUID();

    	this.data = interleavedBuffer;
    	this.itemSize = itemSize;
    	this.offset = offset;

    	this.normalized = normalized === true;

    }


    InterleavedBufferAttribute.prototype = {

    	constructor: InterleavedBufferAttribute,

    	isInterleavedBufferAttribute: true,

    	get count() {

    		return this.data.count;

    	},

    	get array() {

    		return this.data.array;

    	},

    	setX: function ( index, x ) {

    		this.data.array[ index * this.data.stride + this.offset ] = x;

    		return this;

    	},

    	setY: function ( index, y ) {

    		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

    		return this;

    	},

    	setZ: function ( index, z ) {

    		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

    		return this;

    	},

    	setW: function ( index, w ) {

    		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

    		return this;

    	},

    	getX: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset ];

    	},

    	getY: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 1 ];

    	},

    	getZ: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 2 ];

    	},

    	getW: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 3 ];

    	},

    	setXY: function ( index, x, y ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;

    		return this;

    	},

    	setXYZ: function ( index, x, y, z ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;

    		return this;

    	},

    	setXYZW: function ( index, x, y, z, w ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;
    		this.data.array[ index + 3 ] = w;

    		return this;

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBuffer( array, stride ) {

    	this.uuid = exports.Math.generateUUID();

    	this.array = array;
    	this.stride = stride;
    	this.count = array !== undefined ? array.length / stride : 0;

    	this.dynamic = false;
    	this.updateRange = { offset: 0, count: - 1 };

    	this.version = 0;

    }

    InterleavedBuffer.prototype = {

    	constructor: InterleavedBuffer,

    	isInterleavedBuffer: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	setDynamic: function ( value ) {

    		this.dynamic = value;

    		return this;

    	},

    	copy: function ( source ) {

    		this.array = new source.array.constructor( source.array );
    		this.count = source.count;
    		this.stride = source.stride;
    		this.dynamic = source.dynamic;

    		return this;

    	},

    	copyAt: function ( index1, attribute, index2 ) {

    		index1 *= this.stride;
    		index2 *= attribute.stride;

    		for ( var i = 0, l = this.stride; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	},

    	set: function ( value, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.array.set( value, offset );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

    	InterleavedBuffer.call( this, array, stride );

    	this.meshPerAttribute = meshPerAttribute || 1;

    }

    InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
    InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;

    InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

    InstancedInterleavedBuffer.prototype.copy = function ( source ) {

    	InterleavedBuffer.prototype.copy.call( this, source );

    	this.meshPerAttribute = source.meshPerAttribute;

    	return this;

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

    	BufferAttribute.call( this, array, itemSize );

    	this.meshPerAttribute = meshPerAttribute || 1;

    }

    InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;

    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

    InstancedBufferAttribute.prototype.copy = function ( source ) {

    	BufferAttribute.prototype.copy.call( this, source );

    	this.meshPerAttribute = source.meshPerAttribute;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author bhouston / http://clara.io/
     * @author stephomi / http://stephaneginier.com/
     */

    function Raycaster( origin, direction, near, far ) {

    	this.ray = new Ray( origin, direction );
    	// direction is assumed to be normalized (for accurate distance calculations)

    	this.near = near || 0;
    	this.far = far || Infinity;

    	this.params = {
    		Mesh: {},
    		Line: {},
    		LOD: {},
    		Points: { threshold: 1 },
    		Sprite: {}
    	};

    	Object.defineProperties( this.params, {
    		PointCloud: {
    			get: function () {
    				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
    				return this.Points;
    			}
    		}
    	} );

    }

    function ascSort( a, b ) {

    	return a.distance - b.distance;

    }

    function intersectObject( object, raycaster, intersects, recursive ) {

    	if ( object.visible === false ) return;

    	object.raycast( raycaster, intersects );

    	if ( recursive === true ) {

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			intersectObject( children[ i ], raycaster, intersects, true );

    		}

    	}

    }

    //

    Raycaster.prototype = {

    	constructor: Raycaster,

    	linePrecision: 1,

    	set: function ( origin, direction ) {

    		// direction is assumed to be normalized (for accurate distance calculations)

    		this.ray.set( origin, direction );

    	},

    	setFromCamera: function ( coords, camera ) {

    		if ( (camera && camera.isPerspectiveCamera) ) {

    			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
    			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

    		} else if ( (camera && camera.isOrthographicCamera) ) {

    			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
    			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

    		} else {

    			console.error( 'THREE.Raycaster: Unsupported camera type.' );

    		}

    	},

    	intersectObject: function ( object, recursive ) {

    		var intersects = [];

    		intersectObject( object, this, intersects, recursive );

    		intersects.sort( ascSort );

    		return intersects;

    	},

    	intersectObjects: function ( objects, recursive ) {

    		var intersects = [];

    		if ( Array.isArray( objects ) === false ) {

    			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
    			return intersects;

    		}

    		for ( var i = 0, l = objects.length; i < l; i ++ ) {

    			intersectObject( objects[ i ], this, intersects, recursive );

    		}

    		intersects.sort( ascSort );

    		return intersects;

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Clock( autoStart ) {

    	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    	this.startTime = 0;
    	this.oldTime = 0;
    	this.elapsedTime = 0;

    	this.running = false;

    }

    Clock.prototype = {

    	constructor: Clock,

    	start: function () {

    		this.startTime = ( performance || Date ).now();

    		this.oldTime = this.startTime;
    		this.running = true;

    	},

    	stop: function () {

    		this.getElapsedTime();
    		this.running = false;

    	},

    	getElapsedTime: function () {

    		this.getDelta();
    		return this.elapsedTime;

    	},

    	getDelta: function () {

    		var diff = 0;

    		if ( this.autoStart && ! this.running ) {

    			this.start();

    		}

    		if ( this.running ) {

    			var newTime = ( performance || Date ).now();

    			diff = ( newTime - this.oldTime ) / 1000;
    			this.oldTime = newTime;

    			this.elapsedTime += diff;

    		}

    		return diff;

    	}

    };

    /**
     * Spline from Tween.js, slightly optimized (and trashed)
     * http://sole.github.com/tween.js/examples/05_spline.html
     *
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Spline( points ) {

    	this.points = points;

    	var c = [], v3 = { x: 0, y: 0, z: 0 },
    	point, intPoint, weight, w2, w3,
    	pa, pb, pc, pd;

    	this.initFromArray = function ( a ) {

    		this.points = [];

    		for ( var i = 0; i < a.length; i ++ ) {

    			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

    		}

    	};

    	this.getPoint = function ( k ) {

    		point = ( this.points.length - 1 ) * k;
    		intPoint = Math.floor( point );
    		weight = point - intPoint;

    		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    		c[ 1 ] = intPoint;
    		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

    		pa = this.points[ c[ 0 ] ];
    		pb = this.points[ c[ 1 ] ];
    		pc = this.points[ c[ 2 ] ];
    		pd = this.points[ c[ 3 ] ];

    		w2 = weight * weight;
    		w3 = weight * w2;

    		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
    		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
    		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

    		return v3;

    	};

    	this.getControlPointsArray = function () {

    		var i, p, l = this.points.length,
    			coords = [];

    		for ( i = 0; i < l; i ++ ) {

    			p = this.points[ i ];
    			coords[ i ] = [ p.x, p.y, p.z ];

    		}

    		return coords;

    	};

    	// approximate length by summing linear segments

    	this.getLength = function ( nSubDivisions ) {

    		var i, index, nSamples, position,
    			point = 0, intPoint = 0, oldIntPoint = 0,
    			oldPosition = new Vector3(),
    			tmpVec = new Vector3(),
    			chunkLengths = [],
    			totalLength = 0;

    		// first point has 0 length

    		chunkLengths[ 0 ] = 0;

    		if ( ! nSubDivisions ) nSubDivisions = 100;

    		nSamples = this.points.length * nSubDivisions;

    		oldPosition.copy( this.points[ 0 ] );

    		for ( i = 1; i < nSamples; i ++ ) {

    			index = i / nSamples;

    			position = this.getPoint( index );
    			tmpVec.copy( position );

    			totalLength += tmpVec.distanceTo( oldPosition );

    			oldPosition.copy( position );

    			point = ( this.points.length - 1 ) * index;
    			intPoint = Math.floor( point );

    			if ( intPoint !== oldIntPoint ) {

    				chunkLengths[ intPoint ] = totalLength;
    				oldIntPoint = intPoint;

    			}

    		}

    		// last point ends with total length

    		chunkLengths[ chunkLengths.length ] = totalLength;

    		return { chunks: chunkLengths, total: totalLength };

    	};

    	this.reparametrizeByArcLength = function ( samplingCoef ) {

    		var i, j,
    			index, indexCurrent, indexNext,
    			realDistance,
    			sampling, position,
    			newpoints = [],
    			tmpVec = new Vector3(),
    			sl = this.getLength();

    		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

    		for ( i = 1; i < this.points.length; i ++ ) {

    			//tmpVec.copy( this.points[ i - 1 ] );
    			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

    			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

    			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

    			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
    			indexNext = i / ( this.points.length - 1 );

    			for ( j = 1; j < sampling - 1; j ++ ) {

    				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

    				position = this.getPoint( index );
    				newpoints.push( tmpVec.copy( position ).clone() );

    			}

    			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

    		}

    		this.points = newpoints;

    	};

    	// Catmull-Rom

    	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

    		var v0 = ( p2 - p0 ) * 0.5,
    			v1 = ( p3 - p1 ) * 0.5;

    		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    	}

    }

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
     *
     * The poles (phi) are at the positive and negative y axis.
     * The equator starts at positive z.
     */

    function Spherical( radius, phi, theta ) {

    	this.radius = ( radius !== undefined ) ? radius : 1.0;
    	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
    	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

    	return this;

    }

    Spherical.prototype = {

    	constructor: Spherical,

    	set: function ( radius, phi, theta ) {

    		this.radius = radius;
    		this.phi = phi;
    		this.theta = theta;

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( other ) {

    		this.radius.copy( other.radius );
    		this.phi.copy( other.phi );
    		this.theta.copy( other.theta );

    		return this;

    	},

    	// restrict phi to be betwee EPS and PI-EPS
    	makeSafe: function() {

    		var EPS = 0.000001;
    		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

    		return this;

    	},

    	setFromVector3: function( vec3 ) {

    		this.radius = vec3.length();

    		if ( this.radius === 0 ) {

    			this.theta = 0;
    			this.phi = 0;

    		} else {

    			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
    			this.phi = Math.acos( exports.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

    		}

    		return this;

    	},

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function MorphBlendMesh( geometry, material ) {

    	Mesh.call( this, geometry, material );

    	this.animationsMap = {};
    	this.animationsList = [];

    	// prepare default animation
    	// (all frames played together in 1 second)

    	var numFrames = this.geometry.morphTargets.length;

    	var name = "__default";

    	var startFrame = 0;
    	var endFrame = numFrames - 1;

    	var fps = numFrames / 1;

    	this.createAnimation( name, startFrame, endFrame, fps );
    	this.setAnimationWeight( name, 1 );

    }

    MorphBlendMesh.prototype = Object.create( Mesh.prototype );
    MorphBlendMesh.prototype.constructor = MorphBlendMesh;

    MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

    	var animation = {

    		start: start,
    		end: end,

    		length: end - start + 1,

    		fps: fps,
    		duration: ( end - start ) / fps,

    		lastFrame: 0,
    		currentFrame: 0,

    		active: false,

    		time: 0,
    		direction: 1,
    		weight: 1,

    		directionBackwards: false,
    		mirroredLoop: false

    	};

    	this.animationsMap[ name ] = animation;
    	this.animationsList.push( animation );

    };

    MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

    	var pattern = /([a-z]+)_?(\d+)/i;

    	var firstAnimation, frameRanges = {};

    	var geometry = this.geometry;

    	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    		var morph = geometry.morphTargets[ i ];
    		var chunks = morph.name.match( pattern );

    		if ( chunks && chunks.length > 1 ) {

    			var name = chunks[ 1 ];

    			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

    			var range = frameRanges[ name ];

    			if ( i < range.start ) range.start = i;
    			if ( i > range.end ) range.end = i;

    			if ( ! firstAnimation ) firstAnimation = name;

    		}

    	}

    	for ( var name in frameRanges ) {

    		var range = frameRanges[ name ];
    		this.createAnimation( name, range.start, range.end, fps );

    	}

    	this.firstAnimation = firstAnimation;

    };

    MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.direction = 1;
    		animation.directionBackwards = false;

    	}

    };

    MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.direction = - 1;
    		animation.directionBackwards = true;

    	}

    };

    MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.fps = fps;
    		animation.duration = ( animation.end - animation.start ) / animation.fps;

    	}

    };

    MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.duration = duration;
    		animation.fps = ( animation.end - animation.start ) / animation.duration;

    	}

    };

    MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.weight = weight;

    	}

    };

    MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.time = time;

    	}

    };

    MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

    	var time = 0;

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		time = animation.time;

    	}

    	return time;

    };

    MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

    	var duration = - 1;

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		duration = animation.duration;

    	}

    	return duration;

    };

    MorphBlendMesh.prototype.playAnimation = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.time = 0;
    		animation.active = true;

    	} else {

    		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

    	}

    };

    MorphBlendMesh.prototype.stopAnimation = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.active = false;

    	}

    };

    MorphBlendMesh.prototype.update = function ( delta ) {

    	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

    		var animation = this.animationsList[ i ];

    		if ( ! animation.active ) continue;

    		var frameTime = animation.duration / animation.length;

    		animation.time += animation.direction * delta;

    		if ( animation.mirroredLoop ) {

    			if ( animation.time > animation.duration || animation.time < 0 ) {

    				animation.direction *= - 1;

    				if ( animation.time > animation.duration ) {

    					animation.time = animation.duration;
    					animation.directionBackwards = true;

    				}

    				if ( animation.time < 0 ) {

    					animation.time = 0;
    					animation.directionBackwards = false;

    				}

    			}

    		} else {

    			animation.time = animation.time % animation.duration;

    			if ( animation.time < 0 ) animation.time += animation.duration;

    		}

    		var keyframe = animation.start + exports.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
    		var weight = animation.weight;

    		if ( keyframe !== animation.currentFrame ) {

    			this.morphTargetInfluences[ animation.lastFrame ] = 0;
    			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

    			this.morphTargetInfluences[ keyframe ] = 0;

    			animation.lastFrame = animation.currentFrame;
    			animation.currentFrame = keyframe;

    		}

    		var mix = ( animation.time % frameTime ) / frameTime;

    		if ( animation.directionBackwards ) mix = 1 - mix;

    		if ( animation.currentFrame !== animation.lastFrame ) {

    			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
    			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

    		} else {

    			this.morphTargetInfluences[ animation.currentFrame ] = weight;

    		}

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function ImmediateRenderObject( material ) {

    	Object3D.call( this );

    	this.material = material;
    	this.render = function ( renderCallback ) {};

    }

    ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

    ImmediateRenderObject.prototype.isImmediateRenderObject = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function VertexNormalsHelper( object, size, hex, linewidth ) {

    	this.object = object;

    	this.size = ( size !== undefined ) ? size : 1;

    	var color = ( hex !== undefined ) ? hex : 0xff0000;

    	var width = ( linewidth !== undefined ) ? linewidth : 1;

    	//

    	var nNormals = 0;

    	var objGeometry = this.object.geometry;

    	if ( (objGeometry && objGeometry.isGeometry) ) {

    		nNormals = objGeometry.faces.length * 3;

    	} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

    		nNormals = objGeometry.attributes.normal.count;

    	}

    	//

    	var geometry = new BufferGeometry();

    	var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

    	geometry.addAttribute( 'position', positions );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    	//

    	this.matrixAutoUpdate = false;

    	this.update();

    }

    VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

    VertexNormalsHelper.prototype.update = ( function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var normalMatrix = new Matrix3();

    	return function update() {

    		var keys = [ 'a', 'b', 'c' ];

    		this.object.updateMatrixWorld( true );

    		normalMatrix.getNormalMatrix( this.object.matrixWorld );

    		var matrixWorld = this.object.matrixWorld;

    		var position = this.geometry.attributes.position;

    		//

    		var objGeometry = this.object.geometry;

    		if ( (objGeometry && objGeometry.isGeometry) ) {

    			var vertices = objGeometry.vertices;

    			var faces = objGeometry.faces;

    			var idx = 0;

    			for ( var i = 0, l = faces.length; i < l; i ++ ) {

    				var face = faces[ i ];

    				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

    					var vertex = vertices[ face[ keys[ j ] ] ];

    					var normal = face.vertexNormals[ j ];

    					v1.copy( vertex ).applyMatrix4( matrixWorld );

    					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    					position.setXYZ( idx, v1.x, v1.y, v1.z );

    					idx = idx + 1;

    					position.setXYZ( idx, v2.x, v2.y, v2.z );

    					idx = idx + 1;

    				}

    			}

    		} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

    			var objPos = objGeometry.attributes.position;

    			var objNorm = objGeometry.attributes.normal;

    			var idx = 0;

    			// for simplicity, ignore index and drawcalls, and render every normal

    			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

    				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

    				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

    				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    				position.setXYZ( idx, v1.x, v1.y, v1.z );

    				idx = idx + 1;

    				position.setXYZ( idx, v2.x, v2.y, v2.z );

    				idx = idx + 1;

    			}

    		}

    		position.needsUpdate = true;

    		return this;

    	};

    }() );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function SpotLightHelper( light ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	var geometry = new BufferGeometry();

    	var positions = [
    		0, 0, 0,   0,   0,   1,
    		0, 0, 0,   1,   0,   1,
    		0, 0, 0, - 1,   0,   1,
    		0, 0, 0,   0,   1,   1,
    		0, 0, 0,   0, - 1,   1
    	];

    	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

    		var p1 = ( i / l ) * Math.PI * 2;
    		var p2 = ( j / l ) * Math.PI * 2;

    		positions.push(
    			Math.cos( p1 ), Math.sin( p1 ), 1,
    			Math.cos( p2 ), Math.sin( p2 ), 1
    		);

    	}

    	geometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );

    	var material = new LineBasicMaterial( { fog: false } );

    	this.cone = new LineSegments( geometry, material );
    	this.add( this.cone );

    	this.update();

    }

    SpotLightHelper.prototype = Object.create( Object3D.prototype );
    SpotLightHelper.prototype.constructor = SpotLightHelper;

    SpotLightHelper.prototype.dispose = function () {

    	this.cone.geometry.dispose();
    	this.cone.material.dispose();

    };

    SpotLightHelper.prototype.update = function () {

    	var vector = new Vector3();
    	var vector2 = new Vector3();

    	return function update() {

    		var coneLength = this.light.distance ? this.light.distance : 1000;
    		var coneWidth = coneLength * Math.tan( this.light.angle );

    		this.cone.scale.set( coneWidth, coneWidth, coneLength );

    		vector.setFromMatrixPosition( this.light.matrixWorld );
    		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

    		this.cone.lookAt( vector2.sub( vector ) );

    		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	};

    }();

    /**
     * @author Sean Griffin / http://twitter.com/sgrif
     * @author Michael Guerrero / http://realitymeltdown.com
     * @author mrdoob / http://mrdoob.com/
     * @author ikerr / http://verold.com
     */

    function SkeletonHelper( object ) {

    	this.bones = this.getBoneList( object );

    	var geometry = new Geometry();

    	for ( var i = 0; i < this.bones.length; i ++ ) {

    		var bone = this.bones[ i ];

    		if ( (bone.parent && bone.parent.isBone) ) {

    			geometry.vertices.push( new Vector3() );
    			geometry.vertices.push( new Vector3() );
    			geometry.colors.push( new Color( 0, 0, 1 ) );
    			geometry.colors.push( new Color( 0, 1, 0 ) );

    		}

    	}

    	geometry.dynamic = true;

    	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

    	LineSegments.call( this, geometry, material );

    	this.root = object;

    	this.matrix = object.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.update();

    }


    SkeletonHelper.prototype = Object.create( LineSegments.prototype );
    SkeletonHelper.prototype.constructor = SkeletonHelper;

    SkeletonHelper.prototype.getBoneList = function( object ) {

    	var boneList = [];

    	if ( (object && object.isBone) ) {

    		boneList.push( object );

    	}

    	for ( var i = 0; i < object.children.length; i ++ ) {

    		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

    	}

    	return boneList;

    };

    SkeletonHelper.prototype.update = function () {

    	var geometry = this.geometry;

    	var matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );

    	var boneMatrix = new Matrix4();

    	var j = 0;

    	for ( var i = 0; i < this.bones.length; i ++ ) {

    		var bone = this.bones[ i ];

    		if ( (bone.parent && bone.parent.isBone) ) {

    			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
    			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

    			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
    			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

    			j += 2;

    		}

    	}

    	geometry.verticesNeedUpdate = true;

    	geometry.computeBoundingSphere();

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function PointLightHelper( light, sphereSize ) {

    	this.light = light;
    	this.light.updateMatrixWorld();

    	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
    	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
    	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	Mesh.call( this, geometry, material );

    	this.matrix = this.light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	/*
    	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
    	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

    	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

    	var d = light.distance;

    	if ( d === 0.0 ) {

    		this.lightDistance.visible = false;

    	} else {

    		this.lightDistance.scale.set( d, d, d );

    	}

    	this.add( this.lightDistance );
    	*/

    }

    PointLightHelper.prototype = Object.create( Mesh.prototype );
    PointLightHelper.prototype.constructor = PointLightHelper;

    PointLightHelper.prototype.dispose = function () {

    	this.geometry.dispose();
    	this.material.dispose();

    };

    PointLightHelper.prototype.update = function () {

    	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	/*
    	var d = this.light.distance;

    	if ( d === 0.0 ) {

    		this.lightDistance.visible = false;

    	} else {

    		this.lightDistance.visible = true;
    		this.lightDistance.scale.set( d, d, d );

    	}
    	*/

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function HemisphereLightHelper( light, sphereSize ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.colors = [ new Color(), new Color() ];

    	var geometry = new SphereGeometry( sphereSize, 4, 2 );
    	geometry.rotateX( - Math.PI / 2 );

    	for ( var i = 0, il = 8; i < il; i ++ ) {

    		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

    	}

    	var material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );

    	this.lightSphere = new Mesh( geometry, material );
    	this.add( this.lightSphere );

    	this.update();

    }

    HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

    HemisphereLightHelper.prototype.dispose = function () {

    	this.lightSphere.geometry.dispose();
    	this.lightSphere.material.dispose();

    };

    HemisphereLightHelper.prototype.update = function () {

    	var vector = new Vector3();

    	return function update() {

    		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
    		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

    		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    		this.lightSphere.geometry.colorsNeedUpdate = true;

    	};

    }();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function GridHelper( size, divisions, color1, color2 ) {

    	divisions = divisions || 1;
    	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
    	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

    	var center = divisions / 2;
    	var step = ( size * 2 ) / divisions;
    	var vertices = [], colors = [];

    	for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {

    		vertices.push( - size, 0, k, size, 0, k );
    		vertices.push( k, 0, - size, k, 0, size );

    		var color = i === center ? color1 : color2;

    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;

    	}

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );
    	geometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );

    	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    	LineSegments.call( this, geometry, material );

    }

    GridHelper.prototype = Object.create( LineSegments.prototype );
    GridHelper.prototype.constructor = GridHelper;

    GridHelper.prototype.setColors = function () {

    	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function FaceNormalsHelper( object, size, hex, linewidth ) {

    	// FaceNormalsHelper only supports THREE.Geometry

    	this.object = object;

    	this.size = ( size !== undefined ) ? size : 1;

    	var color = ( hex !== undefined ) ? hex : 0xffff00;

    	var width = ( linewidth !== undefined ) ? linewidth : 1;

    	//

    	var nNormals = 0;

    	var objGeometry = this.object.geometry;

    	if ( (objGeometry && objGeometry.isGeometry) ) {

    		nNormals = objGeometry.faces.length;

    	} else {

    		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    	}

    	//

    	var geometry = new BufferGeometry();

    	var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

    	geometry.addAttribute( 'position', positions );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    	//

    	this.matrixAutoUpdate = false;
    	this.update();

    }

    FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
    FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

    FaceNormalsHelper.prototype.update = ( function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var normalMatrix = new Matrix3();

    	return function update() {

    		this.object.updateMatrixWorld( true );

    		normalMatrix.getNormalMatrix( this.object.matrixWorld );

    		var matrixWorld = this.object.matrixWorld;

    		var position = this.geometry.attributes.position;

    		//

    		var objGeometry = this.object.geometry;

    		var vertices = objGeometry.vertices;

    		var faces = objGeometry.faces;

    		var idx = 0;

    		for ( var i = 0, l = faces.length; i < l; i ++ ) {

    			var face = faces[ i ];

    			var normal = face.normal;

    			v1.copy( vertices[ face.a ] )
    				.add( vertices[ face.b ] )
    				.add( vertices[ face.c ] )
    				.divideScalar( 3 )
    				.applyMatrix4( matrixWorld );

    			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    			position.setXYZ( idx, v1.x, v1.y, v1.z );

    			idx = idx + 1;

    			position.setXYZ( idx, v2.x, v2.y, v2.z );

    			idx = idx + 1;

    		}

    		position.needsUpdate = true;

    		return this;

    	};

    }() );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function DirectionalLightHelper( light, size ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	if ( size === undefined ) size = 1;

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( [
    		- size,   size, 0,
    		  size,   size, 0,
    		  size, - size, 0,
    		- size, - size, 0,
    		- size,   size, 0
    	], 3 ) );

    	var material = new LineBasicMaterial( { fog: false } );

    	this.add( new Line( geometry, material ) );

    	geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

    	this.add( new Line( geometry, material ));

    	this.update();

    }

    DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

    DirectionalLightHelper.prototype.dispose = function () {

    	var lightPlane = this.children[ 0 ];
    	var targetLine = this.children[ 1 ];

    	lightPlane.geometry.dispose();
    	lightPlane.material.dispose();
    	targetLine.geometry.dispose();
    	targetLine.material.dispose();

    };

    DirectionalLightHelper.prototype.update = function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var v3 = new Vector3();

    	return function update() {

    		v1.setFromMatrixPosition( this.light.matrixWorld );
    		v2.setFromMatrixPosition( this.light.target.matrixWorld );
    		v3.subVectors( v2, v1 );

    		var lightPlane = this.children[ 0 ];
    		var targetLine = this.children[ 1 ];

    		lightPlane.lookAt( v3 );
    		lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    		targetLine.lookAt( v3 );
    		targetLine.scale.z = v3.length();

    	};

    }();

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     *	- shows frustum, line of sight and up of the camera
     *	- suitable for fast updates
     * 	- based on frustum visualization in lightgl.js shadowmap example
     *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
     */

    function CameraHelper( camera ) {

    	var geometry = new Geometry();
    	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

    	var pointMap = {};

    	// colors

    	var hexFrustum = 0xffaa00;
    	var hexCone = 0xff0000;
    	var hexUp = 0x00aaff;
    	var hexTarget = 0xffffff;
    	var hexCross = 0x333333;

    	// near

    	addLine( "n1", "n2", hexFrustum );
    	addLine( "n2", "n4", hexFrustum );
    	addLine( "n4", "n3", hexFrustum );
    	addLine( "n3", "n1", hexFrustum );

    	// far

    	addLine( "f1", "f2", hexFrustum );
    	addLine( "f2", "f4", hexFrustum );
    	addLine( "f4", "f3", hexFrustum );
    	addLine( "f3", "f1", hexFrustum );

    	// sides

    	addLine( "n1", "f1", hexFrustum );
    	addLine( "n2", "f2", hexFrustum );
    	addLine( "n3", "f3", hexFrustum );
    	addLine( "n4", "f4", hexFrustum );

    	// cone

    	addLine( "p", "n1", hexCone );
    	addLine( "p", "n2", hexCone );
    	addLine( "p", "n3", hexCone );
    	addLine( "p", "n4", hexCone );

    	// up

    	addLine( "u1", "u2", hexUp );
    	addLine( "u2", "u3", hexUp );
    	addLine( "u3", "u1", hexUp );

    	// target

    	addLine( "c", "t", hexTarget );
    	addLine( "p", "c", hexCross );

    	// cross

    	addLine( "cn1", "cn2", hexCross );
    	addLine( "cn3", "cn4", hexCross );

    	addLine( "cf1", "cf2", hexCross );
    	addLine( "cf3", "cf4", hexCross );

    	function addLine( a, b, hex ) {

    		addPoint( a, hex );
    		addPoint( b, hex );

    	}

    	function addPoint( id, hex ) {

    		geometry.vertices.push( new Vector3() );
    		geometry.colors.push( new Color( hex ) );

    		if ( pointMap[ id ] === undefined ) {

    			pointMap[ id ] = [];

    		}

    		pointMap[ id ].push( geometry.vertices.length - 1 );

    	}

    	LineSegments.call( this, geometry, material );

    	this.camera = camera;
    	if( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

    	this.matrix = camera.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.pointMap = pointMap;

    	this.update();

    }

    CameraHelper.prototype = Object.create( LineSegments.prototype );
    CameraHelper.prototype.constructor = CameraHelper;

    CameraHelper.prototype.update = function () {

    	var geometry, pointMap;

    	var vector = new Vector3();
    	var camera = new Camera();

    	function setPoint( point, x, y, z ) {

    		vector.set( x, y, z ).unproject( camera );

    		var points = pointMap[ point ];

    		if ( points !== undefined ) {

    			for ( var i = 0, il = points.length; i < il; i ++ ) {

    				geometry.vertices[ points[ i ] ].copy( vector );

    			}

    		}

    	}

    	return function update() {

    		geometry = this.geometry;
    		pointMap = this.pointMap;

    		var w = 1, h = 1;

    		// we need just camera projection matrix
    		// world matrix must be identity

    		camera.projectionMatrix.copy( this.camera.projectionMatrix );

    		// center / target

    		setPoint( "c", 0, 0, - 1 );
    		setPoint( "t", 0, 0,  1 );

    		// near

    		setPoint( "n1", - w, - h, - 1 );
    		setPoint( "n2",   w, - h, - 1 );
    		setPoint( "n3", - w,   h, - 1 );
    		setPoint( "n4",   w,   h, - 1 );

    		// far

    		setPoint( "f1", - w, - h, 1 );
    		setPoint( "f2",   w, - h, 1 );
    		setPoint( "f3", - w,   h, 1 );
    		setPoint( "f4",   w,   h, 1 );

    		// up

    		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
    		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
    		setPoint( "u3",         0, h * 2,   - 1 );

    		// cross

    		setPoint( "cf1", - w,   0, 1 );
    		setPoint( "cf2",   w,   0, 1 );
    		setPoint( "cf3",   0, - h, 1 );
    		setPoint( "cf4",   0,   h, 1 );

    		setPoint( "cn1", - w,   0, - 1 );
    		setPoint( "cn2",   w,   0, - 1 );
    		setPoint( "cn3",   0, - h, - 1 );
    		setPoint( "cn4",   0,   h, - 1 );

    		geometry.verticesNeedUpdate = true;

    	};

    }();

    /**
     * @author WestLangley / http://github.com/WestLangley
     */

    // a helper to show the world-axis-aligned bounding box for an object

    function BoundingBoxHelper( object, hex ) {

    	var color = ( hex !== undefined ) ? hex : 0x888888;

    	this.object = object;

    	this.box = new Box3();

    	Mesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );

    }

    BoundingBoxHelper.prototype = Object.create( Mesh.prototype );
    BoundingBoxHelper.prototype.constructor = BoundingBoxHelper;

    BoundingBoxHelper.prototype.update = function () {

    	this.box.setFromObject( this.object );

    	this.box.size( this.scale );

    	this.box.getCenter( this.position );

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BoxHelper( object, color ) {

    	if ( color === undefined ) color = 0xffff00;

    	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    	var positions = new Float32Array( 8 * 3 );

    	var geometry = new BufferGeometry();
    	geometry.setIndex( new BufferAttribute( indices, 1 ) );
    	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

    	if ( object !== undefined ) {

    		this.update( object );

    	}

    }

    BoxHelper.prototype = Object.create( LineSegments.prototype );
    BoxHelper.prototype.constructor = BoxHelper;

    BoxHelper.prototype.update = ( function () {

    	var box = new Box3();

    	return function update( object ) {

    		if ( (object && object.isBox3) ) {

    			box.copy( object );

    		} else {

    			box.setFromObject( object );

    		}

    		if ( box.isEmpty() ) return;

    		var min = box.min;
    		var max = box.max;

    		/*
    		  5____4
    		1/___0/|
    		| 6__|_7
    		2/___3/

    		0: max.x, max.y, max.z
    		1: min.x, max.y, max.z
    		2: min.x, min.y, max.z
    		3: max.x, min.y, max.z
    		4: max.x, max.y, min.z
    		5: min.x, max.y, min.z
    		6: min.x, min.y, min.z
    		7: max.x, min.y, min.z
    		*/

    		var position = this.geometry.attributes.position;
    		var array = position.array;

    		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
    		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
    		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
    		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
    		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
    		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
    		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
    		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

    		position.needsUpdate = true;

    		this.geometry.computeBoundingSphere();

    	};

    } )();

    var lineGeometry = new BufferGeometry();
    lineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

    var coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
    coneGeometry.translate( 0, - 0.5, 0 );

    function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

    	// dir is assumed to be normalized

    	Object3D.call( this );

    	if ( color === undefined ) color = 0xffff00;
    	if ( length === undefined ) length = 1;
    	if ( headLength === undefined ) headLength = 0.2 * length;
    	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    	this.position.copy( origin );

    	this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
    	this.line.matrixAutoUpdate = false;
    	this.add( this.line );

    	this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
    	this.cone.matrixAutoUpdate = false;
    	this.add( this.cone );

    	this.setDirection( dir );
    	this.setLength( length, headLength, headWidth );

    }

    ArrowHelper.prototype = Object.create( Object3D.prototype );
    ArrowHelper.prototype.constructor = ArrowHelper;

    ArrowHelper.prototype.setDirection = ( function () {

    	var axis = new Vector3();
    	var radians;

    	return function setDirection( dir ) {

    		// dir is assumed to be normalized

    		if ( dir.y > 0.99999 ) {

    			this.quaternion.set( 0, 0, 0, 1 );

    		} else if ( dir.y < - 0.99999 ) {

    			this.quaternion.set( 1, 0, 0, 0 );

    		} else {

    			axis.set( dir.z, 0, - dir.x ).normalize();

    			radians = Math.acos( dir.y );

    			this.quaternion.setFromAxisAngle( axis, radians );

    		}

    	};

    }() );

    ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

    	if ( headLength === undefined ) headLength = 0.2 * length;
    	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
    	this.line.updateMatrix();

    	this.cone.scale.set( headWidth, headLength, headWidth );
    	this.cone.position.y = length;
    	this.cone.updateMatrix();

    };

    ArrowHelper.prototype.setColor = function ( color ) {

    	this.line.material.color.copy( color );
    	this.cone.material.color.copy( color );

    };

    /**
     * @author sroucheray / http://sroucheray.org/
     * @author mrdoob / http://mrdoob.com/
     */

    function AxisHelper( size ) {

    	size = size || 1;

    	var vertices = new Float32Array( [
    		0, 0, 0,  size, 0, 0,
    		0, 0, 0,  0, size, 0,
    		0, 0, 0,  0, 0, size
    	] );

    	var colors = new Float32Array( [
    		1, 0, 0,  1, 0.6, 0,
    		0, 1, 0,  0.6, 1, 0,
    		0, 0, 1,  0, 0.6, 1
    	] );

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

    	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    	LineSegments.call( this, geometry, material );

    }

    AxisHelper.prototype = Object.create( LineSegments.prototype );
    AxisHelper.prototype.constructor = AxisHelper;

    /**
     * @author zz85 https://github.com/zz85
     *
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */

    exports.CatmullRomCurve3 = ( function() {

    	var
    		tmp = new Vector3(),
    		px = new CubicPoly(),
    		py = new CubicPoly(),
    		pz = new CubicPoly();

    	/*
    	Based on an optimized c++ solution in
    	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
    	 - http://ideone.com/NoEbVM

    	This CubicPoly class could be used for reusing some variables and calculations,
    	but for three.js curve use, it could be possible inlined and flatten into a single function call
    	which can be placed in CurveUtils.
    	*/

    	function CubicPoly() {

    	}

    	/*
    	 * Compute coefficients for a cubic polynomial
    	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
    	 * such that
    	 *   p(0) = x0, p(1) = x1
    	 *  and
    	 *   p'(0) = t0, p'(1) = t1.
    	 */
    	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

    		this.c0 = x0;
    		this.c1 = t0;
    		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
    		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

    	};

    	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

    		// compute tangents when parameterized in [t1,t2]
    		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
    		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

    		// rescale tangents for parametrization in [0,1]
    		t1 *= dt1;
    		t2 *= dt1;

    		// initCubicPoly
    		this.init( x1, x2, t1, t2 );

    	};

    	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

    		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    	};

    	CubicPoly.prototype.calc = function( t ) {

    		var t2 = t * t;
    		var t3 = t2 * t;
    		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

    	};

    	// Subclass Three.js curve
    	return Curve.create(

    		function ( p /* array of Vector3 */ ) {

    			this.points = p || [];
    			this.closed = false;

    		},

    		function ( t ) {

    			var points = this.points,
    				point, intPoint, weight, l;

    			l = points.length;

    			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

    			point = ( l - ( this.closed ? 0 : 1 ) ) * t;
    			intPoint = Math.floor( point );
    			weight = point - intPoint;

    			if ( this.closed ) {

    				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

    			} else if ( weight === 0 && intPoint === l - 1 ) {

    				intPoint = l - 2;
    				weight = 1;

    			}

    			var p0, p1, p2, p3; // 4 points

    			if ( this.closed || intPoint > 0 ) {

    				p0 = points[ ( intPoint - 1 ) % l ];

    			} else {

    				// extrapolate first point
    				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
    				p0 = tmp;

    			}

    			p1 = points[ intPoint % l ];
    			p2 = points[ ( intPoint + 1 ) % l ];

    			if ( this.closed || intPoint + 2 < l ) {

    				p3 = points[ ( intPoint + 2 ) % l ];

    			} else {

    				// extrapolate last point
    				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
    				p3 = tmp;

    			}

    			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

    				// init Centripetal / Chordal Catmull-Rom
    				var pow = this.type === 'chordal' ? 0.5 : 0.25;
    				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
    				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
    				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

    				// safety check for repeated points
    				if ( dt1 < 1e-4 ) dt1 = 1.0;
    				if ( dt0 < 1e-4 ) dt0 = dt1;
    				if ( dt2 < 1e-4 ) dt2 = dt1;

    				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
    				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
    				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

    			} else if ( this.type === 'catmullrom' ) {

    				var tension = this.tension !== undefined ? this.tension : 0.5;
    				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
    				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
    				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

    			}

    			var v = new Vector3(
    				px.calc( weight ),
    				py.calc( weight ),
    				pz.calc( weight )
    			);

    			return v;

    		}

    	);

    } )();

    /**************************************************************
     *	Closed Spline 3D curve
     **************************************************************/


    function ClosedSplineCurve3( points ) {

    	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );

    	exports.CatmullRomCurve3.call( this, points );
    	this.type = 'catmullrom';
    	this.closed = true;

    }

    ClosedSplineCurve3.prototype = Object.create( exports.CatmullRomCurve3.prototype );

    /**************************************************************
     *	Spline 3D curve
     **************************************************************/


    var SplineCurve3 = Curve.create(

    	function ( points /* array of Vector3 */ ) {

    		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
    		this.points = ( points === undefined ) ? [] : points;

    	},

    	function ( t ) {

    		var points = this.points;
    		var point = ( points.length - 1 ) * t;

    		var intPoint = Math.floor( point );
    		var weight = point - intPoint;

    		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
    		var point1 = points[ intPoint ];
    		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    		var interpolate = exports.CurveUtils.interpolate;

    		return new Vector3(
    			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
    			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
    			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
    		);

    	}

    );

    /**************************************************************
     *	Cubic Bezier 3D curve
     **************************************************************/

    exports.CubicBezierCurve3 = Curve.create(

    	function ( v0, v1, v2, v3 ) {

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;
    		this.v3 = v3;

    	},

    	function ( t ) {

    		var b3 = exports.ShapeUtils.b3;

    		return new Vector3(
    			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
    			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
    		);

    	}

    );

    /**************************************************************
     *	Quadratic Bezier 3D curve
     **************************************************************/

    exports.QuadraticBezierCurve3 = Curve.create(

    	function ( v0, v1, v2 ) {

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;

    	},

    	function ( t ) {

    		var b2 = exports.ShapeUtils.b2;		

    		return new Vector3(
    			b2( t, this.v0.x, this.v1.x, this.v2.x ),
    			b2( t, this.v0.y, this.v1.y, this.v2.y ),
    			b2( t, this.v0.z, this.v1.z, this.v2.z )
    		);

    	}

    );

    /**************************************************************
     *	Line3D
     **************************************************************/

    exports.LineCurve3 = Curve.create(

    	function ( v1, v2 ) {

    		this.v1 = v1;
    		this.v2 = v2;

    	},

    	function ( t ) {

    		if ( t === 1 ) {

    			return this.v2.clone();

    		}

    		var vector = new Vector3();

    		vector.subVectors( this.v2, this.v1 ); // diff
    		vector.multiplyScalar( t );
    		vector.add( this.v1 );

    		return vector;

    	}

    );

    /**************************************************************
     *	Arc curve
     **************************************************************/

    function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    }

    ArcCurve.prototype = Object.create( EllipseCurve.prototype );
    ArcCurve.prototype.constructor = ArcCurve;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    exports.SceneUtils = {

    	createMultiMaterialObject: function ( geometry, materials ) {

    		var group = new Group();

    		for ( var i = 0, l = materials.length; i < l; i ++ ) {

    			group.add( new Mesh( geometry, materials[ i ] ) );

    		}

    		return group;

    	},

    	detach: function ( child, parent, scene ) {

    		child.applyMatrix( parent.matrixWorld );
    		parent.remove( child );
    		scene.add( child );

    	},

    	attach: function ( child, scene, parent ) {

    		var matrixWorldInverse = new Matrix4();
    		matrixWorldInverse.getInverse( parent.matrixWorld );
    		child.applyMatrix( matrixWorldInverse );

    		scene.remove( child );
    		parent.add( child );

    	}

    };

    function Face4 ( a, b, c, d, normal, color, materialIndex ) {
    	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    	return new Face3( a, b, c, normal, color, materialIndex );
    }

    var LineStrip = 0;

    var LinePieces = 1;

    function PointCloud ( geometry, material ) {
    	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    	return new Points( geometry, material );
    }

    function ParticleSystem ( geometry, material ) {
    	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    	return new Points( geometry, material );
    }

    function PointCloudMaterial ( parameters ) {
    	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function ParticleBasicMaterial ( parameters ) {
    	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function ParticleSystemMaterial ( parameters ) {
    	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function Vertex ( x, y, z ) {
    	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
    	return new Vector3( x, y, z );
    }

    //

    function EdgesHelper( object, hex ) {
    	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
    	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    }

    function WireframeHelper( object, hex ) {
    	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
    	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    }

    //

    Object.assign( Box2.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	},
    	empty: function () {
    		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
    		return this.isEmpty();
    	},
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	size: function ( optionalTarget ) {
    		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
    		return this.getSize( optionalTarget );
    	}
    } );

    Object.assign( Box3.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	},
    	empty: function () {
    		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
    		return this.isEmpty();
    	},
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	isIntersectionSphere: function ( sphere ) {
    		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
    		return this.intersectsSphere( sphere );
    	},
    	size: function ( optionalTarget ) {
    		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
    		return this.getSize( optionalTarget );
    	}
    } );

    Object.assign( Line3.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	}
    } );

    Object.assign( Matrix3.prototype, {
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
    		return vector.applyMatrix3( this );
    	},
    	multiplyVector3Array: function ( a ) {
    		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    		return this.applyToVector3Array( a );
    	}
    } );

    Object.assign( Matrix4.prototype, {
    	extractPosition: function ( m ) {
    		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
    		return this.copyPosition( m );
    	},
    	setRotationFromQuaternion: function ( q ) {
    		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
    		return this.makeRotationFromQuaternion( q );
    	},
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
    		return vector.applyProjection( this );
    	},
    	multiplyVector4: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    		return vector.applyMatrix4( this );
    	},
    	multiplyVector3Array: function ( a ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    		return this.applyToVector3Array( a );
    	},
    	rotateAxis: function ( v ) {
    		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
    		v.transformDirection( this );
    	},
    	crossVector: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    		return vector.applyMatrix4( this );
    	},
    	translate: function ( v ) {
    		console.error( 'THREE.Matrix4: .translate() has been removed.' );
    	},
    	rotateX: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
    	},
    	rotateY: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
    	},
    	rotateZ: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
    	},
    	rotateByAxis: function ( axis, angle ) {
    		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
    	}
    } );

    Object.assign( Plane.prototype, {
    	isIntersectionLine: function ( line ) {
    		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
    		return this.intersectsLine( line );
    	}
    } );

    Object.assign( Quaternion.prototype, {
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    		return vector.applyQuaternion( this );
    	}
    } );

    Object.assign( Ray.prototype, {
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	isIntersectionPlane: function ( plane ) {
    		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
    		return this.intersectsPlane( plane );
    	},
    	isIntersectionSphere: function ( sphere ) {
    		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
    		return this.intersectsSphere( sphere );
    	}
    } );

    Object.assign( Shape.prototype, {
    	extrude: function ( options ) {
    		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
    		return new ExtrudeGeometry( this, options );
    	},
    	makeGeometry: function ( options ) {
    		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
    		return new ShapeGeometry( this, options );
    	}
    } );

    Object.assign( Vector3.prototype, {
    	setEulerFromRotationMatrix: function () {
    		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
    	},
    	setEulerFromQuaternion: function () {
    		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
    	},
    	getPositionFromMatrix: function ( m ) {
    		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
    		return this.setFromMatrixPosition( m );
    	},
    	getScaleFromMatrix: function ( m ) {
    		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
    		return this.setFromMatrixScale( m );
    	},
    	getColumnFromMatrix: function ( index, matrix ) {
    		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
    		return this.setFromMatrixColumn( matrix, index );
    	}
    } );

    //

    Object.assign( Object3D.prototype, {
    	getChildByName: function ( name ) {
    		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
    		return this.getObjectByName( name );
    	},
    	renderDepth: function ( value ) {
    		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
    	},
    	translate: function ( distance, axis ) {
    		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
    		return this.translateOnAxis( axis, distance );
    	}
    } );

    Object.defineProperties( Object3D.prototype, {
    	eulerOrder: {
    		get: function () {
    			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
    			return this.rotation.order;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
    			this.rotation.order = value;
    		}
    	},
    	useQuaternion: {
    		get: function () {
    			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    		}
    	}
    } );

    Object.defineProperties( LOD.prototype, {
    	objects: {
    		get: function () {
    			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
    			return this.levels;
    		}
    	}
    } );

    //

    PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

    	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
    			"Use .setFocalLength and .filmGauge for a photographic setup." );

    	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
    	this.setFocalLength( focalLength );

    };

    //

    Object.defineProperties( Light.prototype, {
    	onlyShadow: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .onlyShadow has been removed.' );
    		}
    	},
    	shadowCameraFov: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
    			this.shadow.camera.fov = value;
    		}
    	},
    	shadowCameraLeft: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
    			this.shadow.camera.left = value;
    		}
    	},
    	shadowCameraRight: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
    			this.shadow.camera.right = value;
    		}
    	},
    	shadowCameraTop: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
    			this.shadow.camera.top = value;
    		}
    	},
    	shadowCameraBottom: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
    			this.shadow.camera.bottom = value;
    		}
    	},
    	shadowCameraNear: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
    			this.shadow.camera.near = value;
    		}
    	},
    	shadowCameraFar: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
    			this.shadow.camera.far = value;
    		}
    	},
    	shadowCameraVisible: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
    		}
    	},
    	shadowBias: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
    			this.shadow.bias = value;
    		}
    	},
    	shadowDarkness: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
    		}
    	},
    	shadowMapWidth: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
    			this.shadow.mapSize.width = value;
    		}
    	},
    	shadowMapHeight: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
    			this.shadow.mapSize.height = value;
    		}
    	}
    } );

    //

    Object.defineProperties( BufferAttribute.prototype, {
    	length: {
    		get: function () {
    			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
    			return this.array.length;
    		}
    	}
    } );

    Object.assign( BufferGeometry.prototype, {
    	addIndex: function ( index ) {
    		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
    		this.setIndex( index );
    	},
    	addDrawCall: function ( start, count, indexOffset ) {
    		if ( indexOffset !== undefined ) {
    			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
    		}
    		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
    		this.addGroup( start, count );
    	},
    	clearDrawCalls: function () {
    		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
    		this.clearGroups();
    	},
    	computeTangents: function () {
    		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
    	},
    	computeOffsets: function () {
    		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
    	}
    } );

    Object.defineProperties( BufferGeometry.prototype, {
    	drawcalls: {
    		get: function () {
    			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
    			return this.groups;
    		}
    	},
    	offsets: {
    		get: function () {
    			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
    			return this.groups;
    		}
    	}
    } );

    //

    Object.defineProperties( Material.prototype, {
    	wrapAround: {
    		get: function () {
    			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    		}
    	},
    	wrapRGB: {
    		get: function () {
    			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
    			return new Color();
    		}
    	}
    } );

    Object.defineProperties( MeshPhongMaterial.prototype, {
    	metal: {
    		get: function () {
    			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
    			return false;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
    		}
    	}
    } );

    Object.defineProperties( ShaderMaterial.prototype, {
    	derivatives: {
    		get: function () {
    			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
    			return this.extensions.derivatives;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
    			this.extensions.derivatives = value;
    		}
    	}
    } );

    //

    EventDispatcher.prototype = Object.assign( Object.create( {

    	// Note: Extra base ensures these properties are not 'assign'ed.

    	constructor: EventDispatcher,

    	apply: function ( target ) {

    		console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
    				"just inherit or Object.assign the prototype to mix-in." );

    		Object.assign( target, this );

    	}

    } ), EventDispatcher.prototype );

    //

    Object.assign( WebGLRenderer.prototype, {
    	supportsFloatTextures: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
    		return this.extensions.get( 'OES_texture_float' );
    	},
    	supportsHalfFloatTextures: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
    		return this.extensions.get( 'OES_texture_half_float' );
    	},
    	supportsStandardDerivatives: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
    		return this.extensions.get( 'OES_standard_derivatives' );
    	},
    	supportsCompressedTextureS3TC: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
    		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
    	},
    	supportsCompressedTexturePVRTC: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
    		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
    	},
    	supportsBlendMinMax: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
    		return this.extensions.get( 'EXT_blend_minmax' );
    	},
    	supportsVertexTextures: function () {
    		return this.capabilities.vertexTextures;
    	},
    	supportsInstancedArrays: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
    		return this.extensions.get( 'ANGLE_instanced_arrays' );
    	},
    	enableScissorTest: function ( boolean ) {
    		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
    		this.setScissorTest( boolean );
    	},
    	initMaterial: function () {
    		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
    	},
    	addPrePlugin: function () {
    		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
    	},
    	addPostPlugin: function () {
    		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
    	},
    	updateShadowMap: function () {
    		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
    	}
    } );

    Object.defineProperties( WebGLRenderer.prototype, {
    	shadowMapEnabled: {
    		get: function () {
    			return this.shadowMap.enabled;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
    			this.shadowMap.enabled = value;
    		}
    	},
    	shadowMapType: {
    		get: function () {
    			return this.shadowMap.type;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
    			this.shadowMap.type = value;
    		}
    	},
    	shadowMapCullFace: {
    		get: function () {
    			return this.shadowMap.cullFace;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
    			this.shadowMap.cullFace = value;
    		}
    	}
    } );

    Object.defineProperties( WebGLShadowMap.prototype, {
    	cullFace: {
    		get: function () {
    			return this.renderReverseSided ? CullFaceFront : CullFaceBack;
    		},
    		set: function ( cullFace ) {
    			var value = ( cullFace !== CullFaceBack );
    			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
    			this.renderReverseSided = value;
    		}
    	}
    } );

    //

    Object.defineProperties( WebGLRenderTarget.prototype, {
    	wrapS: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
    			return this.texture.wrapS;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
    			this.texture.wrapS = value;
    		}
    	},
    	wrapT: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
    			return this.texture.wrapT;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
    			this.texture.wrapT = value;
    		}
    	},
    	magFilter: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
    			return this.texture.magFilter;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
    			this.texture.magFilter = value;
    		}
    	},
    	minFilter: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
    			return this.texture.minFilter;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
    			this.texture.minFilter = value;
    		}
    	},
    	anisotropy: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
    			return this.texture.anisotropy;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
    			this.texture.anisotropy = value;
    		}
    	},
    	offset: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
    			return this.texture.offset;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
    			this.texture.offset = value;
    		}
    	},
    	repeat: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
    			return this.texture.repeat;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
    			this.texture.repeat = value;
    		}
    	},
    	format: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
    			return this.texture.format;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
    			this.texture.format = value;
    		}
    	},
    	type: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
    			return this.texture.type;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
    			this.texture.type = value;
    		}
    	},
    	generateMipmaps: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
    			return this.texture.generateMipmaps;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
    			this.texture.generateMipmaps = value;
    		}
    	}
    } );

    //

    Object.assign( Audio.prototype, {
    	load: function ( file ) {
    		console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
    		var scope = this;
    		var audioLoader = new AudioLoader();
    		audioLoader.load( file, function ( buffer ) {
    			scope.setBuffer( buffer );
    		} );
    		return this;
    	}
    } );

    Object.assign( AudioAnalyser.prototype, {
    	getData: function ( file ) {
    		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
    		return this.getFrequencyData();
    	}
    } );

    //

    var GeometryUtils = {

    	merge: function ( geometry1, geometry2, materialIndexOffset ) {

    		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

    		var matrix;

    		if ( geometry2.isMesh ) {

    			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

    			matrix = geometry2.matrix;
    			geometry2 = geometry2.geometry;

    		}

    		geometry1.merge( geometry2, matrix, materialIndexOffset );

    	},

    	center: function ( geometry ) {

    		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
    		return geometry.center();

    	}

    };

    var ImageUtils = {

    	crossOrigin: undefined,

    	loadTexture: function ( url, mapping, onLoad, onError ) {

    		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

    		var loader = new TextureLoader();
    		loader.setCrossOrigin( this.crossOrigin );

    		var texture = loader.load( url, onLoad, undefined, onError );

    		if ( mapping ) texture.mapping = mapping;

    		return texture;

    	},

    	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

    		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

    		var loader = new CubeTextureLoader();
    		loader.setCrossOrigin( this.crossOrigin );

    		var texture = loader.load( urls, onLoad, undefined, onError );

    		if ( mapping ) texture.mapping = mapping;

    		return texture;

    	},

    	loadCompressedTexture: function () {

    		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

    	},

    	loadCompressedTextureCube: function () {

    		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

    	}

    };

    //

    function Projector () {

    	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    	this.projectVector = function ( vector, camera ) {

    		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    		vector.project( camera );

    	};

    	this.unprojectVector = function ( vector, camera ) {

    		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    		vector.unproject( camera );

    	};

    	this.pickingRay = function ( vector, camera ) {

    		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    	};

    }

    //

    function CanvasRenderer () {

    	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    	this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    	this.clear = function () {};
    	this.render = function () {};
    	this.setClearColor = function () {};
    	this.setSize = function () {};

    }

    Object.defineProperty( exports, 'AudioContext', {
    	get: function () {
    		return exports.getAudioContext();
    	}
    });

    exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
    exports.WebGLRenderTarget = WebGLRenderTarget;
    exports.WebGLRenderer = WebGLRenderer;
    exports.ShaderLib = ShaderLib;
    exports.UniformsLib = UniformsLib;
    exports.ShaderChunk = ShaderChunk;
    exports.FogExp2 = FogExp2;
    exports.Fog = Fog;
    exports.Scene = Scene;
    exports.LensFlare = LensFlare;
    exports.Sprite = Sprite;
    exports.LOD = LOD;
    exports.SkinnedMesh = SkinnedMesh;
    exports.Skeleton = Skeleton;
    exports.Bone = Bone;
    exports.Mesh = Mesh;
    exports.LineSegments = LineSegments;
    exports.Line = Line;
    exports.Points = Points;
    exports.Group = Group;
    exports.VideoTexture = VideoTexture;
    exports.DataTexture = DataTexture;
    exports.CompressedTexture = CompressedTexture;
    exports.CubeTexture = CubeTexture;
    exports.CanvasTexture = CanvasTexture;
    exports.DepthTexture = DepthTexture;
    exports.TextureIdCount = TextureIdCount;
    exports.Texture = Texture;
    exports.MaterialIdCount = MaterialIdCount;
    exports.CompressedTextureLoader = CompressedTextureLoader;
    exports.BinaryTextureLoader = BinaryTextureLoader;
    exports.DataTextureLoader = DataTextureLoader;
    exports.CubeTextureLoader = CubeTextureLoader;
    exports.TextureLoader = TextureLoader;
    exports.ObjectLoader = ObjectLoader;
    exports.MaterialLoader = MaterialLoader;
    exports.BufferGeometryLoader = BufferGeometryLoader;
    exports.LoadingManager = LoadingManager;
    exports.JSONLoader = JSONLoader;
    exports.ImageLoader = ImageLoader;
    exports.FontLoader = FontLoader;
    exports.XHRLoader = XHRLoader;
    exports.Loader = Loader;
    exports.AudioLoader = AudioLoader;
    exports.SpotLightShadow = SpotLightShadow;
    exports.SpotLight = SpotLight;
    exports.PointLight = PointLight;
    exports.HemisphereLight = HemisphereLight;
    exports.DirectionalLightShadow = DirectionalLightShadow;
    exports.DirectionalLight = DirectionalLight;
    exports.AmbientLight = AmbientLight;
    exports.LightShadow = LightShadow;
    exports.Light = Light;
    exports.StereoCamera = StereoCamera;
    exports.PerspectiveCamera = PerspectiveCamera;
    exports.OrthographicCamera = OrthographicCamera;
    exports.CubeCamera = CubeCamera;
    exports.Camera = Camera;
    exports.AudioListener = AudioListener;
    exports.PositionalAudio = PositionalAudio;
    exports.getAudioContext = getAudioContext;
    exports.AudioAnalyser = AudioAnalyser;
    exports.Audio = Audio;
    exports.VectorKeyframeTrack = VectorKeyframeTrack;
    exports.StringKeyframeTrack = StringKeyframeTrack;
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    exports.NumberKeyframeTrack = NumberKeyframeTrack;
    exports.ColorKeyframeTrack = ColorKeyframeTrack;
    exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
    exports.PropertyMixer = PropertyMixer;
    exports.PropertyBinding = PropertyBinding;
    exports.KeyframeTrack = KeyframeTrack;
    exports.AnimationObjectGroup = AnimationObjectGroup;
    exports.AnimationMixer = AnimationMixer;
    exports.AnimationClip = AnimationClip;
    exports.Uniform = Uniform;
    exports.InstancedBufferGeometry = InstancedBufferGeometry;
    exports.BufferGeometry = BufferGeometry;
    exports.GeometryIdCount = GeometryIdCount;
    exports.Geometry = Geometry;
    exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    exports.InterleavedBuffer = InterleavedBuffer;
    exports.InstancedBufferAttribute = InstancedBufferAttribute;
    exports.DynamicBufferAttribute = DynamicBufferAttribute;
    exports.Float64Attribute = Float64Attribute;
    exports.Float32Attribute = Float32Attribute;
    exports.Uint32Attribute = Uint32Attribute;
    exports.Int32Attribute = Int32Attribute;
    exports.Uint16Attribute = Uint16Attribute;
    exports.Int16Attribute = Int16Attribute;
    exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
    exports.Uint8Attribute = Uint8Attribute;
    exports.Int8Attribute = Int8Attribute;
    exports.BufferAttribute = BufferAttribute;
    exports.Face3 = Face3;
    exports.Object3DIdCount = Object3DIdCount;
    exports.Object3D = Object3D;
    exports.Raycaster = Raycaster;
    exports.Layers = Layers;
    exports.EventDispatcher = EventDispatcher;
    exports.Clock = Clock;
    exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    exports.LinearInterpolant = LinearInterpolant;
    exports.DiscreteInterpolant = DiscreteInterpolant;
    exports.CubicInterpolant = CubicInterpolant;
    exports.Interpolant = Interpolant;
    exports.Triangle = Triangle;
    exports.Spline = Spline;
    exports.Spherical = Spherical;
    exports.Plane = Plane;
    exports.Frustum = Frustum;
    exports.Sphere = Sphere;
    exports.Ray = Ray;
    exports.Matrix4 = Matrix4;
    exports.Matrix3 = Matrix3;
    exports.Box3 = Box3;
    exports.Box2 = Box2;
    exports.Line3 = Line3;
    exports.Euler = Euler;
    exports.Vector4 = Vector4;
    exports.Vector3 = Vector3;
    exports.Vector2 = Vector2;
    exports.Quaternion = Quaternion;
    exports.Color = Color;
    exports.MorphBlendMesh = MorphBlendMesh;
    exports.ImmediateRenderObject = ImmediateRenderObject;
    exports.VertexNormalsHelper = VertexNormalsHelper;
    exports.SpotLightHelper = SpotLightHelper;
    exports.SkeletonHelper = SkeletonHelper;
    exports.PointLightHelper = PointLightHelper;
    exports.HemisphereLightHelper = HemisphereLightHelper;
    exports.GridHelper = GridHelper;
    exports.FaceNormalsHelper = FaceNormalsHelper;
    exports.DirectionalLightHelper = DirectionalLightHelper;
    exports.CameraHelper = CameraHelper;
    exports.BoundingBoxHelper = BoundingBoxHelper;
    exports.BoxHelper = BoxHelper;
    exports.ArrowHelper = ArrowHelper;
    exports.AxisHelper = AxisHelper;
    exports.ClosedSplineCurve3 = ClosedSplineCurve3;
    exports.SplineCurve3 = SplineCurve3;
    exports.ArcCurve = ArcCurve;
    exports.EllipseCurve = EllipseCurve;
    exports.SplineCurve = SplineCurve;
    exports.CubicBezierCurve = CubicBezierCurve;
    exports.QuadraticBezierCurve = QuadraticBezierCurve;
    exports.LineCurve = LineCurve;
    exports.Shape = Shape;
    exports.ShapePath = ShapePath;
    exports.Path = Path;
    exports.Font = Font;
    exports.CurvePath = CurvePath;
    exports.Curve = Curve;
    exports.WireframeGeometry = WireframeGeometry;
    exports.ParametricGeometry = ParametricGeometry;
    exports.TetrahedronGeometry = TetrahedronGeometry;
    exports.OctahedronGeometry = OctahedronGeometry;
    exports.IcosahedronGeometry = IcosahedronGeometry;
    exports.DodecahedronGeometry = DodecahedronGeometry;
    exports.PolyhedronGeometry = PolyhedronGeometry;
    exports.TubeGeometry = TubeGeometry;
    exports.TorusKnotGeometry = TorusKnotGeometry;
    exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
    exports.TorusGeometry = TorusGeometry;
    exports.TorusBufferGeometry = TorusBufferGeometry;
    exports.TextGeometry = TextGeometry;
    exports.SphereBufferGeometry = SphereBufferGeometry;
    exports.SphereGeometry = SphereGeometry;
    exports.RingGeometry = RingGeometry;
    exports.RingBufferGeometry = RingBufferGeometry;
    exports.PlaneBufferGeometry = PlaneBufferGeometry;
    exports.PlaneGeometry = PlaneGeometry;
    exports.LatheGeometry = LatheGeometry;
    exports.LatheBufferGeometry = LatheBufferGeometry;
    exports.ShapeGeometry = ShapeGeometry;
    exports.ExtrudeGeometry = ExtrudeGeometry;
    exports.EdgesGeometry = EdgesGeometry;
    exports.ConeGeometry = ConeGeometry;
    exports.ConeBufferGeometry = ConeBufferGeometry;
    exports.CylinderGeometry = CylinderGeometry;
    exports.CylinderBufferGeometry = CylinderBufferGeometry;
    exports.CircleBufferGeometry = CircleBufferGeometry;
    exports.CircleGeometry = CircleGeometry;
    exports.BoxBufferGeometry = BoxBufferGeometry;
    exports.BoxGeometry = BoxGeometry;
    exports.ShadowMaterial = ShadowMaterial;
    exports.SpriteMaterial = SpriteMaterial;
    exports.RawShaderMaterial = RawShaderMaterial;
    exports.ShaderMaterial = ShaderMaterial;
    exports.PointsMaterial = PointsMaterial;
    exports.MultiMaterial = MultiMaterial;
    exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
    exports.MeshStandardMaterial = MeshStandardMaterial;
    exports.MeshPhongMaterial = MeshPhongMaterial;
    exports.MeshNormalMaterial = MeshNormalMaterial;
    exports.MeshLambertMaterial = MeshLambertMaterial;
    exports.MeshDepthMaterial = MeshDepthMaterial;
    exports.MeshBasicMaterial = MeshBasicMaterial;
    exports.LineDashedMaterial = LineDashedMaterial;
    exports.LineBasicMaterial = LineBasicMaterial;
    exports.Material = Material;
    exports.REVISION = REVISION;
    exports.MOUSE = MOUSE;
    exports.CullFaceNone = CullFaceNone;
    exports.CullFaceBack = CullFaceBack;
    exports.CullFaceFront = CullFaceFront;
    exports.CullFaceFrontBack = CullFaceFrontBack;
    exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
    exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
    exports.BasicShadowMap = BasicShadowMap;
    exports.PCFShadowMap = PCFShadowMap;
    exports.PCFSoftShadowMap = PCFSoftShadowMap;
    exports.FrontSide = FrontSide;
    exports.BackSide = BackSide;
    exports.DoubleSide = DoubleSide;
    exports.FlatShading = FlatShading;
    exports.SmoothShading = SmoothShading;
    exports.NoColors = NoColors;
    exports.FaceColors = FaceColors;
    exports.VertexColors = VertexColors;
    exports.NoBlending = NoBlending;
    exports.NormalBlending = NormalBlending;
    exports.AdditiveBlending = AdditiveBlending;
    exports.SubtractiveBlending = SubtractiveBlending;
    exports.MultiplyBlending = MultiplyBlending;
    exports.CustomBlending = CustomBlending;
    exports.BlendingMode = BlendingMode;
    exports.AddEquation = AddEquation;
    exports.SubtractEquation = SubtractEquation;
    exports.ReverseSubtractEquation = ReverseSubtractEquation;
    exports.MinEquation = MinEquation;
    exports.MaxEquation = MaxEquation;
    exports.ZeroFactor = ZeroFactor;
    exports.OneFactor = OneFactor;
    exports.SrcColorFactor = SrcColorFactor;
    exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    exports.SrcAlphaFactor = SrcAlphaFactor;
    exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    exports.DstAlphaFactor = DstAlphaFactor;
    exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    exports.DstColorFactor = DstColorFactor;
    exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    exports.NeverDepth = NeverDepth;
    exports.AlwaysDepth = AlwaysDepth;
    exports.LessDepth = LessDepth;
    exports.LessEqualDepth = LessEqualDepth;
    exports.EqualDepth = EqualDepth;
    exports.GreaterEqualDepth = GreaterEqualDepth;
    exports.GreaterDepth = GreaterDepth;
    exports.NotEqualDepth = NotEqualDepth;
    exports.MultiplyOperation = MultiplyOperation;
    exports.MixOperation = MixOperation;
    exports.AddOperation = AddOperation;
    exports.NoToneMapping = NoToneMapping;
    exports.LinearToneMapping = LinearToneMapping;
    exports.ReinhardToneMapping = ReinhardToneMapping;
    exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
    exports.CineonToneMapping = CineonToneMapping;
    exports.UVMapping = UVMapping;
    exports.CubeReflectionMapping = CubeReflectionMapping;
    exports.CubeRefractionMapping = CubeRefractionMapping;
    exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    exports.SphericalReflectionMapping = SphericalReflectionMapping;
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
    exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
    exports.TextureMapping = TextureMapping;
    exports.RepeatWrapping = RepeatWrapping;
    exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
    exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
    exports.TextureWrapping = TextureWrapping;
    exports.NearestFilter = NearestFilter;
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    exports.LinearFilter = LinearFilter;
    exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    exports.TextureFilter = TextureFilter;
    exports.UnsignedByteType = UnsignedByteType;
    exports.ByteType = ByteType;
    exports.ShortType = ShortType;
    exports.UnsignedShortType = UnsignedShortType;
    exports.IntType = IntType;
    exports.UnsignedIntType = UnsignedIntType;
    exports.FloatType = FloatType;
    exports.HalfFloatType = HalfFloatType;
    exports.UnsignedShort4444Type = UnsignedShort4444Type;
    exports.UnsignedShort5551Type = UnsignedShort5551Type;
    exports.UnsignedShort565Type = UnsignedShort565Type;
    exports.UnsignedInt248Type = UnsignedInt248Type;
    exports.AlphaFormat = AlphaFormat;
    exports.RGBFormat = RGBFormat;
    exports.RGBAFormat = RGBAFormat;
    exports.LuminanceFormat = LuminanceFormat;
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
    exports.RGBEFormat = RGBEFormat;
    exports.DepthFormat = DepthFormat;
    exports.DepthStencilFormat = DepthStencilFormat;
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    exports.RGB_ETC1_Format = RGB_ETC1_Format;
    exports.LoopOnce = LoopOnce;
    exports.LoopRepeat = LoopRepeat;
    exports.LoopPingPong = LoopPingPong;
    exports.InterpolateDiscrete = InterpolateDiscrete;
    exports.InterpolateLinear = InterpolateLinear;
    exports.InterpolateSmooth = InterpolateSmooth;
    exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
    exports.ZeroSlopeEnding = ZeroSlopeEnding;
    exports.WrapAroundEnding = WrapAroundEnding;
    exports.TrianglesDrawMode = TrianglesDrawMode;
    exports.TriangleStripDrawMode = TriangleStripDrawMode;
    exports.TriangleFanDrawMode = TriangleFanDrawMode;
    exports.LinearEncoding = LinearEncoding;
    exports.sRGBEncoding = sRGBEncoding;
    exports.GammaEncoding = GammaEncoding;
    exports.RGBEEncoding = RGBEEncoding;
    exports.LogLuvEncoding = LogLuvEncoding;
    exports.RGBM7Encoding = RGBM7Encoding;
    exports.RGBM16Encoding = RGBM16Encoding;
    exports.RGBDEncoding = RGBDEncoding;
    exports.BasicDepthPacking = BasicDepthPacking;
    exports.RGBADepthPacking = RGBADepthPacking;
    exports.CubeGeometry = BoxGeometry;
    exports.Face4 = Face4;
    exports.LineStrip = LineStrip;
    exports.LinePieces = LinePieces;
    exports.MeshFaceMaterial = MultiMaterial;
    exports.PointCloud = PointCloud;
    exports.Particle = Sprite;
    exports.ParticleSystem = ParticleSystem;
    exports.PointCloudMaterial = PointCloudMaterial;
    exports.ParticleBasicMaterial = ParticleBasicMaterial;
    exports.ParticleSystemMaterial = ParticleSystemMaterial;
    exports.Vertex = Vertex;
    exports.EdgesHelper = EdgesHelper;
    exports.WireframeHelper = WireframeHelper;
    exports.GeometryUtils = GeometryUtils;
    exports.ImageUtils = ImageUtils;
    exports.Projector = Projector;
    exports.CanvasRenderer = CanvasRenderer;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The base class for all VR devices.
 */
function VRDevice() {
  this.hardwareUnitId = 'webvr-polyfill hardwareUnitId';
  this.deviceId = 'webvr-polyfill deviceId';
  this.deviceName = 'webvr-polyfill deviceName';
}

/**
 * The base class for all VR HMD devices.
 */
function HMDVRDevice() {
}
HMDVRDevice.prototype = new VRDevice();

/**
 * The base class for all VR position sensor devices.
 */
function PositionSensorVRDevice() {
}
PositionSensorVRDevice.prototype = new VRDevice();

module.exports.VRDevice = VRDevice;
module.exports.HMDVRDevice = HMDVRDevice;
module.exports.PositionSensorVRDevice = PositionSensorVRDevice;

},{}],2:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;

// Constants from vrtoolkit: https://github.com/googlesamples/cardboard-java.
var DEFAULT_INTERPUPILLARY_DISTANCE = 0.06;
var DEFAULT_FIELD_OF_VIEW = 40;

/**
 * The HMD itself, providing rendering parameters.
 */
function CardboardHMDVRDevice() {
  // From com/google/vrtoolkit/cardboard/FieldOfView.java.
  this.setFieldOfView(DEFAULT_FIELD_OF_VIEW);
  // Set display constants.
  this.setInterpupillaryDistance(DEFAULT_INTERPUPILLARY_DISTANCE);
}
CardboardHMDVRDevice.prototype = new HMDVRDevice();

CardboardHMDVRDevice.prototype.getEyeParameters = function(whichEye) {
  var eyeTranslation;
  if (whichEye == 'left') {
    eyeTranslation = this.eyeTranslationLeft;
  } else if (whichEye == 'right') {
    eyeTranslation = this.eyeTranslationRight;
  } else {
    console.error('Invalid eye provided: %s', whichEye);
    return null;
  }
  return {
    recommendedFieldOfView: this.fov,
    eyeTranslation: eyeTranslation
  };
};

/**
 * Sets the IPD (in m) of this device. Useful for initialization and for
 * changing viewer parameters dynamically.
 */
CardboardHMDVRDevice.prototype.setInterpupillaryDistance = function(ipd) {
  this.eyeTranslationLeft = {
    x: ipd * -0.5,
    y: 0,
    z: 0
  };
  this.eyeTranslationRight = {
    x: ipd * 0.5,
    y: 0,
    z: 0
  };
};

/**
 * Sets the FOV (in degrees) of this viewer. Useful for initialization and
 * changing viewer parameters dynamically.
 */
CardboardHMDVRDevice.prototype.setFieldOfView = function(angle) {
  this.fov = {
    upDegrees: angle,
    downDegrees: angle,
    leftDegrees: angle,
    rightDegrees: angle
  };
};

module.exports = CardboardHMDVRDevice;

},{"./base.js":1}],3:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TODO: Fix up all "new THREE" instantiations to improve performance.
 */
var SensorSample = _dereq_('./sensor-sample.js');
var THREE = _dereq_('./three-math.js');
var Util = _dereq_('./util.js');

var DEBUG = false;

/**
 * An implementation of a simple complementary filter, which fuses gyroscope and
 * accelerometer data from the 'devicemotion' event.
 *
 * Accelerometer data is very noisy, but stable over the long term.
 * Gyroscope data is smooth, but tends to drift over the long term.
 *
 * This fusion is relatively simple:
 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
 *    on that data.
 * 2. Get orientation estimates from gyroscope by integrating over time.
 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
 *    short term.
 */
function ComplementaryFilter(kFilter) {
  this.kFilter = kFilter;

  // Raw sensor measurements.
  this.currentAccelMeasurement = new SensorSample();
  this.currentGyroMeasurement = new SensorSample();
  this.previousGyroMeasurement = new SensorSample();

  // Current filter orientation
  this.filterQ = new THREE.Quaternion();
  this.previousFilterQ = new THREE.Quaternion();

  // Orientation based on the accelerometer.
  this.accelQ = new THREE.Quaternion();
  // Whether or not the orientation has been initialized.
  this.isOrientationInitialized = false;
  // Running estimate of gravity based on the current orientation.
  this.estimatedGravity = new THREE.Vector3();
  // Measured gravity based on accelerometer.
  this.measuredGravity = new THREE.Vector3();

  // Debug only quaternion of gyro-based orientation.
  this.gyroIntegralQ = new THREE.Quaternion();
}

ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
  this.currentAccelMeasurement.set(vector, timestampS);
};

ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
  this.currentGyroMeasurement.set(vector, timestampS);

  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
  if (Util.isTimestampDeltaValid(deltaT)) {
    this.run_();
  }
  
  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
};

ComplementaryFilter.prototype.run_ = function() {

  if (!this.isOrientationInitialized) {
    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
    this.previousFilterQ.copy(this.accelQ);
    this.isOrientationInitialized = true;
    return;
  }

  var deltaT = this.currentGyroMeasurement.timestampS -
      this.previousGyroMeasurement.timestampS;

  // Convert gyro rotation vector to a quaternion delta.
  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
  this.gyroIntegralQ.multiply(gyroDeltaQ);

  // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
  this.filterQ.copy(this.previousFilterQ);
  this.filterQ.multiply(gyroDeltaQ);

  // Calculate the delta between the current estimated gravity and the real
  // gravity vector from accelerometer.
  var invFilterQ = new THREE.Quaternion();
  invFilterQ.copy(this.filterQ);
  invFilterQ.inverse();

  this.estimatedGravity.set(0, 0, -1);
  this.estimatedGravity.applyQuaternion(invFilterQ);
  this.estimatedGravity.normalize();

  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
  this.measuredGravity.normalize();

  // Compare estimated gravity with measured gravity, get the delta quaternion
  // between the two.
  var deltaQ = new THREE.Quaternion();
  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
  deltaQ.inverse();

  if (DEBUG) {
    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
                THREE.Math.radToDeg(Util.getQuaternionAngle(deltaQ)),
                (this.estimatedGravity.x).toFixed(1),
                (this.estimatedGravity.y).toFixed(1),
                (this.estimatedGravity.z).toFixed(1),
                (this.measuredGravity.x).toFixed(1),
                (this.measuredGravity.y).toFixed(1),
                (this.measuredGravity.z).toFixed(1));
  }

  // Calculate the SLERP target: current orientation plus the measured-estimated
  // quaternion delta.
  var targetQ = new THREE.Quaternion();
  targetQ.copy(this.filterQ);
  targetQ.multiply(deltaQ);

  // SLERP factor: 0 is pure gyro, 1 is pure accel.
  this.filterQ.slerp(targetQ, 1 - this.kFilter);

  this.previousFilterQ.copy(this.filterQ);
};

ComplementaryFilter.prototype.getOrientation = function() {
  return this.filterQ;
};

ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
  var normAccel = new THREE.Vector3();
  normAccel.copy(accel);
  normAccel.normalize();
  var quat = new THREE.Quaternion();
  quat.setFromUnitVectors(new THREE.Vector3(0, 0, -1), normAccel);
  quat.inverse();
  return quat;
};

ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
  // Extract axis and angle from the gyroscope data.
  var quat = new THREE.Quaternion();
  var axis = new THREE.Vector3();
  axis.copy(gyro);
  axis.normalize();
  quat.setFromAxisAngle(axis, gyro.length() * dt);
  return quat;
};


module.exports = ComplementaryFilter;

},{"./sensor-sample.js":8,"./three-math.js":9,"./util.js":11}],4:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;

var ComplementaryFilter = _dereq_('./complementary-filter.js');
var PosePredictor = _dereq_('./pose-predictor.js');
var TouchPanner = _dereq_('./touch-panner.js');
var THREE = _dereq_('./three-math.js');
var Util = _dereq_('./util.js');

/**
 * The positional sensor, implemented using DeviceMotion APIs.
 */
function FusionPositionSensorVRDevice() {
  this.deviceId = 'webvr-polyfill:fused';
  this.deviceName = 'VR Position Device (webvr-polyfill:fused)';

  this.accelerometer = new THREE.Vector3();
  this.gyroscope = new THREE.Vector3();

  window.addEventListener('devicemotion', this.onDeviceMotionChange_.bind(this));
  window.addEventListener('orientationchange', this.onScreenOrientationChange_.bind(this));

  this.filter = new ComplementaryFilter(WebVRConfig.K_FILTER || 0.98);
  this.posePredictor = new PosePredictor(WebVRConfig.PREDICTION_TIME_S || 0.040);
  this.touchPanner = new TouchPanner();

  this.filterToWorldQ = new THREE.Quaternion();

  // Set the filter to world transform, depending on OS.
  if (Util.isIOS()) {
    this.filterToWorldQ.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI/2);
  } else {
    this.filterToWorldQ.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2);
  }

  this.worldToScreenQ = new THREE.Quaternion();
  this.setScreenTransform_();

  // Keep track of a reset transform for resetSensor.
  this.resetQ = new THREE.Quaternion();

  this.isFirefoxAndroid = Util.isFirefoxAndroid();
  this.isIOS = Util.isIOS();
}
FusionPositionSensorVRDevice.prototype = new PositionSensorVRDevice();

/**
 * Returns {orientation: {x,y,z,w}, position: null}.
 * Position is not supported since we can't do 6DOF.
 */
FusionPositionSensorVRDevice.prototype.getState = function() {
  return {
    hasOrientation: true,
    orientation: this.getOrientation(),
    hasPosition: false,
    position: null
  }
};

FusionPositionSensorVRDevice.prototype.getOrientation = function() {
  // Convert from filter space to the the same system used by the
  // deviceorientation event.
  var orientation = this.filter.getOrientation();

  // Predict orientation.
  this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);

  // Convert to THREE coordinate system: -Z forward, Y up, X right.
  var out = new THREE.Quaternion();
  out.copy(this.filterToWorldQ);
  out.multiply(this.resetQ);
  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
    out.multiply(this.touchPanner.getOrientation());
  }
  out.multiply(this.predictedQ);
  out.multiply(this.worldToScreenQ);

  // Handle the yaw-only case.
  if (WebVRConfig.YAW_ONLY) {
    // Make a quaternion that only turns around the Y-axis.
    out.x = 0;
    out.z = 0;
    out.normalize();
  }
  return out;
};

FusionPositionSensorVRDevice.prototype.resetSensor = function() {
  var euler = new THREE.Euler();
  euler.setFromQuaternion(this.filter.getOrientation());
  var yaw = euler.y;
  console.log('resetSensor with yaw: %f', yaw);
  this.resetQ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -yaw);
  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
    this.touchPanner.resetSensor();
  }
};

FusionPositionSensorVRDevice.prototype.onDeviceMotionChange_ = function(deviceMotion) {
  var accGravity = deviceMotion.accelerationIncludingGravity;
  var rotRate = deviceMotion.rotationRate;
  var timestampS = deviceMotion.timeStamp / 1000;

  // Firefox Android timeStamp returns one thousandth of a millisecond.
  if (this.isFirefoxAndroid) {
    timestampS /= 1000;
  }

  var deltaS = timestampS - this.previousTimestampS;
  if (deltaS <= Util.MIN_TIMESTEP || deltaS > Util.MAX_TIMESTEP) {
    console.warn('Invalid timestamps detected. Time step between successive ' +
                 'gyroscope sensor samples is very small or not monotonic');
    this.previousTimestampS = timestampS;
    return;
  }
  this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
  this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);

  // With iOS and Firefox Android, rotationRate is reported in degrees,
  // so we first convert to radians.
  if (this.isIOS || this.isFirefoxAndroid) {
    this.gyroscope.multiplyScalar(Math.PI / 180);
  }

  this.filter.addAccelMeasurement(this.accelerometer, timestampS);
  this.filter.addGyroMeasurement(this.gyroscope, timestampS);

  this.previousTimestampS = timestampS;
};

FusionPositionSensorVRDevice.prototype.onScreenOrientationChange_ =
    function(screenOrientation) {
  this.setScreenTransform_();
};

FusionPositionSensorVRDevice.prototype.setScreenTransform_ = function() {
  this.worldToScreenQ.set(0, 0, 0, 1);
  switch (window.orientation) {
    case 0:
      break;
    case 90:
      this.worldToScreenQ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -Math.PI/2);
      break;
    case -90:
      this.worldToScreenQ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI/2);
      break;
    case 180:
      // TODO.
      break;
  }
};


module.exports = FusionPositionSensorVRDevice;

},{"./base.js":1,"./complementary-filter.js":3,"./pose-predictor.js":7,"./three-math.js":9,"./touch-panner.js":10,"./util.js":11}],5:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var WebVRPolyfill = _dereq_('./webvr-polyfill.js');

// Initialize a WebVRConfig just in case.
window.WebVRConfig = window.WebVRConfig || {};
new WebVRPolyfill();

},{"./webvr-polyfill.js":12}],6:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;
var THREE = _dereq_('./three-math.js');
var Util = _dereq_('./util.js');

// How much to rotate per key stroke.
var KEY_SPEED = 0.15;
var KEY_ANIMATION_DURATION = 80;

// How much to rotate for mouse events.
var MOUSE_SPEED_X = 0.5;
var MOUSE_SPEED_Y = 0.3;

/**
 * A virtual position sensor, implemented using keyboard and
 * mouse APIs. This is designed as for desktops/laptops where no Device*
 * events work.
 */
function MouseKeyboardPositionSensorVRDevice() {
  this.deviceId = 'webvr-polyfill:mouse-keyboard';
  this.deviceName = 'VR Position Device (webvr-polyfill:mouse-keyboard)';

  // Attach to mouse and keyboard events.
  window.addEventListener('keydown', this.onKeyDown_.bind(this));
  window.addEventListener('mousemove', this.onMouseMove_.bind(this));
  window.addEventListener('mousedown', this.onMouseDown_.bind(this));
  window.addEventListener('mouseup', this.onMouseUp_.bind(this));

  this.phi = 0;
  this.theta = 0;

  // Variables for keyboard-based rotation animation.
  this.targetAngle = null;

  // State variables for calculations.
  this.euler = new THREE.Euler();
  this.orientation = new THREE.Quaternion();

  // Variables for mouse-based rotation.
  this.rotateStart = new THREE.Vector2();
  this.rotateEnd = new THREE.Vector2();
  this.rotateDelta = new THREE.Vector2();
}
MouseKeyboardPositionSensorVRDevice.prototype = new PositionSensorVRDevice();

/**
 * Returns {orientation: {x,y,z,w}, position: null}.
 * Position is not supported for parity with other PositionSensors.
 */
MouseKeyboardPositionSensorVRDevice.prototype.getState = function() {
  this.euler.set(this.phi, this.theta, 0, 'YXZ');
  this.orientation.setFromEuler(this.euler);

  return {
    hasOrientation: true,
    orientation: this.orientation,
    hasPosition: false,
    position: null
  }
};

MouseKeyboardPositionSensorVRDevice.prototype.onKeyDown_ = function(e) {
  // Track WASD and arrow keys.
  if (e.keyCode == 38) { // Up key.
    this.animatePhi_(this.phi + KEY_SPEED);
  } else if (e.keyCode == 39) { // Right key.
    this.animateTheta_(this.theta - KEY_SPEED);
  } else if (e.keyCode == 40) { // Down key.
    this.animatePhi_(this.phi - KEY_SPEED);
  } else if (e.keyCode == 37) { // Left key.
    this.animateTheta_(this.theta + KEY_SPEED);
  }
};

MouseKeyboardPositionSensorVRDevice.prototype.animateTheta_ = function(targetAngle) {
  this.animateKeyTransitions_('theta', targetAngle);
};

MouseKeyboardPositionSensorVRDevice.prototype.animatePhi_ = function(targetAngle) {
  // Prevent looking too far up or down.
  targetAngle = Util.clamp(targetAngle, -Math.PI/2, Math.PI/2);
  this.animateKeyTransitions_('phi', targetAngle);
};

/**
 * Start an animation to transition an angle from one value to another.
 */
MouseKeyboardPositionSensorVRDevice.prototype.animateKeyTransitions_ = function(angleName, targetAngle) {
  // If an animation is currently running, cancel it.
  if (this.angleAnimation) {
    clearInterval(this.angleAnimation);
  }
  var startAngle = this[angleName];
  var startTime = new Date();
  // Set up an interval timer to perform the animation.
  this.angleAnimation = setInterval(function() {
    // Once we're finished the animation, we're done.
    var elapsed = new Date() - startTime;
    if (elapsed >= KEY_ANIMATION_DURATION) {
      this[angleName] = targetAngle;
      clearInterval(this.angleAnimation);
      return;
    }
    // Linearly interpolate the angle some amount.
    var percent = elapsed / KEY_ANIMATION_DURATION;
    this[angleName] = startAngle + (targetAngle - startAngle) * percent;
  }.bind(this), 1000/60);
};

MouseKeyboardPositionSensorVRDevice.prototype.onMouseDown_ = function(e) {
  this.rotateStart.set(e.clientX, e.clientY);
  this.isDragging = true;
};

// Very similar to https://gist.github.com/mrflix/8351020
MouseKeyboardPositionSensorVRDevice.prototype.onMouseMove_ = function(e) {
  if (!this.isDragging && !this.isPointerLocked_()) {
    return;
  }
  // Support pointer lock API.
  if (this.isPointerLocked_()) {
    var movementX = e.movementX || e.mozMovementX || 0;
    var movementY = e.movementY || e.mozMovementY || 0;
    this.rotateEnd.set(this.rotateStart.x - movementX, this.rotateStart.y - movementY);
  } else {
    this.rotateEnd.set(e.clientX, e.clientY);
  }
  // Calculate how much we moved in mouse space.
  this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
  this.rotateStart.copy(this.rotateEnd);

  // Keep track of the cumulative euler angles.
  var element = document.body;
  this.phi += 2 * Math.PI * this.rotateDelta.y / element.clientHeight * MOUSE_SPEED_Y;
  this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * MOUSE_SPEED_X;

  // Prevent looking too far up or down.
  this.phi = Util.clamp(this.phi, -Math.PI/2, Math.PI/2);
};

MouseKeyboardPositionSensorVRDevice.prototype.onMouseUp_ = function(e) {
  this.isDragging = false;
};

MouseKeyboardPositionSensorVRDevice.prototype.isPointerLocked_ = function() {
  var el = document.pointerLockElement || document.mozPointerLockElement ||
      document.webkitPointerLockElement;
  return el !== undefined;
};

MouseKeyboardPositionSensorVRDevice.prototype.resetSensor = function() {
  console.error('Not implemented yet.');
};

module.exports = MouseKeyboardPositionSensorVRDevice;

},{"./base.js":1,"./three-math.js":9,"./util.js":11}],7:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var THREE = _dereq_('./three-math.js');

var DEBUG = false;

/**
 * Given an orientation and the gyroscope data, predicts the future orientation
 * of the head. This makes rendering appear faster.
 *
 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
 *
 * @param {Number} predictionTimeS time from head movement to the appearance of
 * the corresponding image.
 */
function PosePredictor(predictionTimeS) {
  this.predictionTimeS = predictionTimeS;

  // The quaternion corresponding to the previous state.
  this.previousQ = new THREE.Quaternion();
  // Previous time a prediction occurred.
  this.previousTimestampS = null;

  // The delta quaternion that adjusts the current pose.
  this.deltaQ = new THREE.Quaternion();
  // The output quaternion.
  this.outQ = new THREE.Quaternion();
}

PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
  if (!this.previousTimestampS) {
    this.previousQ.copy(currentQ);
    this.previousTimestampS = timestampS;
    return currentQ;
  }

  // Calculate axis and angle based on gyroscope rotation rate data.
  var axis = new THREE.Vector3();
  axis.copy(gyro);
  axis.normalize();

  var angularSpeed = gyro.length();

  // If we're rotating slowly, don't do prediction.
  if (angularSpeed < THREE.Math.degToRad(20)) {
    if (DEBUG) {
      console.log('Moving slowly, at %s deg/s: no prediction',
                  THREE.Math.radToDeg(angularSpeed).toFixed(1));
    }
    this.outQ.copy(currentQ);
    this.previousQ.copy(currentQ);
    return this.outQ;
  }

  // Get the predicted angle based on the time delta and latency.
  var deltaT = timestampS - this.previousTimestampS;
  var predictAngle = angularSpeed * this.predictionTimeS;

  this.deltaQ.setFromAxisAngle(axis, predictAngle);
  this.outQ.copy(this.previousQ);
  this.outQ.multiply(this.deltaQ);

  this.previousQ.copy(currentQ);

  return this.outQ;
};


module.exports = PosePredictor;

},{"./three-math.js":9}],8:[function(_dereq_,module,exports){
function SensorSample(sample, timestampS) {
  this.set(sample, timestampS);
};

SensorSample.prototype.set = function(sample, timestampS) {
  this.sample = sample;
  this.timestampS = timestampS;
};

SensorSample.prototype.copy = function(sensorSample) {
  this.set(sensorSample.sample, sensorSample.timestampS);
};

module.exports = SensorSample;

},{}],9:[function(_dereq_,module,exports){
/*
 * A subset of THREE.js, providing mostly quaternion and euler-related
 * operations, manually lifted from
 * https://github.com/mrdoob/three.js/tree/master/src/math, as of 9c30286b38df039fca389989ff06ea1c15d6bad1
 */

// Only use if the real THREE is not provided.
var THREE = window.THREE || {};

// If some piece of THREE is missing, fill it in here.
if (!THREE.Quaternion || !THREE.Vector3 || !THREE.Vector2 || !THREE.Euler || !THREE.Math) {
console.log('No THREE.js found.');


/*** START Quaternion ***/

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	_x: 0,_y: 0, _z: 0, _w: 0,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		if ( euler.order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function ( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			this.normalize();

			return this;

		}

	}(),

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Quaternion( this._x, this._y, this._z, this._w );

	}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}

/*** END Quaternion ***/
/*** START Vector2 ***/
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;
	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

	    if ( offset === undefined ) offset = 0;

	    index = index * attribute.itemSize + offset;

	    this.x = attribute.array[ index ];
	    this.y = attribute.array[ index + 1 ];

	    return this;

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

};
/*** END Vector2 ***/
/*** START Vector3 ***/

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function ( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function ( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function ( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function ( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

		return this.setFromMatrixScale( m );
	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

	    if ( offset === undefined ) offset = 0;

	    index = index * attribute.itemSize + offset;

	    this.x = attribute.array[ index ];
	    this.y = attribute.array[ index + 1 ];
	    this.z = attribute.array[ index + 2 ];

	    return this;

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

};
/*** END Vector3 ***/
/*** START Euler ***/
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = THREE.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix;

		return function ( q, order, update ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();
			matrix.makeRotationFromQuaternion( q );
			this.setFromRotationMatrix( matrix, order, update );

			return this;

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._order ];

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new THREE.Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Euler( this._x, this._y, this._z, this._order );

	}

};
/*** END Euler ***/
/*** START Math ***/
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

					uuid[ i ] = '-';

				} else if ( i == 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}
			}

			return uuid.join( '' );

		};

	}(),

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return Math.floor( this.randFloat( low, high ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function () {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function () {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}(),

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	nextPowerOfTwo: function ( value ) {

		value --;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value ++;

		return value;
	}

};

/*** END Math ***/

}

module.exports = THREE;

},{}],10:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var THREE = _dereq_('./three-math.js');
var Util = _dereq_('./util.js');

var ROTATE_SPEED = 0.5;
/**
 * Provides a quaternion responsible for pre-panning the scene before further
 * transformations due to device sensors.
 */
function TouchPanner() {
  window.addEventListener('touchstart', this.onTouchStart_.bind(this));
  window.addEventListener('touchmove', this.onTouchMove_.bind(this));
  window.addEventListener('touchend', this.onTouchEnd_.bind(this));

  this.isTouching = false;
  this.rotateStart = new THREE.Vector2();
  this.rotateEnd = new THREE.Vector2();
  this.rotateDelta = new THREE.Vector2();

  this.theta = 0;
  this.orientation = new THREE.Quaternion();
}

TouchPanner.prototype.getOrientation = function() {
  this.orientation.setFromEuler(new THREE.Euler(0, 0, this.theta));
  return this.orientation;
};

TouchPanner.prototype.resetSensor = function() {
  this.theta = 0;
};

TouchPanner.prototype.onTouchStart_ = function(e) {
  // Only respond if there is exactly one touch.
  if (e.touches.length != 1) {
    return;
  }
  this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);
  this.isTouching = true;
};

TouchPanner.prototype.onTouchMove_ = function(e) {
  if (!this.isTouching) {
    return;
  }
  this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY);
  this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
  this.rotateStart.copy(this.rotateEnd);

  // On iOS, direction is inverted.
  if (Util.isIOS()) {
    this.rotateDelta.x *= -1;
  }

  var element = document.body;
  this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * ROTATE_SPEED;
};

TouchPanner.prototype.onTouchEnd_ = function(e) {
  this.isTouching = false;
};

module.exports = TouchPanner;

},{"./three-math.js":9,"./util.js":11}],11:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Util = window.Util || {};

Util.MIN_TIMESTEP = 0.001;
Util.MAX_TIMESTEP = 1;

Util.clamp = function(value, min, max) {
  return Math.min(Math.max(min, value), max);
};

Util.isIOS = function() {
  return /iPad|iPhone|iPod/.test(navigator.platform);
};

Util.isFirefoxAndroid = function() {
  return navigator.userAgent.indexOf('Firefox') !== -1 && navigator.userAgent.indexOf('Android') !== -1;
}

// Helper method to validate the time steps of sensor timestamps.
Util.isTimestampDeltaValid = function(timestampDeltaS) {
  if (isNaN(timestampDeltaS)) {
    return false;
  }
  if (timestampDeltaS <= Util.MIN_TIMESTEP) {
    return false;
  }
  if (timestampDeltaS > Util.MAX_TIMESTEP) {
    return false;
  }
  return true;
}

module.exports = Util;

},{}],12:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CardboardHMDVRDevice = _dereq_('./cardboard-hmd-vr-device.js');
//var OrientationPositionSensorVRDevice = require('./orientation-position-sensor-vr-device.js');
var FusionPositionSensorVRDevice = _dereq_('./fusion-position-sensor-vr-device.js');
var MouseKeyboardPositionSensorVRDevice = _dereq_('./mouse-keyboard-position-sensor-vr-device.js');
// Uncomment to add positional tracking via webcam.
//var WebcamPositionSensorVRDevice = require('./webcam-position-sensor-vr-device.js');
var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;
var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;

function WebVRPolyfill() {
  this.devices = [];

  if (!this.isWebVRAvailable()) {
    this.enablePolyfill();
  }
}

WebVRPolyfill.prototype.isWebVRAvailable = function() {
  return ('getVRDevices' in navigator) || ('mozGetVRDevices' in navigator);
};


WebVRPolyfill.prototype.enablePolyfill = function() {
  // Initialize our virtual VR devices.
  if (this.isCardboardCompatible()) {
    this.devices.push(new CardboardHMDVRDevice());
  }

  // Polyfill using the right position sensor.
  if (this.isMobile()) {
    //this.devices.push(new OrientationPositionSensorVRDevice());
    this.devices.push(new FusionPositionSensorVRDevice());
  } else {
    if (!WebVRConfig.MOUSE_KEYBOARD_CONTROLS_DISABLED) {
      this.devices.push(new MouseKeyboardPositionSensorVRDevice());
    }
    // Uncomment to add positional tracking via webcam.
    //this.devices.push(new WebcamPositionSensorVRDevice());
  }

  // Provide navigator.getVRDevices.
  navigator.getVRDevices = this.getVRDevices.bind(this);

  // Provide the CardboardHMDVRDevice and PositionSensorVRDevice objects.
  window.HMDVRDevice = HMDVRDevice;
  window.PositionSensorVRDevice = PositionSensorVRDevice;
};

WebVRPolyfill.prototype.getVRDevices = function() {
  var devices = this.devices;
  return new Promise(function(resolve, reject) {
    try {
      resolve(devices);
    } catch (e) {
      reject(e);
    }
  });
};

/**
 * Determine if a device is mobile.
 */
WebVRPolyfill.prototype.isMobile = function() {
  return /Android/i.test(navigator.userAgent) ||
      /iPhone|iPad|iPod/i.test(navigator.userAgent);
};

WebVRPolyfill.prototype.isCardboardCompatible = function() {
  // For now, support all iOS and Android devices.
  // Also enable the WebVRConfig.FORCE_VR flag for debugging.
  return this.isMobile() || WebVRConfig.FORCE_ENABLE_VR;
};

module.exports = WebVRPolyfill;

},{"./base.js":1,"./cardboard-hmd-vr-device.js":2,"./fusion-position-sensor-vr-device.js":4,"./mouse-keyboard-position-sensor-vr-device.js":6}]},{},[5]);

/**
 * @license
 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern -o ./lodash.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.10.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      ARY_FLAG = 128,
      REARG_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

  /**
   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
   */
  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect hexadecimal string values. */
  var reHasHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^\d+$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled regexes. */
  var regexpEscapes = {
    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

  /** Detect free variable `self`. */
  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it's the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsNull = value === null,
          valIsUndef = value === undefined,
          valIsReflexive = value === value;

      var othIsNull = other === null,
          othIsUndef = other === undefined,
          othIsReflexive = other === other;

      if ((value > other && !othIsNull) || !valIsReflexive ||
          (valIsNull && !othIsUndef && othIsReflexive) ||
          (valIsUndef && othIsReflexive)) {
        return 1;
      }
      if ((value < other && !valIsNull) || !othIsReflexive ||
          (othIsNull && !valIsUndef && valIsReflexive) ||
          (othIsUndef && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Function} predicate The function invoked per iteration.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromRight) {
    var length = array.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it's not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByOrder` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
   * a value is sorted in ascending order if its corresponding order is "asc", and
   * descending if "desc".
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * ((order === 'asc' || order === true) ? 1 : -1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @param {string} leadingChar The capture group for a leading character.
   * @param {string} whitespaceChar The capture group for a whitespace character.
   * @returns {string} Returns the escaped character.
   */
  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
    if (leadingChar) {
      chr = regexpEscapes[chr];
    } else if (whitespaceChar) {
      chr = stringEscapes[chr];
    }
    return '\\' + chr;
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = context.ArrayBuffer,
        clearTimeout = context.clearTimeout,
        parseFloat = context.parseFloat,
        pow = Math.pow,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = getNative(context, 'Set'),
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = context.Uint8Array,
        WeakMap = getNative(context, 'WeakMap');

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeCreate = getNative(Object, 'create'),
        nativeFloor = Math.floor,
        nativeIsArray = getNative(Array, 'isArray'),
        nativeIsFinite = context.isFinite,
        nativeKeys = getNative(Object, 'keys'),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = getNative(Date, 'now'),
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /**
     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
     * of an array-like value.
     */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that retrieve a single value or may return a
     * primitive value will automatically end the chain returning the unwrapped
     * value. Explicit chaining may be enabled using `_.chain`. The execution of
     * chained methods is lazy, that is, execution is deferred until `_#value`
     * is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization strategy which merge iteratee calls; this can help
     * to avoid the creation of intermediate data structures and greatly reduce the
     * number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
     * `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
     * `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(total, n) {
     *   return total + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = arrayCopy(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = arrayCopy(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = arrayCopy(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Sets `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a new array joining `array` with `other`.
     *
     * @private
     * @param {Array} array The array to join.
     * @param {Array} other The other array to join.
     * @returns {Array} Returns the new concatenated array.
     */
    function arrayConcat(array, other) {
      var index = -1,
          length = array.length,
          othIndex = -1,
          othLength = other.length,
          result = Array(length + othLength);

      while (++index < length) {
        result[index] = array[index];
      }
      while (++othIndex < othLength) {
        result[index++] = other[othIndex];
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
     * with one argument: (value).
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function arrayExtremum(array, iteratee, comparator, exValue) {
      var index = -1,
          length = array.length,
          computed = exValue,
          result = computed;

      while (++index < length) {
        var value = array[index],
            current = +iteratee(value);

        if (comparator(current, computed)) {
          computed = current;
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.sum` for arrays without support for callback
     * shorthands and `this` binding..
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function arraySum(array, iteratee) {
      var length = array.length,
          result = 0;

      while (length--) {
        result += +iteratee(array[length]) || 0;
      }
      return result;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This function is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (objectValue === undefined || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * A specialized version of `_.assign` for customizing assigned values without
     * support for argument juggling, multiple sources, and `this` binding `customizer`
     * functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     */
    function assignWith(object, source, customizer) {
      var index = -1,
          props = keys(source),
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? (result !== value) : (value === value)) ||
            (value === undefined && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return source == null
        ? object
        : baseCopy(source, keys(source), object);
    }

    /**
     * The base implementation of `_.at` without support for string collections
     * and individual key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} props The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          isNil = collection == null,
          isArr = !isNil && isArrayLike(collection),
          length = isArr ? collection.length : 0,
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = isNil ? undefined : collection[key];
        }
      }
      return result;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, props, object) {
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return thisArg === undefined
          ? func
          : bindCallback(func, thisArg, argCount);
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return thisArg === undefined
        ? property(func)
        : baseMatchesProperty(func, thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseAssign(result, value);
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return its corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          object.prototype = prototype;
          var result = new object;
          object.prototype = undefined;
        }
        return result || {};
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The arguments provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf === baseIndexOf,
          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value, 0) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(collection, iteratee, comparator, exValue) {
      var computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = +iteratee(value, index, collection);
        if (comparator(current, computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end >>> 0);
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, result) {
      result || (result = []);

      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index];
        if (isObjectLike(value) && isArrayLike(value) &&
            (isStrict || isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, isDeep, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `get` without support for string paths
     * and default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path of the property to get.
     * @param {string} [pathKey] The key representation of path.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path, pathKey) {
      if (object == null) {
        return;
      }
      if (pathKey !== undefined && pathKey in toObject(object)) {
        path = [pathKey];
      }
      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      if (!isLoose) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
        }
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} matchData The propery names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = toObject(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];

        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value && (value !== undefined || (key in toObject(object)));
        };
      }
      return function(object) {
        return baseIsMatch(object, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      var isArr = isArray(path),
          isCommon = isKey(path) && isStrictComparable(srcValue),
          pathKey = (path + '');

      path = toPath(path);
      return function(object) {
        if (object == null) {
          return false;
        }
        var key = pathKey;
        object = toObject(object);
        if ((isArr || !isCommon) && !(key in object)) {
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          if (object == null) {
            return false;
          }
          key = last(path);
          object = toObject(object);
        }
        return object[key] === srcValue
          ? (srcValue !== undefined || (key in object))
          : baseIsEqual(srcValue, object[key], undefined, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns `object`.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
          props = isSrcArr ? undefined : keys(source);

      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        else {
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

          if (isCommon) {
            result = srcValue;
          }
          if ((result !== undefined || (isSrcArr && !(key in object))) &&
              (isCommon || (result === result ? (result !== value) : (value === value)))) {
            object[key] = result;
          }
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = result === undefined;

      if (isCommon) {
        result = srcValue;
        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (isArrayLike(value) ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? (result !== value) : (value === value)) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      var pathKey = (path + '');
      path = toPath(path);
      return function(object) {
        return baseGet(object, path, pathKey);
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments and capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0;
      while (length--) {
        var index = indexes[length];
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + nativeFloor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands and `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define
     * the sort order of `array` and replaces criteria objects with their
     * corresponding values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sortByOrder` without param guards.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseSortByOrder(collection, iteratees, orders) {
      var callback = getCallback(),
          index = -1;

      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

      var result = baseMap(collection, function(value) {
        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.sum` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(collection, iteratee) {
      var result = 0;
      baseEach(collection, function(value, index, collection) {
        result += +iteratee(value, index, collection) || 0;
      });
      return result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf === baseIndexOf,
          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed, 0) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
     * and `_.takeWhile` without support for callback shorthands and `this` binding.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var action = actions[index];
        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsUndef = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            isDef = computed !== undefined,
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsNull) {
          setLow = isReflexive && isDef && (retHighest || computed != null);
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || isDef);
        } else if (computed == null) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (thisArg === undefined) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      var result = new ArrayBuffer(buffer.byteLength),
          view = new Uint8Array(result);

      view.set(new Uint8Array(buffer));
      return result;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(leftLength + argsLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return restParam(function(object, sources) {
        var index = -1,
            length = object == null ? 0 : sources.length,
            customizer = length > 2 ? sources[length - 2] : undefined,
            guard = length > 2 ? sources[2] : undefined,
            thisArg = length > 1 ? sources[length - 1] : undefined;

        if (typeof customizer == 'function') {
          customizer = bindCallback(customizer, thisArg, 5);
          length -= 2;
        } else {
          customizer = typeof thisArg == 'function' ? thisArg : undefined;
          length -= (customizer ? 1 : 0);
        }
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        var length = collection ? getLength(collection) : 0;
        if (!isLength(length)) {
          return eachFunc(collection, iteratee);
        }
        var index = fromRight ? length : -1,
            iterable = toObject(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var iterable = toObject(object),
            props = keysFunc(object),
            length = props.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length)) {
          var key = props[index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    function createCache(values) {
      return (nativeCreate && Set) ? new SetCache(values) : null;
    }

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors.
        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a `_.curry` or `_.curryRight` function.
     *
     * @private
     * @param {boolean} flag The curry bit flag.
     * @returns {Function} Returns the new curry function.
     */
    function createCurry(flag) {
      function curryFunc(func, arity, guard) {
        if (guard && isIterateeCall(func, arity, guard)) {
          arity = undefined;
        }
        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
        result.placeholder = curryFunc.placeholder;
        return result;
      }
      return curryFunc;
    }

    /**
     * Creates a `_.defaults` or `_.defaultsDeep` function.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Function} Returns the new defaults function.
     */
    function createDefaults(assigner, customizer) {
      return restParam(function(args) {
        var object = args[0];
        if (object == null) {
          return object;
        }
        args.push(customizer);
        return assigner.apply(undefined, args);
      });
    }

    /**
     * Creates a `_.max` or `_.min` function.
     *
     * @private
     * @param {Function} comparator The function used to compare values.
     * @param {*} exValue The initial extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(comparator, exValue) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = undefined;
        }
        iteratee = getCallback(iteratee, thisArg, 3);
        if (iteratee.length == 1) {
          collection = isArray(collection) ? collection : toIterable(collection);
          var result = arrayExtremum(collection, iteratee, comparator, exValue);
          if (!(collection.length && result === exValue)) {
            return result;
          }
        }
        return baseExtremum(collection, iteratee, comparator, exValue);
      };
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFind(eachFunc, fromRight) {
      return function(collection, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        if (isArray(collection)) {
          var index = baseFindIndex(collection, predicate, fromRight);
          return index > -1 ? collection[index] : undefined;
        }
        return baseFind(collection, predicate, eachFunc);
      };
    }

    /**
     * Creates a `_.findIndex` or `_.findLastIndex` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new find function.
     */
    function createFindIndex(fromRight) {
      return function(array, predicate, thisArg) {
        if (!(array && array.length)) {
          return -1;
        }
        predicate = getCallback(predicate, thisArg, 3);
        return baseFindIndex(array, predicate, fromRight);
      };
    }

    /**
     * Creates a `_.findKey` or `_.findLastKey` function.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new find function.
     */
    function createFindKey(objectFunc) {
      return function(object, predicate, thisArg) {
        predicate = getCallback(predicate, thisArg, 3);
        return baseFind(object, predicate, objectFunc, true);
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var wrapper,
            length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);

        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
            wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? -1 : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }

    /**
     * Creates a function for `_.forEach` or `_.forEachRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createForEach(arrayFunc, eachFunc) {
      return function(collection, iteratee, thisArg) {
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee)
          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
      };
    }

    /**
     * Creates a function for `_.forIn` or `_.forInRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForIn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee, keysIn);
      };
    }

    /**
     * Creates a function for `_.forOwn` or `_.forOwnRight`.
     *
     * @private
     * @param {Function} objectFunc The function to iterate over an object.
     * @returns {Function} Returns the new each function.
     */
    function createForOwn(objectFunc) {
      return function(object, iteratee, thisArg) {
        if (typeof iteratee != 'function' || thisArg !== undefined) {
          iteratee = bindCallback(iteratee, thisArg, 3);
        }
        return objectFunc(object, iteratee);
      };
    }

    /**
     * Creates a function for `_.mapKeys` or `_.mapValues`.
     *
     * @private
     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
     * @returns {Function} Returns the new map function.
     */
    function createObjectMapper(isMapKeys) {
      return function(object, iteratee, thisArg) {
        var result = {};
        iteratee = getCallback(iteratee, thisArg, 3);

        baseForOwn(object, function(value, key, object) {
          var mapped = iteratee(value, key, object);
          key = isMapKeys ? mapped : key;
          value = isMapKeys ? value : mapped;
          result[key] = value;
        });
        return result;
      };
    }

    /**
     * Creates a function for `_.padLeft` or `_.padRight`.
     *
     * @private
     * @param {boolean} [fromRight] Specify padding from the right.
     * @returns {Function} Returns the new pad function.
     */
    function createPadDir(fromRight) {
      return function(string, length, chars) {
        string = baseToString(string);
        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
      };
    }

    /**
     * Creates a `_.partial` or `_.partialRight` function.
     *
     * @private
     * @param {boolean} flag The partial bit flag.
     * @returns {Function} Returns the new partial function.
     */
    function createPartial(flag) {
      var partialFunc = restParam(function(func, partials) {
        var holders = replaceHolders(partials, partialFunc.placeholder);
        return createWrapper(func, flag, undefined, partials, holders);
      });
      return partialFunc;
    }

    /**
     * Creates a function for `_.reduce` or `_.reduceRight`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over an array.
     * @param {Function} eachFunc The function to iterate over a collection.
     * @returns {Function} Returns the new each function.
     */
    function createReduce(arrayFunc, eachFunc) {
      return function(collection, iteratee, accumulator, thisArg) {
        var initFromArray = arguments.length < 3;
        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
          Ctor = isBindKey ? undefined : createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : undefined,
                newHoldersRight = isCurry ? undefined : argsHolders,
                newPartials = isCurry ? args : undefined,
                newPartialsRight = isCurry ? undefined : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                result = createHybridWrapper.apply(undefined, newData);

            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtorWrapper(func);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the padding required for `string` based on the given `length`.
     * The `chars` string is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPadding(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        precision = precision === undefined ? 0 : (+precision || 0);
        if (precision) {
          precision = pow(10, precision);
          return func(number * precision) / precision;
        }
        return func(number);
      };
    }

    /**
     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
     *
     * @private
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {Function} Returns the new index function.
     */
    function createSortedIndex(retHighest) {
      return function(array, value, iteratee, thisArg) {
        var callback = getCallback(iteratee);
        return (iteratee == null && callback === baseCallback)
          ? binaryIndex(array, value, retHighest)
          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
        return false;
      }
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index],
            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

        if (result !== undefined) {
          if (result) {
            continue;
          }
          return false;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isLoose) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
              })) {
            return false;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            : object == +other;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isLoose] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isLoose) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var skipCtor = isLoose;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key],
            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

        // Recursively compare objects (susceptible to call stack limits).
        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
          return false;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (!skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = array ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');

    /**
     * Gets the propery names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = pairs(object),
          length = result.length;

      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object == null ? undefined : object[key];
      return isNative(value) ? value : undefined;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Invokes the method at `path` on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function invokePath(object, path, args) {
      if (object != null && !isKey(path, object)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        path = last(path);
      }
      var func = object == null ? object : object[path];
      return func == null ? undefined : func.apply(object, args);
    }

    /**
     * Checks if `value` is array-like.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value));
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        var other = object[index];
        return value === value ? (value === other) : (other !== other);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      var type = typeof value;
      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
        return true;
      }
      if (isArray(value)) {
        return false;
      }
      var result = !reIsDeepProp.test(value);
      return result || (object != null && value in toObject(object));
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < ARY_FLAG;

      var isCombo =
        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function mergeDefaults(objectValue, sourceValue) {
      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties specified
     * by `props`.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` which picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length;

      var allowIndexes = !!length && isLength(length) &&
        (isArray(object) || isArguments(object));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isArrayLike(value)) {
        return values(value);
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to property path array if it's not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array} Returns the property path array.
     */
    function toPath(value) {
      if (isArray(value)) {
        return value;
      }
      var result = [];
      baseToString(value).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(nativeFloor(size) || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array of unique `array` values not included in the other
     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    var difference = restParam(function(array, values) {
      return (isObjectLike(array) && isArrayLike(array))
        ? baseDifference(array, baseFlatten(values, false, true))
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8], '*', 1, 2);
     * // => [4, '*', 8]
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    var findIndex = createFindIndex();

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 2
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    var findLastIndex = createFindIndex(true);

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it's only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]]
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4]
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4]
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the offset
     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
     * performs a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
      } else if (fromIndex) {
        var index = binaryIndex(array, value);
        if (index < length &&
            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
          return index;
        }
        return -1;
      }
      return baseIndexOf(array, value, fromIndex || 0);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values that are included in all of the provided
     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    var intersection = restParam(function(arrays) {
      var othLength = arrays.length,
          othIndex = othLength,
          caches = Array(length),
          indexOf = getIndexOf(),
          isCommon = indexOf === baseIndexOf,
          result = [];

      while (othIndex--) {
        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
      }
      var array = arrays[0],
          index = -1,
          length = array ? array.length : 0,
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
          var othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        if (value === value ? (value === other) : (other !== other)) {
          return index;
        }
        return -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var args = arguments,
          array = args[0];

      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = args.length;

      while (++index < length) {
        var fromIndex = 0,
            value = args[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    var pullAt = restParam(function(array, indexes) {
      indexes = baseFlatten(indexes);

      var result = baseAt(array, indexes);
      basePullAt(array, indexes.sort(baseCompareAscending));
      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it's invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    var sortedIndex = createSortedIndex();

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    var sortedLastIndex = createSortedIndex(true);

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments: (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      return (array && array.length)
        ? baseWhile(array, getCallback(predicate, thisArg, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all of the provided arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    var union = restParam(function(arrays) {
      return baseUniq(baseFlatten(arrays, false, true));
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurence of each element
     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
     * for sorted arrays. If an iteratee function is provided it's invoked for
     * each element in the array to generate the criterion by which uniqueness
     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, array).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
        isSorted = false;
      }
      var callback = getCallback();
      if (!(iteratee == null && callback === baseCallback)) {
        iteratee = callback(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() === baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var index = -1,
          length = 0;

      array = arrayFilter(array, function(group) {
        if (isArrayLike(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      var result = Array(length);
      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * This method is like `_.unzip` except that it accepts an iteratee to specify
     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee] The function to combine regrouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      iteratee = bindCallback(iteratee, thisArg, 4);
      return arrayMap(result, function(group) {
        return arrayReduce(group, iteratee, undefined, true);
      });
    }

    /**
     * Creates an array excluding all provided values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    var without = restParam(function(array, values) {
      return isArrayLike(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the provided arrays.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArrayLike(array)) {
          var result = result
            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    var zip = restParam(unzip);

    /**
     * The inverse of `_.pairs`; this method returns an object composed from arrays
     * of property names and values. Provide either a single two dimensional array,
     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
     * and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject([['fred', 30], ['barney', 40]]);
     * // => { 'fred': 30, 'barney': 40 }
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /**
     * This method is like `_.zip` except that it accepts an iteratee to specify
     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
     * and invoked with four arguments: (accumulator, value, index, group).
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee] The function to combine grouped values.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
     * // => [111, 222]
     */
    var zipWith = restParam(function(arrays) {
      var length = arrays.length,
          iteratee = length > 2 ? arrays[length - 2] : undefined,
          thisArg = length > 1 ? arrays[length - 1] : undefined;

      if (length > 2 && typeof iteratee == 'function') {
        length -= 2;
      } else {
        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
        thisArg = undefined;
      }
      arrays.length = length;
      return unzipWith(arrays, iteratee, thisArg);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a new array joining a wrapped array with any additional arrays
     * and/or values.
     *
     * @name concat
     * @memberOf _
     * @category Chain
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var wrapped = _(array).concat(2, [3], [[4]]);
     *
     * console.log(wrapped.value());
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    var wrapperConcat = restParam(function(values) {
      values = baseFlatten(values);
      return this.thru(function(array) {
        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
      });
    });

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapped = wrapped.plant(other);
     *
     * otherWrapped.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;

      var interceptor = function(value) {
        return value.reverse();
      };
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(interceptor);
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
     * // => ['barney', 'pebbles']
     */
    var at = restParam(function(collection, props) {
      return baseAt(collection, baseFlatten(props));
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    var find = createFind(baseEach);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(baseEachRight, true);

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection). Iteratee functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length" property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    var forEach = createForEach(arrayEach, baseEach);

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from right to left and returns the array
     */
    var forEachRight = createForEach(arrayEachRight, baseEachRight);

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `target` is in `collection` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the offset
     * from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex, guard) {
      var length = collection ? getLength(collection) : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
        fromIndex = 0;
      } else {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `methodName` is a function it's
     * invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invoke = restParam(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          isProp = isKey(path),
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
      });
      return result;
    });

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
     * `sum`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1.2, 3.4], [2.3]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the property value of `path` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|string} path The path of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, path) {
      return map(collection, property(path));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
     * and `sortByOrder`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(total, n) {
     *   return total + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    var reduce = createReduce(arrayReduce, baseEach);

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var index = -1,
          result = toArray(collection),
          length = result.length,
          lastIndex = length - 1;

      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
      while (++index < n) {
        var rand = baseRandom(index, lastIndex),
            value = result[rand];

        result[rand] = result[index];
        result[index] = value;
      }
      result.length = n;
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      return sample(collection, POSITIVE_INFINITY);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? getLength(collection) : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments: (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
        predicate = undefined;
      }
      if (typeof predicate != 'function' || thisArg !== undefined) {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
     * (value, index|key, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      if (collection == null) {
        return [];
      }
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      var index = -1;
      iteratee = getCallback(iteratee, thisArg, 3);

      var result = baseMap(collection, function(value, key, collection) {
        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it can sort by multiple iteratees
     * or property names.
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
     *  The iteratees to sort by, specified as individual values or arrays of values.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
     *
     * _.map(_.sortByAll(users, 'user', function(chr) {
     *   return Math.floor(chr.age / 10);
     * }), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    var sortByAll = restParam(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var guard = iteratees[2];
      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
        iteratees.length = 1;
      }
      return baseSortByOrder(collection, baseFlatten(iteratees), []);
    });

    /**
     * This method is like `_.sortByAll` except that it allows specifying the
     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
     * values are sorted in ascending order. Otherwise, a value is sorted in
     * ascending order if its corresponding order is "asc", and descending if "desc".
     *
     * If a property name is provided for an iteratee the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If an object is provided for an iteratee the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {boolean[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 42 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // sort by `user` in ascending order and by `age` in descending order
     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
     */
    function sortByOrder(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (guard && isIterateeCall(iteratees, orders, guard)) {
        orders = undefined;
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseSortByOrder(collection, iteratees, orders);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = undefined;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = restParam(function(func, thisArg, partials) {
      var bitmask = BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bind.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the "length" property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    var bindAll = restParam(function(object, methodNames) {
      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    });

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = restParam(function(object, key, partials) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, bindKey.placeholder);
        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    var curry = createCurry(CURRY_FLAG);

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    var curryRight = createCurry(CURRY_RIGHT_FLAG);

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the debounced function return the result of the last
     * `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it's invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        complete(trailing, timeoutId);
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    var defer = restParam(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    var delay = restParam(function(func, wait, args) {
      return baseDelay(func, wait, args);
    });

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(_.add, square);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that runs each argument through a corresponding
     * transform function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms] The functions to transform
     * arguments, specified as individual functions or arrays of functions.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var modded = _.modArgs(function(x, y) {
     *   return [x, y];
     * }, square, doubled);
     *
     * modded(1, 2);
     * // => [1, 4]
     *
     * modded(5, 10);
     * // => [25, 20]
     */
    var modArgs = restParam(function(func, transforms) {
      transforms = baseFlatten(transforms);
      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = transforms.length;
      return restParam(function(args) {
        var index = nativeMin(args.length, length);
        while (index--) {
          args[index] = transforms[index](args[index]);
        }
        return func.apply(this, args);
      });
    });

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = createPartial(PARTIAL_FLAG);

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    var rearg = restParam(function(func, indexes) {
      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.restParam(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function restParam(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            rest = Array(length);

        while (++index < length) {
          rest[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, args[0], rest);
          case 2: return func.call(this, args[0], args[1], rest);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = rest;
        return func.apply(this, otherArgs);
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the created
     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
     *
     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/Web/JavaScript/Reference/Operators/Spread_operator).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed invocations. Provide an options object to indicate
     * that `func` should be invoked on the leading and/or trailing edge of the
     * `wait` timeout. Subsequent calls to the throttled function return the
     * result of the last `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it's
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with up to three argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      return typeof customizer == 'function'
        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3))
        : baseClone(value, isDeep);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it's invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with up to three argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      return typeof customizer == 'function'
        ? baseClone(value, true, bindCallback(customizer, thisArg, 3))
        : baseClone(value, true);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    function gt(value, other) {
      return value > other;
    }

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    function gte(value, other) {
      return value >= other;
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return isObjectLike(value) && isArrayLike(value) &&
        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return isObjectLike(value) && objToString.call(value) == dateTag;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
    }

    /**
     * Checks if `value` is empty. A value is considered empty unless it's an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !value.length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it's invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with up to
     * three arguments: (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @alias eq
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 which returns 'object' for typed array constructors.
      return isObject(value) && objToString.call(value) == funcTag;
    }

    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it's invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments: (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize value comparisons.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
      return baseIsMatch(object, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
     * which returns `true` for `undefined` and other non-numeric values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(fnToString.call(value));
      }
      return isObjectLike(value) && reIsHostCtor.test(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      var Ctor;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return isObject(value) && objToString.call(value) == regexpTag;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    function lt(value, other) {
      return value < other;
    }

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    function lte(value, other) {
      return value <= other;
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? getLength(value) : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it's invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments: (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it's invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments:
     * (objectValue, sourceValue, key, object, source).
     *
     * **Note:** This method mutates `object` and is based on
     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return _.isUndefined(value) ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(function(object, source, customizer) {
      return customizer
        ? assignWith(object, source, customizer)
        : baseAssign(object, source);
    });

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = undefined;
      }
      return properties ? baseAssign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var defaults = createDefaults(assign, assignDefaults);

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
     * // => { 'user': { 'name': 'barney', 'age': 36 } }
     *
     */
    var defaultsDeep = createDefaults(merge, mergeDefaults);

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    var findKey = createFindKey(baseForOwn);

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    var findLastKey = createFindKey(baseForOwnRight);

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    var forIn = createForIn(baseFor);

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    var forInRight = createForIn(baseForRight);

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    var forOwn = createForOwn(baseForOwn);

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    var forOwnRight = createForOwn(baseForOwnRight);

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the property value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, toPath(path), (path + ''));
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': { 'c': 3 } } };
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b.c');
     * // => true
     *
     * _.has(object, ['a', 'b', 'c']);
     * // => true
     */
    function has(object, path) {
      if (object == null) {
        return false;
      }
      var result = hasOwnProperty.call(object, path);
      if (!result && !isKey(path)) {
        path = toPath(path);
        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
        if (object == null) {
          return false;
        }
        path = last(path);
        result = hasOwnProperty.call(object, path);
      }
      return result || (isLength(object.length) && isIndex(path, object.length) &&
        (isArray(object) || isArguments(object)));
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = undefined;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      var Ctor = object == null ? undefined : object.constructor;
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
          (typeof object != 'function' && isArrayLike(object))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length;
      length = (length && isLength(length) &&
        (isArray(object) || isArguments(object)) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
          result = Array(length),
          skipIndexes = length > 0;

      while (++index < length) {
        result[index] = (index + '');
      }
      for (var key in object) {
        if (!(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * property of `object` through `iteratee`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    var mapKeys = createObjectMapper(true);

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments:
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    var mapValues = createObjectMapper();

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    var omit = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      if (typeof props[0] != 'function') {
        var props = arrayMap(baseFlatten(props), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      var predicate = bindCallback(props[0], props[1], 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    });

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      object = toObject(object);

      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it's invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    var pick = restParam(function(object, props) {
      if (object == null) {
        return {};
      }
      return typeof props[0] == 'function'
        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
        : pickByArray(object, baseFlatten(props));
    });

    /**
     * This method is like `_.get` except that if the resolved value is a function
     * it's invoked with the `this` binding of its parent object and its result
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a.b.c', 'default');
     * // => 'default'
     *
     * _.result(object, 'a.b.c', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      var result = object == null ? undefined : object[path];
      if (result === undefined) {
        if (object != null && !isKey(path, object)) {
          path = toPath(path);
          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
          result = object == null ? undefined : object[last(path)];
        }
        result = result === undefined ? defaultValue : result;
      }
      return isFunction(result) ? result.call(object) : result;
    }

    /**
     * Sets the property value of `path` on `object`. If a portion of `path`
     * does not exist it's created.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to augment.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, 'x[0].y.z', 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      if (object == null) {
        return object;
      }
      var pathKey = (path + '');
      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = path[index];
        if (isObject(nested)) {
          if (index == lastIndex) {
            nested[key] = value;
          } else if (nested[key] == null) {
            nested[key] = isIndex(path[index + 1]) ? [] : {};
          }
        }
        nested = nested[key];
      }
      return object;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments: (accumulator, value, key, object). Iteratee functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it's set to `start` with `start` then set to `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= nativeMin(start, end) && value < nativeMax(start, end);
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = undefined;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = position === undefined
        ? length
        : nativeMin(position < 0 ? 0 : (+position || 0), length);

      position -= target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
     * for more details.
     *
     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
     * to reduce XSS vectors.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, escapeRegExpChar)
        : (string || '(?:)');
    }

    /**
     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);

      chars = createPadding('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    var padLeft = createPadDir();

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    var padRight = createPadDir(true);

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
     * of `parseInt`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
      // Chrome fails to trim leading <BOM> whitespace characters.
      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      string = trim(string);
      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null
        ? 0
        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = undefined;
      }
      string = baseToString(string);
      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? (+options.length || 0) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = undefined;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = restParam(function(func, args) {
      try {
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = undefined;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function that compares the property value of `path` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred' }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, true));
    }

    /**
     * Creates a function that invokes the method at `path` on a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': _.constant(2) } } },
     *   { 'a': { 'b': { 'c': _.constant(1) } } }
     * ];
     *
     * _.map(objects, _.method('a.b.c'));
     * // => [2, 1]
     *
     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    var method = restParam(function(path, args) {
      return function(object) {
        return invokePath(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path on `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = restParam(function(object, args) {
      return function(path) {
        return invokePath(object, path, args);
      };
    });

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj ? keys(source) : undefined,
            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = arrayCopy(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      root._ = oldDash;
      return this;
    }

    /**
     * A no-operation function that returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that returns the property value at `path` on a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the property value at a given path on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return baseGet(object, toPath(path), (path + ''));
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it's
     * set to `start` with `start` then set to `0`. If `end` is less than `start`
     * a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = undefined;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = nativeFloor(n);

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} augend The first number to add.
     * @param {number} addend The second number to add.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    function add(augend, addend) {
      return (+augend || 0) + (+addend || 0);
    }

    /**
     * Calculates `n` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Calculates `n` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it's invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 }
     */
    var max = createExtremum(gt, NEGATIVE_INFINITY);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it's invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments: (value, index, collection).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 }
     */
    var min = createExtremum(lt, POSITIVE_INFINITY);

    /**
     * Calculates `n` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {number} n The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Gets the sum of the values in `collection`.
     *
     * @static
     * @memberOf _
     * @category Math
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 6]);
     * // => 10
     *
     * _.sum({ 'a': 4, 'b': 6 });
     * // => 10
     *
     * var objects = [
     *   { 'n': 4 },
     *   { 'n': 6 }
     * ];
     *
     * _.sum(objects, function(object) {
     *   return object.n;
     * });
     * // => 10
     *
     * // using the `_.property` callback shorthand
     * _.sum(objects, 'n');
     * // => 10
     */
    function sum(collection, iteratee, thisArg) {
      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = undefined;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      return iteratee.length == 1
        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
        : baseSum(collection, iteratee);
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.modArgs = modArgs;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.restParam = restParam;
    lodash.set = set;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.sortByOrder = sortByOrder;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.floor = floor;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.sum = sum;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.eq = isEqual;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        var filtered = this.__filtered__;
        if (filtered && !index) {
          return new LazyWrapper(this);
        }
        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

        var result = this.clone();
        if (filtered) {
          result.__takeCount__ = nativeMin(result.__takeCount__, n);
        } else {
          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type != LAZY_MAP_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone();
        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : property;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 1);
      return this.filter(function(value) {
        return !predicate(value);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
      return this.reverse().takeWhile(predicate, thisArg).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(POSITIVE_INFINITY);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
          retUnwrapped = /^(?:first|last)$/.test(methodName),
          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var args = retUnwrapped ? [1] : arguments,
            chainAll = this.__chain__,
            value = this.__wrapped__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var interceptor = function(value) {
          return (retUnwrapped && chainAll)
            ? lodashFunc(value, 1)[0]
            : lodashFunc.apply(undefined, arrayPush([value], args));
        };

        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          if (onlyLazy) {
            value = value.clone();
            value.__actions__.push(action);
            return func.call(value);
          }
          return lodashFunc.call(undefined, this.value())[0];
        }
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push(action);
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array` and `String` methods to `lodash.prototype`.
    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Map minified function names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = (lodashFunc.name + ''),
            names = realNames[key] || (realNames[key] = []);

        names.push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.concat = wrapperConcat;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Rhino with CommonJS support.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

/**
 * @author alteredq / http://alteredqualia.com/
 * @authod mrdoob / http://mrdoob.com/
 * @authod arodic / http://aleksandarrodic.com/
 * @authod fonserbc / http://fonserbc.github.io/
*/

THREE.StereoEffect = function ( renderer ) {

	var _stereo = new THREE.StereoCamera();
	_stereo.aspect = 0.5;

	this.setEyeSeparation = function ( eyeSep ) {

		_stereo.eyeSep = eyeSep;

	};

	this.setSize = function ( width, height ) {

		renderer.setSize( width, height );

	};

	this.render = function ( scene, camera ) {

		scene.updateMatrixWorld();

		if ( camera.parent === null ) camera.updateMatrixWorld();

		_stereo.update( camera );

		var size = renderer.getSize();

		renderer.clear();
		renderer.setScissorTest( true );

		renderer.setScissor( 0, 0, size.width / 2, size.height );
		renderer.setViewport( 0, 0, size.width / 2, size.height );
		renderer.render( scene, _stereo.cameraL );

		renderer.setScissor( size.width / 2, 0, size.width / 2, size.height );
		renderer.setViewport( size.width / 2, 0, size.width / 2, size.height );
		renderer.render( scene, _stereo.cameraR );

		renderer.setScissorTest( false );

	};

};

!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

module.exports = _dereq_('./lib/');

},{"./lib/":2}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var parser = _dereq_('socket.io-parser');
var Manager = _dereq_('./manager');
var debug = _dereq_('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_('./manager');
exports.Socket = _dereq_('./socket');

},{"./manager":3,"./socket":5,"./url":6,"debug":10,"socket.io-parser":44}],3:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var eio = _dereq_('engine.io-client');
var Socket = _dereq_('./socket');
var Emitter = _dereq_('component-emitter');
var parser = _dereq_('socket.io-parser');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var object = _dereq_('object-component');
var debug = _dereq_('debug')('socket.io-client:manager');
var indexOf = _dereq_('indexof');
var Backoff = _dereq_('backo2');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = 'closed';
  this.engine && this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":4,"./socket":5,"./url":6,"backo2":7,"component-bind":8,"component-emitter":9,"debug":10,"engine.io-client":11,"indexof":40,"object-component":41,"socket.io-parser":44}],4:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],5:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_('socket.io-parser');
var Emitter = _dereq_('component-emitter');
var toArray = _dereq_('to-array');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:socket');
var hasBin = _dereq_('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

},{"./on":4,"component-bind":8,"component-emitter":9,"debug":10,"has-binary":36,"socket.io-parser":44,"to-array":48}],6:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_('parseuri');
var debug = _dereq_('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":10,"parseuri":42}],7:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],8:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],9:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(_dereq_,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],11:[function(_dereq_,module,exports){

module.exports =  _dereq_('./lib/');

},{"./lib/":12}],12:[function(_dereq_,module,exports){

module.exports = _dereq_('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_('engine.io-parser');

},{"./socket":13,"engine.io-parser":25}],13:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_('./transports');
var Emitter = _dereq_('component-emitter');
var debug = _dereq_('debug')('engine.io-client:socket');
var index = _dereq_('indexof');
var parser = _dereq_('engine.io-parser');
var parseuri = _dereq_('parseuri');
var parsejson = _dereq_('parsejson');
var parseqs = _dereq_('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? '443' : '80';
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_('./transport');
Socket.transports = _dereq_('./transports');
Socket.parser = _dereq_('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    function close() {
      self.onClose('forced close');
      debug('socket closing - telling transport to close');
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener('upgrade', cleanupAndClose);
      self.removeListener('upgradeError', cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      self.once('upgrade', cleanupAndClose);
      self.once('upgradeError', cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":14,"./transports":15,"component-emitter":9,"debug":22,"engine.io-parser":25,"indexof":40,"parsejson":32,"parseqs":33,"parseuri":34}],14:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_('engine.io-parser');
var Emitter = _dereq_('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":9,"engine.io-parser":25}],15:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var XHR = _dereq_('./polling-xhr');
var JSONP = _dereq_('./polling-jsonp');
var websocket = _dereq_('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":16,"./polling-xhr":17,"./websocket":19,"xmlhttprequest":20}],16:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_('./polling');
var inherit = _dereq_('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":18,"component-inherit":21}],17:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var Polling = _dereq_('./polling');
var Emitter = _dereq_('component-emitter');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = 'ok';
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":18,"component-emitter":9,"component-inherit":21,"debug":22,"xmlhttprequest":20}],18:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parseqs = _dereq_('parseqs');
var parser = _dereq_('engine.io-parser');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_('xmlhttprequest');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":33,"xmlhttprequest":20}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parser = _dereq_('engine.io-parser');
var parseqs = _dereq_('parseqs');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = _dereq_('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":33,"ws":35}],20:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":38}],21:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],22:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console
    && 'function' == typeof console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":23}],23:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":24}],24:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],25:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_('./keys');
var hasBinary = _dereq_('has-binary');
var sliceBuffer = _dereq_('arraybuffer.slice');
var base64encoder = _dereq_('base64-arraybuffer');
var after = _dereq_('after');
var utf8 = _dereq_('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":26,"after":27,"arraybuffer.slice":28,"base64-arraybuffer":29,"blob":30,"has-binary":36,"utf8":31}],26:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],27:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],28:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],29:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],30:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],31:[function(_dereq_,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],32:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],33:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],34:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],35:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],36:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":37}],37:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],38:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = _dereq_('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":39}],39:[function(_dereq_,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],40:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],41:[function(_dereq_,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],42:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],43:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_('isarray');
var isBuf = _dereq_('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is-buffer":45,"isarray":46}],44:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_('debug')('socket.io-parser');
var json = _dereq_('json3');
var isArray = _dereq_('isarray');
var Emitter = _dereq_('component-emitter');
var binary = _dereq_('./binary');
var isBuf = _dereq_('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":43,"./is-buffer":45,"component-emitter":9,"debug":10,"isarray":46,"json3":47}],45:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],46:[function(_dereq_,module,exports){
module.exports=_dereq_(37)
},{}],47:[function(_dereq_,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],48:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}]},{},[1])
(1)
});

;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};


	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {

		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	} else {
		window.FastClick = FastClick;
	}
}());

/**
   orientationchange Polyfill
   Copyright (c) 2012, Jason LuBean (@jlubean)
   Licensed under the MIT license.

   This polyfill allows you to use "window.orientation" and to bind to the "orientationchange" event.  It has
   no dependencies on any libraries, but has support for using jQuery to bind to the "orientationchange" event.

  Because IE8 does not allow you to use attachEvent / fireEvent for custom events, you have to set the
  window.onorientationchange function:

    function handler() {
        if(window.orientation == 0 || window.orientation == 180) {
            // Do something useful in portrait mode
        } else {
            // Do something useful in landscape mode
        }
    }

    if(window.addEventListener) {
        window.addEventListener("orientationchange", handler, false);
    } else {
        window.onorientationchange = handler;
    }

    If you use jQuery:

    $(window).on('orientationchange', function() {
        if(window.orientation == 0 || window.orientation == 180) {
            // Do something useful in portrait mode
        } else {
            // Do something useful in landscape mode
        }
    });
 */
(function() {

  if(typeof window.orientation === 'undefined') {

    var lastOrientation = -1,
        orientationEventType = "orientationchange",
        resizeEventType = "resize";

    // Set orientation to landscape (90) if width > height
    // Set orientation to portait (0) if width <= height
    // Use document.body.offsetWidth for IE

    var getOrientation = function() {

      var ornttn = window.outerWidth > 0 ?
        (window.outerWidth > window.outerHeight ? 90 : 0) :
        (document.body.offsetWidth > document.body.offsetHeight ? 90 : 0);

      return ornttn;
    };

    // Dispatch/fire the "orientationchange" event when the
    // width==height boundary is crossed.

    var handleResize = function () {
      var evt;
      window.orientation = getOrientation();
      if(window.orientation != lastOrientation) {
        lastOrientation = window.orientation;
        if(document.createEvent) {
          evt = document.createEvent("HTMLEvents");
          evt.initEvent(orientationEventType, true, true);
          window.dispatchEvent(evt);
        } else {
          evt = document.createEventObject();
          evt.eventType = orientationEventType;
          evt.eventName = orientationEventType;
          if(window[orientationEventType]) {
            window[orientationEventType]();
          } else if(window['on'+orientationEventType]) {
            window['on'+orientationEventType]();
          } else if(typeof jQuery == 'function') {
            $(window).trigger(orientationEventType);
          }
        }
      }
    };

    //Listen for the window "resize" event

    if(window.addEventListener)
      window.addEventListener( resizeEventType, handleResize, false);
    else
      window["on"+resizeEventType] = handleResize;

    //Initialize the orientation

    window.orientation = getOrientation();
  }

})();

/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */

(function(global){

  // Passing in seed will seed this Noise instance
  function Noise(seed) {
    function Grad(x, y, z) {
      this.x = x; this.y = y; this.z = z;
    }

    Grad.prototype.dot2 = function(x, y) {
      return this.x*x + this.y*y;
    };

    Grad.prototype.dot3 = function(x, y, z) {
      return this.x*x + this.y*y + this.z*z;
    };

    this.grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
                 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
                 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];

    this.p = [151,160,137,91,90,15,
    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
    // To remove the need for index wrapping, double the permutation table length
    this.perm = new Array(512);
    this.gradP = new Array(512);

    this.seed(seed || 0);
  }

  // This isn't a very good seeding function, but it works ok. It supports 2^16
  // different seed values. Write something better if you need more seeds.
  Noise.prototype.seed = function(seed) {
    if(seed > 0 && seed < 1) {
      // Scale the seed out
      seed *= 65536;
    }

    seed = Math.floor(seed);
    if(seed < 256) {
      seed |= seed << 8;
    }

    var p = this.p;
    for(var i = 0; i < 256; i++) {
      var v;
      if (i & 1) {
        v = p[i] ^ (seed & 255);
      } else {
        v = p[i] ^ ((seed>>8) & 255);
      }

      var perm = this.perm;
      var gradP = this.gradP;
      perm[i] = perm[i + 256] = v;
      gradP[i] = gradP[i + 256] = this.grad3[v % 12];
    }
  };

  /*
  for(var i=0; i<256; i++) {
    perm[i] = perm[i + 256] = p[i];
    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
  }*/

  // Skewing and unskewing factors for 2, 3, and 4 dimensions
  var F2 = 0.5*(Math.sqrt(3)-1);
  var G2 = (3-Math.sqrt(3))/6;

  var F3 = 1/3;
  var G3 = 1/6;

  // 2D simplex noise
  Noise.prototype.simplex2 = function(xin, yin) {
    var n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin)*F2; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var t = (i+j)*G2;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      i1=1; j1=0;
    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      i1=0; j1=1;
    }
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    var y1 = y0 - j1 + G2;
    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
    var y2 = y0 - 1 + 2 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    i &= 255;
    j &= 255;

    var perm = this.perm;
    var gradP = this.gradP;
    var gi0 = gradP[i+perm[j]];
    var gi1 = gradP[i+i1+perm[j+j1]];
    var gi2 = gradP[i+1+perm[j+1]];
    // Calculate the contribution from the three corners
    var t0 = 0.5 - x0*x0-y0*y0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.5 - x1*x1-y1*y1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    var t2 = 0.5 - x2*x2-y2*y2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot2(x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70 * (n0 + n1 + n2);
  };

  // 3D simplex noise
  Noise.prototype.simplex3 = function(xin, yin, zin) {
    var n0, n1, n2, n3; // Noise contributions from the four corners

    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin+zin)*F3; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var k = Math.floor(zin+s);

    var t = (i+j+k)*G3;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    var z0 = zin-k+t;

    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
    // Determine which simplex we are in.
    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
    if(x0 >= y0) {
      if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
      else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
      else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
    } else {
      if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
      else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
      else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
    }
    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
    // c = 1/6.
    var x1 = x0 - i1 + G3; // Offsets for second corner
    var y1 = y0 - j1 + G3;
    var z1 = z0 - k1 + G3;

    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
    var y2 = y0 - j2 + 2 * G3;
    var z2 = z0 - k2 + 2 * G3;

    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
    var y3 = y0 - 1 + 3 * G3;
    var z3 = z0 - 1 + 3 * G3;

    // Work out the hashed gradient indices of the four simplex corners
    i &= 255;
    j &= 255;
    k &= 255;

    var perm = this.perm;
    var gradP = this.gradP;
    var gi0 = gradP[i+   perm[j+   perm[k   ]]];
    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];
    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];
    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];

    // Calculate the contribution from the four corners
    var t0 = 0.5 - x0*x0-y0*y0-z0*z0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.5 - x1*x1-y1*y1-z1*z1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
    }
    var t2 = 0.5 - x2*x2-y2*y2-z2*z2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
    }
    var t3 = 0.5 - x3*x3-y3*y3-z3*z3;
    if(t3<0) {
      n3 = 0;
    } else {
      t3 *= t3;
      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 32 * (n0 + n1 + n2 + n3);

  };

  // ##### Perlin noise stuff

  function fade(t) {
    return t*t*t*(t*(t*6-15)+10);
  }

  function lerp(a, b, t) {
    return (1-t)*a + t*b;
  }

  // 2D Perlin Noise
  Noise.prototype.perlin2 = function(x, y) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y);
    // Get relative xy coordinates of point within that cell
    x = x - X; y = y - Y;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255;

    // Calculate noise contributions from each of the four corners
    var perm = this.perm;
    var gradP = this.gradP;
    var n00 = gradP[X+perm[Y]].dot2(x, y);
    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);

    // Compute the fade curve value for x
    var u = fade(x);

    // Interpolate the four results
    return lerp(
        lerp(n00, n10, u),
        lerp(n01, n11, u),
       fade(y));
  };

  // 3D Perlin Noise
  Noise.prototype.perlin3 = function(x, y, z) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);
    // Get relative xyz coordinates of point within that cell
    x = x - X; y = y - Y; z = z - Z;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255; Z = Z & 255;

    // Calculate noise contributions from each of the eight corners
    var perm = this.perm;
    var gradP = this.gradP;
    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);
    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);
    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);
    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);
    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);
    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);
    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);
    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);

    // Compute the fade curve value for x, y, z
    var u = fade(x);
    var v = fade(y);
    var w = fade(z);

    // Interpolate
    return lerp(
        lerp(
          lerp(n000, n100, u),
          lerp(n001, n101, u), w),
        lerp(
          lerp(n010, n110, u),
          lerp(n011, n111, u), w),
       v);
  };

  if (typeof module === "object" && module && typeof module.exports === "object") {
    module.exports = Noise;
  } else if (typeof define === "function" && define.amd) {
    define([], function () { return Noise; } );
  } else {
    global.Noise = Noise;
  }

})(this);
